<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Rg">
  <meta name="description" content="Rg&#39;s blog">
  <meta name="keywords" content="blog, Hugo, Rust, Golang, Raft, 火箭少女, Rocket Girl">
  
  <link rel="prev" href="https://laohanlinux.github.io/2013/muduo-base-library-2/" />
  <link rel="next" href="https://laohanlinux.github.io/2015/cowboy/" />
  <link rel="canonical" href="https://laohanlinux.github.io/2014/muduo-simple-example/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           muduo simple example | Welcome to Rg Home
       
  </title>
  <meta name="title" content="muduo simple example | Welcome to Rg Home">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://laohanlinux.github.io"
    },
    "articleSection" : "posts",
    "name" : "muduo simple example",
    "headline" : "muduo simple example",
    "description" : "muduo 是一个linux 网络库，使用poll和epoll模式。 这些内容是本人在大学的时候，通过  &lt;&lt; c&#43;&#43;教程网 &gt;&gt;  所学的知识笔记. 已经过去好几年了，版本也是比较老的了，属于入门级别的教程； 如有错误，纯属正常!!!",
    "inLanguage" : "en-us",
    "author" : "Rg",
    "creator" : "Rg",
    "publisher": "Rg",
    "accountablePerson" : "Rg",
    "copyrightHolder" : "Rg",
    "copyrightYear" : "2014",
    "datePublished": "2014-07-01 01:22:24 &#43;0000 UTC",
    "dateModified" : "2014-07-01 01:22:24 &#43;0000 UTC",
    "url" : "https://laohanlinux.github.io/2014/muduo-simple-example/",
    "wordCount" : "8798",
    "keywords" : [ "muduo", "Welcome to Rg Home"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://laohanlinux.github.io">Welcome to Rg Home</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://laohanlinux.github.io">Welcome to Rg Home</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">muduo simple example</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://laohanlinux.github.io" rel="author">Rg</a> with ♥ 
                <span class="post-time">
                on <time datetime=2014-07-01 itemprop="datePublished">July 1, 2014</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://laohanlinux.github.io/categories/muduo/"> muduo </a>
                        <a href="https://laohanlinux.github.io/categories/network-program/"> network program </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          

<h2 id="42-四个-服务器设计模型">[42] 四个 服务器设计模型</h2>

<p>五个简单TCP协议（MuduoManual.pdf P50）
muduo库网络模型使用示例（sudoku求解服务器MuduoManual.pdf P35 ）</p>

<ul>
<li>reactor（一个IO线程）</li>
<li>reactor + threadpool (一个IO + 多个计算线程)</li>
<li>multiple reactor （多个IO线程）</li>
<li>one loop per thread + thread pool （多个IO线程 + 计算线程池）</li>
</ul>

<p>网络编程关注4个半事件：</p>

<ul>
<li>连接建立</li>
<li>连接断开</li>
<li>消息到达</li>
<li>信息发送完毕（对于低流量的服务来说，通常不需要关注该事件）</li>
</ul>

<p>如何实现server</p>

<ul>
<li>提供一个xxxServer类</li>
<li>在该类中包含一个TcpServer对象</li>
</ul>

<p>注册一些事件</p>

<ul>
<li>OnConnection </li>
<li>OnMessage</li>
<li>OnWriteComplete</li>
<li>TcpConnection::shutdown（）内部实现，只关闭写入这一半</li>
</ul>

<h3 id="下面的程序都是用来解-数独-的-数独的实现如下">下面的程序都是用来解 数独 的，数独的实现如下</h3>

<p>sudoku.h</p>

<pre><code class="language-c++">#ifndef MUDUO_EXAMPLES_SUDOKU_SUDOKU_H
#define MUDUO_EXAMPLES_SUDOKU_SUDOKU_H
 
 
#include &lt;muduo/base/Types.h&gt;
 
// FIXME, use (const char*, len) for saving memory copying.
muduo::string solveSudoku(const muduo::string&amp; puzzle);
const int kCells = 81;
 
#endif
</code></pre>

<p>sudoku.cc</p>

<pre><code class="language-c++">#include &quot;sudoku.h&quot;
 
#include &lt;vector&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
 
using namespace muduo;
 
struct Node;
typedef Node Column;
struct Node
{
    Node* left;
    Node* right;
    Node* up;
    Node* down;
    Column* col;
    int name;
    int size;
};
 
const int kMaxNodes = 1 + 81*4 + 9*9*9*4;
const int kMaxColumns = 400;
const int kRow = 100, kCol = 200, kBox = 300;
 
class SudokuSolver
{
 public:
    SudokuSolver(int board[kCells])
      : inout_(board),
        cur_node_(0)
    {
        stack_.reserve(100);
 
        root_ = new_column();
        root_-&gt;left = root_-&gt;right = root_;
        memset(columns_, 0, sizeof(columns_));
 
        bool rows[kCells][10] = { {false} };
        bool cols[kCells][10] = { {false} };
        bool boxes[kCells][10] = { {false} };
 
        for (int i = 0; i &lt; kCells; ++i) {
            int row = i / 9;
            int col = i % 9;
            int box = row/3*3 + col/3;
            int val = inout_[i];
            rows[row][val] = true;
            cols[col][val] = true;
            boxes[box][val] = true;
        }
 
        for (int i = 0; i &lt; kCells; ++i) {
            if (inout_[i] == 0) {
                append_column(i);
            }
        }
 
        for (int i = 0; i &lt; 9; ++i) {
            for (int v = 1; v &lt; 10; ++v) {
                if (!rows[i][v])
                    append_column(get_row_col(i, v));
                if (!cols[i][v])
                    append_column(get_col_col(i, v));
                if (!boxes[i][v])
                    append_column(get_box_col(i, v));
            }
        }
 
        for (int i = 0; i &lt; kCells; ++i) {
            if (inout_[i] == 0) {
                int row = i / 9;
                int col = i % 9;
                int box = row/3*3 + col/3;
                //int val = inout[i];
                for (int v = 1; v &lt; 10; ++v) {
                    if (!(rows[row][v] || cols[col][v] || boxes[box][v])) {
                        Node* n0 = new_row(i);
                        Node* nr = new_row(get_row_col(row, v));
                        Node* nc = new_row(get_col_col(col, v));
                        Node* nb = new_row(get_box_col(box, v));
                        put_left(n0, nr);
                        put_left(n0, nc);
                        put_left(n0, nb);
                    }
                }
            }
        }
    }
 
    bool solve()
    {
        if (root_-&gt;left == root_) {
            for (size_t i = 0; i &lt; stack_.size(); ++i) {
                Node* n = stack_[i];
                int cell = -1;
                int val = -1;
                while (cell == -1 || val == -1) {
                    if (n-&gt;name &lt; 100)
                        cell = n-&gt;name;
                    else
                        val = n-&gt;name % 10;
                    n = n-&gt;right;
                }
 
                //assert(cell != -1 &amp;&amp; val != -1);
                inout_[cell] = val;
            }
            return true;
        }
 
        Column* const col = get_min_column();
        cover(col);
        for (Node* row = col-&gt;down; row != col; row = row-&gt;down) {
            stack_.push_back(row);
            for (Node* j = row-&gt;right; j != row; j = j-&gt;right) {
                cover(j-&gt;col);
            }
            if (solve()) {
                return true;
            }
            stack_.pop_back();
            for (Node* j = row-&gt;left; j != row; j = j-&gt;left) {
                uncover(j-&gt;col);
            }
        }
        uncover(col);
        return false;
    }
 
 private:
 
    Column* root_;
    int*    inout_;
    Column* columns_[400];
    std::vector&lt;Node*&gt; stack_;
    Node    nodes_[kMaxNodes];
    int     cur_node_;
 
    Column* new_column(int n = 0)
    {
        assert(cur_node_ &lt; kMaxNodes);
        Column* c = &amp;nodes_[cur_node_++];
        memset(c, 0, sizeof(Column));
        c-&gt;left = c;
        c-&gt;right = c;
        c-&gt;up = c;
        c-&gt;down = c;
        c-&gt;col = c;
        c-&gt;name = n;
        return c;
    }
 
    void append_column(int n)
    {
        assert(columns_[n] == NULL);
 
        Column* c = new_column(n);
        put_left(root_, c);
        columns_[n] = c;
    }
 
    Node* new_row(int col)
    {
        assert(columns_[col] != NULL);
        assert(cur_node_ &lt; kMaxNodes);
 
        Node* r = &amp;nodes_[cur_node_++];
 
        //Node* r = new Node;
        memset(r, 0, sizeof(Node));
        r-&gt;left = r;
        r-&gt;right = r;
        r-&gt;up = r;
        r-&gt;down = r;
        r-&gt;name = col;
        r-&gt;col = columns_[col];
        put_up(r-&gt;col, r);
        return r;
    }
 
    int get_row_col(int row, int val)
    {
        return kRow+row*10+val;
    }
 
    int get_col_col(int col, int val)
    {
        return kCol+col*10+val;
    }
 
    int get_box_col(int box, int val)
    {
        return kBox+box*10+val;
    }
 
    Column* get_min_column()
    {
        Column* c = root_-&gt;right;
        int min_size = c-&gt;size;
        if (min_size &gt; 1) {
            for (Column* cc = c-&gt;right; cc != root_; cc = cc-&gt;right) {
                if (min_size &gt; cc-&gt;size) {
                    c = cc;
                    min_size = cc-&gt;size;
                    if (min_size &lt;= 1)
                        break;
                }
            }
        }
        return c;
    }
 
    void cover(Column* c)
    {
        c-&gt;right-&gt;left = c-&gt;left;
        c-&gt;left-&gt;right = c-&gt;right;
        for (Node* row = c-&gt;down; row != c; row = row-&gt;down) {
            for (Node* j = row-&gt;right; j != row; j = j-&gt;right) {
                j-&gt;down-&gt;up = j-&gt;up;
                j-&gt;up-&gt;down = j-&gt;down;
                j-&gt;col-&gt;size--;
            }
        }
    }
 
    void uncover(Column* c)
    {
        for (Node* row = c-&gt;up; row != c; row = row-&gt;up) {
            for (Node* j = row-&gt;left; j != row; j = j-&gt;left) {
                j-&gt;col-&gt;size++;
                j-&gt;down-&gt;up = j;
                j-&gt;up-&gt;down = j;
            }
        }
        c-&gt;right-&gt;left = c;
        c-&gt;left-&gt;right = c;
    }
 
    void put_left(Column* old, Column* nnew)
    {
        nnew-&gt;left = old-&gt;left;
        nnew-&gt;right = old;
        old-&gt;left-&gt;right = nnew;
        old-&gt;left = nnew;
    }
 
    void put_up(Column* old, Node* nnew)
    {
        nnew-&gt;up = old-&gt;up;
        nnew-&gt;down = old;
        old-&gt;up-&gt;down = nnew;
        old-&gt;up = nnew;
        old-&gt;size++;
        nnew-&gt;col = old;
    }
};
 
string solveSudoku(const string&amp; puzzle)
{
  assert(puzzle.size() == implicit_cast&lt;size_t&gt;(kCells));
 
  string result = &quot;NoSolution&quot;;
 
  int board[kCells] = { 0 };
  bool valid = true;
  for (int i = 0; i &lt; kCells; ++i)
  {
    board[i] = puzzle[i] - '0';
    valid = valid &amp;&amp; (0 &lt;= board[i] &amp;&amp; board[i] &lt;= 9);
  }
 
  if (valid)
  {
    SudokuSolver s(board);
    if (s.solve())
    {
      result.clear();
      result.resize(kCells);
      for (int i = 0; i &lt; kCells; ++i)
      {
        result[i] = static_cast&lt;char&gt;(board[i] + '0');
      }
    }
  }
  return result;
}
</code></pre>

<h3 id="reactor模型">reactor模型</h3>

<p>只有一个IO线程：这个IO线程既负责listenfd也负责connfd</p>

<pre><code class="language-c++">#include &quot;sudoku.h&quot;
 
#include &lt;muduo/base/Atomic.h&gt;
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Thread.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;utility&gt;
 
#include &lt;mcheck.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class SudokuServer
{
 public:
  SudokuServer(EventLoop* loop, const InetAddress&amp; listenAddr)
    : loop_(loop),
      server_(loop, listenAddr, &quot;SudokuServer&quot;),
      startTime_(Timestamp::now())
  {
    server_.setConnectionCallback(
        boost::bind(&amp;SudokuServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;SudokuServer::onMessage, this, _1, _2, _3));
  }
 
  void start()
  {
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)
  {
    LOG_DEBUG &lt;&lt; conn-&gt;name();
    size_t len = buf-&gt;readableBytes();
    while (len &gt;= kCells + 2)
    {
      const char* crlf = buf-&gt;findCRLF();
      if (crlf)
      {
        string request(buf-&gt;peek(), crlf);
        buf-&gt;retrieveUntil(crlf + 2);
        len = buf-&gt;readableBytes();
        if (!processRequest(conn, request))
        {
          conn-&gt;send(&quot;Bad Request!\r\n&quot;);
          conn-&gt;shutdown();
          break;
        }
      }
      else if (len &gt; 100) // id + &quot;:&quot; + kCells + &quot;\r\n&quot;
      {
        conn-&gt;send(&quot;Id too long!\r\n&quot;);
        conn-&gt;shutdown();
        break;
      }
      else
      {
        break;
      }
    }
  }
 
  bool processRequest(const TcpConnectionPtr&amp; conn, const string&amp; request)
  {
    string id;
    string puzzle;
    bool goodRequest = true;
 
    string::const_iterator colon = find(request.begin(), request.end(), ':');
    if (colon != request.end())
    {
      id.assign(request.begin(), colon);
      puzzle.assign(colon+1, request.end());
    }
    else
    {
      puzzle = request;
    }
 
    if (puzzle.size() == implicit_cast&lt;size_t&gt;(kCells))
    {
      LOG_DEBUG &lt;&lt; conn-&gt;name();
      string result = solveSudoku(puzzle);
      if (id.empty())
      {
        conn-&gt;send(result+&quot;\r\n&quot;);
      }
      else
      {
        conn-&gt;send(id+&quot;:&quot;+result+&quot;\r\n&quot;);
      }
    }
    else
    {
      goodRequest = false;
    }
    return goodRequest;
  }
 
  EventLoop* loop_;
  TcpServer server_;
  Timestamp startTime_;
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, tid = &quot; &lt;&lt; CurrentThread::tid();
  EventLoop loop;
  InetAddress listenAddr(9981);
  SudokuServer server(&amp;loop, listenAddr);
 
  server.start();
 
  loop.loop();
}
</code></pre>

<h3 id="multiple-reactor">multiple reactor</h3>

<ul>
<li>IO线程的数目多个</li>
<li>EventLoopThreadPoll IO线程池</li>
<li>直接设置server_.setThreadNum(numThreads)就OK了</li>
</ul>

<p>main reactor 负责listenfd accept , sub reactor  负责connfd, 使用roundbin轮叫策略
来一个连接，就选择下一个EventLoop，这样让多个连接分配给若干个EventLoop来处理，
而每个EventLoop属于一个IO线程，也就意味着，多个连接分配给若干个IO线程来处理。</p>

<pre><code class="language-c++">include &quot;sudoku.h&quot;
 
#include &lt;muduo/base/Atomic.h&gt;
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Thread.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;utility&gt;
 
#include &lt;mcheck.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class SudokuServer
{
 public:
  SudokuServer(EventLoop* loop, const InetAddress&amp; listenAddr, int numThreads)
    : loop_(loop),
      server_(loop, listenAddr, &quot;SudokuServer&quot;),
      numThreads_(numThreads),
      startTime_(Timestamp::now())
  {
    server_.setConnectionCallback(
        boost::bind(&amp;SudokuServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;SudokuServer::onMessage, this, _1, _2, _3));
    server_.setThreadNum(numThreads);
  }
 
  void start()
  {
    LOG_INFO &lt;&lt; &quot;starting &quot; &lt;&lt; numThreads_ &lt;&lt; &quot; threads.&quot;;
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)
  {
    LOG_DEBUG &lt;&lt; conn-&gt;name();
    size_t len = buf-&gt;readableBytes();
    while (len &gt;= kCells + 2)
    {
      const char* crlf = buf-&gt;findCRLF();
      if (crlf)
      {
        string request(buf-&gt;peek(), crlf);
        buf-&gt;retrieveUntil(crlf + 2);
        len = buf-&gt;readableBytes();
        if (!processRequest(conn, request))
        {
          conn-&gt;send(&quot;Bad Request!\r\n&quot;);
          conn-&gt;shutdown();
          break;
        }
      }
      else if (len &gt; 100) // id + &quot;:&quot; + kCells + &quot;\r\n&quot;
      {
        conn-&gt;send(&quot;Id too long!\r\n&quot;);
        conn-&gt;shutdown();
        break;
      }
      else
      {
        break;
      }
    }
  }
 
  bool processRequest(const TcpConnectionPtr&amp; conn, const string&amp; request)
  {
    string id;
    string puzzle;
    bool goodRequest = true;
 
    string::const_iterator colon = find(request.begin(), request.end(), ':');
    if (colon != request.end())
    {
      id.assign(request.begin(), colon);
      puzzle.assign(colon+1, request.end());
    }
    else
    {
      puzzle = request;
    }
 
    if (puzzle.size() == implicit_cast&lt;size_t&gt;(kCells))
    {
      LOG_DEBUG &lt;&lt; conn-&gt;name();
      string result = solveSudoku(puzzle);
      if (id.empty())
      {
        conn-&gt;send(result+&quot;\r\n&quot;);
      }
      else
      {
        conn-&gt;send(id+&quot;:&quot;+result+&quot;\r\n&quot;);
      }
    }
    else
    {
      goodRequest = false;
    }
    return goodRequest;
  }
 
  EventLoop* loop_;
  TcpServer server_;
  int numThreads_;
  Timestamp startTime_;
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, tid = &quot; &lt;&lt; CurrentThread::tid();
  int numThreads = 0;
  if (argc &gt; 1)
  {
    numThreads = atoi(argv[1]);
  }
  EventLoop loop;
  InetAddress listenAddr(9981);
  SudokuServer server(&amp;loop, listenAddr, numThreads);
 
  server.start();
 
  loop.loop();
}
</code></pre>

<h3 id="reactor-threadpool">reactor + threadPool</h3>

<ul>
<li>一个IO线程，多个计算thread的模式</li>
<li>EventLoop + threadpool + numThreads_</li>
</ul>

<pre><code class="language-c++">include &quot;sudoku.h&quot;
 
#include &lt;muduo/base/Atomic.h&gt;
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Thread.h&gt;
#include &lt;muduo/base/ThreadPool.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;utility&gt;
 
#include &lt;mcheck.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class SudokuServer
{
 public:
  SudokuServer(EventLoop* loop, const InetAddress&amp; listenAddr, int numThreads)
    : loop_(loop),
      server_(loop, listenAddr, &quot;SudokuServer&quot;),
      numThreads_(numThreads),
      startTime_(Timestamp::now())
  {
    server_.setConnectionCallback(
        boost::bind(&amp;SudokuServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;SudokuServer::onMessage, this, _1, _2, _3));
  }
 
  void start()
  {
    LOG_INFO &lt;&lt; &quot;starting &quot; &lt;&lt; numThreads_ &lt;&lt; &quot; threads.&quot;;
    threadPool_.start(numThreads_);//线程池的线程个数
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)
  {
    LOG_DEBUG &lt;&lt; conn-&gt;name();
    size_t len = buf-&gt;readableBytes();
    while (len &gt;= kCells + 2)
    {
      const char* crlf = buf-&gt;findCRLF();
      if (crlf)
      {
        string request(buf-&gt;peek(), crlf);
        buf-&gt;retrieveUntil(crlf + 2);
        len = buf-&gt;readableBytes();
        if (!processRequest(conn, request))
        {
          conn-&gt;send(&quot;Bad Request!\r\n&quot;);
          conn-&gt;shutdown();
          break;
        }
      }
      else if (len &gt; 100) // id + &quot;:&quot; + kCells + &quot;\r\n&quot;
      {
        conn-&gt;send(&quot;Id too long!\r\n&quot;);
        conn-&gt;shutdown();
        break;
      }
      else
      {
        break;
      }
    }
  }
 
  bool processRequest(const TcpConnectionPtr&amp; conn, const string&amp; request)
  {
    string id;
    string puzzle;
    bool goodRequest = true;
 
    string::const_iterator colon = find(request.begin(), request.end(), ':');
    if (colon != request.end())
    {
      id.assign(request.begin(), colon);
      puzzle.assign(colon+1, request.end());
    }
    else
    {
      puzzle = request;
    }
    /*计算线程中的线程进行处理*/
    if (puzzle.size() == implicit_cast&lt;size_t&gt;(kCells))
    {
      threadPool_.run(boost::bind(&amp;solve, conn, puzzle, id));
    }
    else
    {
      goodRequest = false;
    }
    return goodRequest;
  }
 
  static void solve(const TcpConnectionPtr&amp; conn,
                    const string&amp; puzzle,
                    const string&amp; id)
  {
    LOG_DEBUG &lt;&lt; conn-&gt;name();
    string result = solveSudoku(puzzle);
    /*这里处理完数据后，conn-&gt;send() 还是在IO线程中发送，而不是
在计算线程中处理
    */
    if (id.empty())
    {
      conn-&gt;send(result+&quot;\r\n&quot;);
    }
    else
    {
      conn-&gt;send(id+&quot;:&quot;+result+&quot;\r\n&quot;);
    }
  }
 
  EventLoop* loop_;
  TcpServer server_;
  ThreadPool threadPool_; //计算线程池
  int numThreads_;
  Timestamp startTime_;
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, tid = &quot; &lt;&lt; CurrentThread::tid();
  int numThreads = 0;
  if (argc &gt; 1)
  {
    numThreads = atoi(argv[1]);
  }
  EventLoop loop;
  InetAddress listenAddr(9981);
  SudokuServer server(&amp;loop, listenAddr, numThreads);
 
  server.start();
 
  loop.loop();
}
</code></pre>

<h3 id="multiple-reactors-threadpool">multiple reactors+threadpool</h3>

<p>EventLoopThreadPoll + threadpool + IOnumThreads_ + ThreadPoolnumThreads_</p>

<p><center><figure><img src="/images/ring.svg" data-sizes="auto" data-src="http://laohanlinux.github.io/images/img/blog/muduo-simple-example/multiplereactorthreadpool.png" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></center></p>

<pre><code class="language-c++">include &quot;sudoku.h&quot;
 
#include &lt;muduo/base/Atomic.h&gt;
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Thread.h&gt;
#include &lt;muduo/base/ThreadPool.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;utility&gt;
 
#include &lt;mcheck.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class SudokuServer
{
 public:
  SudokuServer(EventLoop* loop, const InetAddress&amp; listenAddr, int numThreads)
    : loop_(loop),
      server_(loop, listenAddr, &quot;SudokuServer&quot;),
      numThreads_(numThreads),
      startTime_(Timestamp::now())
  {
    server_.setConnectionCallback(
        boost::bind(&amp;SudokuServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;SudokuServer::onMessage, this, _1, _2, _3));
     server_.setThreadNum(numThreads);//IO线程池的初始化
  }
 
  void start()
  {
    LOG_INFO &lt;&lt; &quot;starting &quot; &lt;&lt; numThreads_ &lt;&lt; &quot; threads.&quot;;
    threadPool_.start(numThreads_);
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)
  {
    LOG_DEBUG &lt;&lt; conn-&gt;name();
    size_t len = buf-&gt;readableBytes();
    while (len &gt;= kCells + 2)
    {
      const char* crlf = buf-&gt;findCRLF();
      if (crlf)
      {
        string request(buf-&gt;peek(), crlf);
        buf-&gt;retrieveUntil(crlf + 2);
        len = buf-&gt;readableBytes();
        if (!processRequest(conn, request))
        {
          conn-&gt;send(&quot;Bad Request!\r\n&quot;);
          conn-&gt;shutdown();
          break;
        }
      }
      else if (len &gt; 100) // id + &quot;:&quot; + kCells + &quot;\r\n&quot;
      {
        conn-&gt;send(&quot;Id too long!\r\n&quot;);
        conn-&gt;shutdown();
        break;
      }
      else
      {
        break;
      }
    }
  }
 
  bool processRequest(const TcpConnectionPtr&amp; conn, const string&amp; request)
  {
    string id;
    string puzzle;
    bool goodRequest = true;
 
    string::const_iterator colon = find(request.begin(), request.end(), ':');
    if (colon != request.end())
    {
      id.assign(request.begin(), colon);
      puzzle.assign(colon+1, request.end());
    }
    else
    {
      puzzle = request;
    }
    /*计算线程中的线程进行处理*/
    if (puzzle.size() == implicit_cast&lt;size_t&gt;(kCells))
    {
      threadPool_.run(boost::bind(&amp;solve, conn, puzzle, id));
    }
    else
    {
      goodRequest = false;
    }
    return goodRequest;
  }
 
  static void solve(const TcpConnectionPtr&amp; conn,
                    const string&amp; puzzle,
                    const string&amp; id)
  {
    LOG_DEBUG &lt;&lt; conn-&gt;name();
    string result = solveSudoku(puzzle);
    /*这里处理完数据后，conn-&gt;send() 还是在IO线程中发送，而不是
在计算线程中处理
    */
    if (id.empty())
    {
      conn-&gt;send(result+&quot;\r\n&quot;);
    }
    else
    {
      conn-&gt;send(id+&quot;:&quot;+result+&quot;\r\n&quot;);
    }
  }
 
  EventLoop* loop_;
  TcpServer server_;
  ThreadPool threadPool_;
  int numThreads_;
  Timestamp startTime_;
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, tid = &quot; &lt;&lt; CurrentThread::tid();
  int numThreads = 0;
  if (argc &gt; 1)
  {
    numThreads = atoi(argv[1]);
  }
  EventLoop loop;
  InetAddress listenAddr(9981);
  SudokuServer server(&amp;loop, listenAddr, numThreads);
 
  server.start();
 
  loop.loop();
}
</code></pre>

<p>sudoKu 求解服务器，既是一个IO密集型，又是一个计算密集型的服务</p>

<p>IO线程池 + 计算线程池
计算时间如果比较久，就会使得IO线程阻塞，IO线程很快就用尽，就不处理大量的并发连接
一个IO线程+计算线程池
使用muduo 库来编程还是比较容易的，有兴趣的朋友可以试一下！</p>

<h2 id="43-文件传输服务器">[43] 文件传输服务器</h2>

<ul>
<li>文件传输（MuduoManual.pdf P57）</li>
<li>examples/filetransfer/download.cc</li>
<li>examples/filetransfer/download2.cc</li>
<li>examples/filetransfer/download3.cc</li>
</ul>

<p>tests/Filetransfer_test.cc</p>

<h3 id="单线程模式之一次性发完一个文件">单线程模式之一次性发完一个文件</h3>

<pre><code class="language-c++">#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
const char* g_file = NULL;
 
// FIXME: use FileUtil::readFile()
string readFile(const char* filename)
{
  string content;
  FILE* fp = ::fopen(filename, &quot;rb&quot;);
  if (fp)
  {
    // inefficient!!!
    const int kBufSize = 1024*1024;
    char iobuf[kBufSize];
    ::setbuffer(fp, iobuf, sizeof iobuf);
 
    char buf[kBufSize];
    size_t nread = 0;
    while ( (nread = ::fread(buf, 1, sizeof buf, fp)) &gt; 0)
    {
      content.append(buf, nread);
    }
    ::fclose(fp);
  }
  return content;
}
 
void onHighWaterMark(const TcpConnectionPtr&amp; conn, size_t len)
{
  LOG_INFO &lt;&lt; &quot;HighWaterMark &quot; &lt;&lt; len;
}
 
void onConnection(const TcpConnectionPtr&amp; conn)
{
  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
  if (conn-&gt;connected())
  {
    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file
             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();
    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, 64*1024);
    string fileContent = readFile(g_file);
    conn-&gt;send(fileContent);
    conn-&gt;shutdown();
    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;
  }
}
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();
  if (argc &gt; 1)
  {
    g_file = argv[1];
 
    EventLoop loop;
    InetAddress listenAddr(2021);
    TcpServer server(&amp;loop, listenAddr, &quot;FileServer&quot;);
    server.setConnectionCallback(onConnection);
    server.start();
    loop.loop();
  }
  else
  {
    fprintf(stderr, &quot;Usage: %s file_for_downloading\n&quot;, argv[0]);
  }
}
</code></pre>

<h3 id="单线程模型之分块发送文件">单线程模型之分块发送文件</h3>

<pre><code class="language-c++">#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
void onHighWaterMark(const TcpConnectionPtr&amp; conn, size_t len)
{
  LOG_INFO &lt;&lt; &quot;HighWaterMark &quot; &lt;&lt; len;
}
 
const int kBufSize = 64*1024;
const char* g_file = NULL;
 
void onConnection(const TcpConnectionPtr&amp; conn)
{
  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
  if (conn-&gt;connected())
  {
    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file
             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();
    /*高水位标志的回调函数*/
    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, kBufSize+1);
 
    FILE* fp = ::fopen(g_file, &quot;rb&quot;);
    if (fp)
    {
    /*设置conn 的上下文*/
      conn-&gt;setContext(fp);
      char buf[kBufSize];
      size_t nread = ::fread(buf, 1, sizeof buf, fp);
      conn-&gt;send(buf, nread);
    }
    /*发送完毕就shutdown connection*/
    else
    {
      conn-&gt;shutdown();
      LOG_INFO &lt;&lt; &quot;FileServer - no such file&quot;;
    }
  }
  /*如果连接关闭，那么就关闭文件指针*/
  else
  {
    if (!conn-&gt;getContext().empty())
    {
      FILE* fp = boost::any_cast&lt;FILE*&gt;(conn-&gt;getContext());
      if (fp)
      {
        ::fclose(fp);
      }
    }
  }
}
 
/*如果发完一块，还有其他块，那么接着发送，这只fp是保存在
 
connection的上下文中，所以是同一个文件指针*/
void onWriteComplete(const TcpConnectionPtr&amp; conn)
{
  FILE* fp = boost::any_cast&lt;FILE*&gt;(conn-&gt;getContext());
  char buf[kBufSize];
  size_t nread = ::fread(buf, 1, sizeof buf, fp);
  if (nread &gt; 0)
  {
    conn-&gt;send(buf, nread);
  }
  /*如果发完也关闭掉*/
  else
  {
    ::fclose(fp);
    fp = NULL;
    conn-&gt;setContext(fp);
    conn-&gt;shutdown();
    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;
  }
}
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();
  if (argc &gt; 1)
  {
    g_file = argv[1];
 
    EventLoop loop;
    InetAddress listenAddr(2021);
    TcpServer server(&amp;loop, listenAddr, &quot;FileServer&quot;);
    server.setConnectionCallback(onConnection);
    server.setWriteCompleteCallback(onWriteComplete);
    server.start();
    loop.loop();
  }
  else
  {
    fprintf(stderr, &quot;Usage: %s file_for_downloading\n&quot;, argv[0]);
  }
}
</code></pre>

<h3 id="单线程模型之分块发送-智能指针">单线程模型之分块发送（智能指针）</h3>

<pre><code class="language-c++">#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/shared_ptr.hpp&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
/*这个程序和第二个是一样，只是这里的文件指针是智能共享的，
不用我们手动关闭*/
 
void onHighWaterMark(const TcpConnectionPtr&amp; conn, size_t len)
{
  LOG_INFO &lt;&lt; &quot;HighWaterMark &quot; &lt;&lt; len;
}
 
const int kBufSize = 64*1024;
const char* g_file = NULL;
typedef boost::shared_ptr&lt;FILE&gt; FilePtr;
 
void onConnection(const TcpConnectionPtr&amp; conn)
{
  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
  if (conn-&gt;connected())
  {
    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file
             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();
    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, kBufSize+1);
 
    FILE* fp = ::fopen(g_file, &quot;rb&quot;);
    if (fp)
    {
    /*这里ctx接受两个参数，因为ctx不是类的指针，所以他不是调用delete
    来消费ctx指针，而是调用fclose这个函数来消费这个ctx指针*/
      FilePtr ctx(fp, ::fclose);
      conn-&gt;setContext(ctx);
      char buf[kBufSize];
      size_t nread = ::fread(buf, 1, sizeof buf, fp);
      conn-&gt;send(buf, nread);
    }
    else
    {
      conn-&gt;shutdown();
      LOG_INFO &lt;&lt; &quot;FileServer - no such file&quot;;
    }
  }
}
 
void onWriteComplete(const TcpConnectionPtr&amp; conn)
{
  const FilePtr&amp; fp = boost::any_cast&lt;const FilePtr&amp;&gt;(conn-&gt;getContext());
  char buf[kBufSize];
  size_t nread = ::fread(buf, 1, sizeof buf, get_pointer(fp));
  if (nread &gt; 0)
  {
    conn-&gt;send(buf, nread);
  }
  else
  {
    conn-&gt;shutdown();
    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;
  }
}
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();
  if (argc &gt; 1)
  {
    g_file = argv[1];
 
    EventLoop loop;
    InetAddress listenAddr(2021);
    TcpServer server(&amp;loop, listenAddr, &quot;FileServer&quot;);
    server.setConnectionCallback(onConnection);
    server.setWriteCompleteCallback(onWriteComplete);
    server.start();
    loop.loop();
  }
  else
  {
    fprintf(stderr, &quot;Usage: %s file_for_downloading\n&quot;, argv[0]);
  }
}
</code></pre>

<h2 id="44-45-muduo实现简单了聊天功能">[44-45] muduo实现简单了聊天功能</h2>

<h3 id="聊天服务器-muduomanual-pdf-p66">聊天服务器（MuduoManual.pdf P66）</h3>

<ul>
<li>examples/asio/chat/server.cc 单线程</li>
<li>examples/asio/chat/server_threaded.cc，多线程TcpServer，并用mutex来保护共享数据</li>
<li>examples/asio/chat/server_threaded_efficient.cc,借shared_ptr实现copy-on-write的手法来降低锁竞争</li>
<li>examples/asio/chat/server_threaded_highperformance.cc，采用thread local变量实现多线程高效转发</li>
</ul>

<p>消息分为包头与包体，每条消息有一个4字节的头部，以网络序存放字符串的长度。包体是一个字符串，字符串也不一定以’\0’结尾。比方说有两条消息&rdquo;hello&rdquo;和&rdquo;chenshuo&rdquo;，那么打包后的字节流是： <code>0x00,0x00,0x00,0x05, 'h','e','l','l','o',0x00,0x00,0x00,0x08,'c','h', 'e','n','s','h','u','o'</code> 共21字节。</p>

<p><center> <figure><img src="/images/ring.svg" data-sizes="auto" data-src="hhttp://laohanlinux.github.io/images/img/blog/muduo-simple-example/chat1.png" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></center></p>

<p><code>shared_ptr</code> 指针</p>

<p>借<code>shared_ptr</code>实现<code>copy on write</code></p>

<p><code>shared_ptr</code>是引用计数智能指针，如果当前只有一个观察者，那么引用计数为<code>1</code>,可以用<code>shared_ptr::unique()</code>来判断 对于<code>write</code>端，如果发现引用计数为<code>1</code>，这时可以安全地修改对象，不必担心有人在读它。 对于<code>read</code>端，在读之前把引用计数加<code>1</code>，读完之后减<code>1</code>，这样可以保证在读的期间其引用计数大于<code>1</code>，可以阻止并发写。 比较难的是，对于<code>write</code>端，如果发现引用计数大于<code>1</code>，该如何处理?既然要更新数据，肯定要加锁，如果这时候其他线程正在读，那么不能在原来的数据上修改，得创建一个副本，在副本上修改，修改完了再替换。如果没有用户在读，那么可以直接修改。</p>

<h3 id="code-h">code.h</h3>

<pre><code class="language-c++">#ifndef MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H
#define MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Buffer.h&gt;
#include &lt;muduo/net/Endian.h&gt;
#include &lt;muduo/net/TcpConnection.h&gt;
 
#include &lt;boost/function.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
 
class LengthHeaderCodec : boost::noncopyable
{
 public:
  typedef boost::function&lt;void (const muduo::net::TcpConnectionPtr&amp;,
                                const muduo::string&amp; message,
                                muduo::Timestamp)&gt; StringMessageCallback;
 
  explicit LengthHeaderCodec(const StringMessageCallback&amp; cb)
    : messageCallback_(cb)
  {
  }
/*消息到达的回调函数*/
  void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,
                 muduo::net::Buffer* buf,
                 muduo::Timestamp receiveTime)
  {
  /*这里可能有多条信息一起到达*/
    while (buf-&gt;readableBytes() &gt;= kHeaderLen) // kHeaderLen == 4
    {
      // FIXME: use Buffer::peekInt32()
        /*这里的消息包括消息头(包头)和消息尾(包体)*/
      const void* data = buf-&gt;peek(); //这里只是查看一下数据而已，并没有取出数据
      /*读出的是对方发过来的网络字节序(大端)的前4个字节(header)*/
      int32_t be32 = *static_cast&lt;const int32_t*&gt;(data); // SIGBUS
        /*把网络字节转为主机字节序*/
      const int32_t len = muduo::net::sockets::networkToHost32(be32);
        /*这里假设消息的包体长度不超过64k */
      if (len &gt; 65536 || len &lt; 0) //消息不合法
      {
        LOG_ERROR &lt;&lt; &quot;Invalid length &quot; &lt;&lt; len;
        conn-&gt;shutdown();  // FIXME: disable reading
        break;
      }
 
      else if (buf-&gt;readableBytes() &gt;= len + kHeaderLen)
      {
        buf-&gt;retrieve(kHeaderLen);
        /*这里还没有取出消息的包体，只是peek一下*/
        muduo::string message(buf-&gt;peek(), len);
        /*回调应用程序，让应用层来处理包体*/
        messageCallback_(conn, message, receiveTime);
        /*取出包体*/
        buf-&gt;retrieve(len);
      }
      /*未达到完整的一条消息*/
      else
      {
        break;
      }
    }
  }
 
  // FIXME: TcpConnectionPtr
    /*编码函数*/
  void send(muduo::net::TcpConnection* conn,
            const muduo::StringPiece&amp; message)
  {
    muduo::net::Buffer buf;
    buf.append(message.data(), message.size());
    int32_t len = static_cast&lt;int32_t&gt;(message.size());
    int32_t be32 = muduo::net::sockets::hostToNetwork32(len);
    buf.prepend(&amp;be32, sizeof be32);
    /*编完码后,发送出去*/
    conn-&gt;send(&amp;buf);
  }
 
 private:
  StringMessageCallback messageCallback_;
  const static size_t kHeaderLen = sizeof(int32_t);
};
</code></pre>

<h3 id="examples-asio-chat-server-cc-单线程">examples/asio/chat/server.cc 单线程</h3>

<pre><code class="language-c++">#include &quot;codec.h&quot;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;set&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
/*
Program :这是一个单线程的程序，不需要mutex
 
*/
 
class ChatServer : boost::noncopyable
{
 public:
  ChatServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
  : loop_(loop),
    server_(loop, listenAddr, &quot;ChatServer&quot;),
    /*消息编解码初始化，邋onString錗essage()为编解码完后的回调函数*/
    codec_(boost::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))
  {
    server_.setConnectionCallback(
        boost::bind(&amp;ChatServer::onConnection, this, _1));
    /*消息达到时的回调函数*/
    server_.setMessageCallback(
        boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));
  }
 
  void start()
  {
    server_.start();
  }
 
 private:
    /*只有一个IO线程，因而这里的connection_不需要mutex保护*/
    /*连接到达对等方对开连接时的回调函数*/
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
             &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;
             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
    /*如果已经连接了，回调*/
    if (conn-&gt;connected())
    {
      connections_.insert(conn);
    }
    /*连接断开*/
    else
    {
      connections_.erase(conn);
    }
  }
/*编解码class 的回调函数*/
/*转发消息给所有客户端*/
  void onStringMessage(const TcpConnectionPtr&amp;,
                       const string&amp; message,
                       Timestamp)
  {
  /*只有一个IO线程，因而这里的connections_不需要mutex保护;
    转发信息给所有客户端
  */
    for (ConnectionList::iterator it = connections_.begin();
        it != connections_.end();
        ++it)
    {
      codec_.send(get_pointer(*it), message);
    }
  }
 
  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;
  EventLoop* loop_;
  TcpServer server_;
  /*消息编解码class*/
  LengthHeaderCodec codec_;
  /*连接列表*/
  ConnectionList connections_;
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();
  if (argc &gt; 1)
  {
    EventLoop loop;
    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));
    InetAddress serverAddr(port);
    ChatServer server(&amp;loop, serverAddr);
    server.start();
    loop.loop();
  }
  else
  {
    printf(&quot;Usage: %s port\n&quot;, argv[0]);
  }
}
</code></pre>

<h3 id="examples-asio-chat-server-threaded-cc-多线程tcpserver-并用mutex来保护共享数据">examples/asio/chat/server_threaded.cc，多线程TcpServer，并用mutex来保护共享数据</h3>

<pre><code class="language-c++">#include &quot;codec.h&quot;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;set&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
/*这是一个典型的多线程聊天程序,multipleReactor 模型*/
 
class ChatServer : boost::noncopyable
{
 public:
  ChatServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
  : loop_(loop),
    server_(loop, listenAddr, &quot;ChatServer&quot;),
    codec_(boost::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))
  {
    server_.setConnectionCallback(
        boost::bind(&amp;ChatServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));
  }
 
  void setThreadNum(int numThreads)
  {
    server_.setThreadNum(numThreads);
  }
 
  void start()
  {
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
        &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;
        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
 
    MutexLockGuard lock(mutex_);
    if (conn-&gt;connected())
    {
      connections_.insert(conn);
    }
    else
    {
      connections_.erase(conn);
    }
  }
 
  void onStringMessage(const TcpConnectionPtr&amp;,
                       const string&amp; message,
                       Timestamp)
  {
  /*多线程需要保护连接列表*/
    MutexLockGuard lock(mutex_);
    for (ConnectionList::iterator it = connections_.begin();
        it != connections_.end();
        ++it)
    {
      codec_.send(get_pointer(*it), message);
    }
  }
 
  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;
  EventLoop* loop_;
  TcpServer server_;
  LengthHeaderCodec codec_;
  MutexLock mutex_;
  ConnectionList connections_;
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();
  if (argc &gt; 1)
  {
    EventLoop loop;
    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));
    InetAddress serverAddr(port);
    ChatServer server(&amp;loop, serverAddr);
    if (argc &gt; 2)
    {
      server.setThreadNum(atoi(argv[2]));
    }
    server.start();
    loop.loop();
  }
  else
  {
    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);
  }
}
</code></pre>

<h3 id="examples-asio-chat-server-threaded-efficient-cc-借shared-ptr实现copy-on-write的手法来降低锁竞争">examples/asio/chat/server_threaded_efficient.cc,借shared_ptr实现copy-on-write的手法来降低锁竞争</h3>

<pre><code class="language-c++">#include &quot;codec.h&quot;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
 
#include &lt;set&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
/*这是一个典型的多线程聊天程序multipleReactor 模型，
但是这里使用了一些编程技巧，达到一些优化*/
 
class ChatServer : boost::noncopyable
{
 public:
  ChatServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
  : loop_(loop),
    server_(loop, listenAddr, &quot;ChatServer&quot;),//loop : acceptor loop
    codec_(boost::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3)),
    connections_(new ConnectionList)//初始化时，share_ptr的引用为1
  {
    server_.setConnectionCallback(
        boost::bind(&amp;ChatServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));
  }
 
  void setThreadNum(int numThreads)
  {
    server_.setThreadNum(numThreads);
  }
 
  void start()
  {
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
        &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;
        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
 
    MutexLockGuard lock(mutex_);
    if (!connections_.unique())//说明引用计数大于1
    {//new ConnectionList(*connections_) 这段代码拷贝了一份ConnectionList
    //connections_原来的引用计数减1，而connections_现在的引用计数
    // 等于1
      connections_.reset(new ConnectionList(*connections_));
    }
    //所以这里断言才会成功
    assert(connections_.unique());
    /*在复本上修改,不会影响读者,所以读者在遍历列表的时候,
    不需要mutex保护*/
    if (conn-&gt;connected())
    {
      connections_-&gt;insert(conn);
    }
    else
    {
      connections_-&gt;erase(conn);
    }
  }
 
  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;
  typedef boost::shared_ptr&lt;ConnectionList&gt; ConnectionListPtr;
/*读操作*/
  void onStringMessage(const TcpConnectionPtr&amp;,
                       const string&amp; message,
                       Timestamp)
  {
  /*引用计数加1，mutex保护的临时区大大缩短*/
    ConnectionListPtr connections = getConnectionList();;//栈上变量
  /*可能大家会有疑问，不受mutex保护，写者更改了连接列表怎么办�*
    实际上，写者是在另一个副本上修改，所以无需担心*/
    for (ConnectionList::iterator it = connections-&gt;begin();
        it != connections-&gt;end();
        ++it)
    {
    /*这里也是无法减少第一个和第二个连接发送所需的时间,
    因为他们都是在同步发送的，就是所要等到转发完一条消息到
    一个connection后,然后才能转发下一个连接connection.
    实质就是调用这个函数的IO负责转发*/
      codec_.send(get_pointer(*it), message);
    }
        /*这个断言不一定成立
        assert(!connections.uniquer())。
        这是由于Onconnection()----&gt;connections_.reset(new ConnectionList(*connections_));*/
        /*当connection这个栈上的变量销毁的时候，引用计数减1*/
  }
 
  ConnectionListPtr getConnectionList()
  {
  /*保护区域变小了&lt;&gt;*/
    MutexLockGuard lock(mutex_);
    return connections_;
  }
 
  EventLoop* loop_;
  TcpServer server_; /*tcpserver服务器*/
  LengthHeaderCodec codec_;
  MutexLock mutex_;
  ConnectionListPtr connections_;
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();
  if (argc &gt; 1)
  {
    EventLoop loop;
    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));
    InetAddress serverAddr(port);
    ChatServer server(&amp;loop, serverAddr);
    if (argc &gt; 2)
    {
    /*IO线程个数*/
      server.setThreadNum(atoi(argv[2]));
    }
    server.start();
    loop.loop();
  }
  else
  {
    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);
  }
}
</code></pre>

<h3 id="examples-asio-chat-server-threaded-highperformance-cc-采用thread-local变量实现多线程高效转发">examples/asio/chat/server_threaded_highperformance.cc，采用thread local变量实现多线程高效转发</h3>

<pre><code class="language-c++">#include &quot;codec.h&quot;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/base/ThreadLocalSingleton.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;boost/bind.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
 
#include &lt;set&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
/*这个主要是针对第二个进行改正的，*/
class ChatServer : boost::noncopyable
{
 public:
  ChatServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
  : loop_(loop),
    server_(loop, listenAddr, &quot;ChatServer&quot;),
    codec_(boost::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))
  {
    server_.setConnectionCallback(
        boost::bind(&amp;ChatServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));
  }
 
  void setThreadNum(int numThreads)
  {
  /*设置sub IO线程池的大小*/
    server_.setThreadNum(numThreads);
  }
 
  void start()
  {/*设置线程的初始化函数*/
    server_.setThreadInitCallback(boost::bind(&amp;ChatServer::threadInit, this, _1));
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
             &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;
             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
 
    if (conn-&gt;connected())
    {
      connections_.instance().insert(conn);
    }
    else
    {
      connections_.instance().erase(conn);
    }
    cout&lt;&lt;&quot;connection adress :&quot;&lt;&lt;&amp;connections_&lt;&lt;&quot;\t&quot;&lt;&lt;&quot;connection size :&quot;&lt;&lt;connections_.size() ;
  }
 
  void onStringMessage(const TcpConnectionPtr&amp;,
                       const string&amp; message,
                       Timestamp)
  {
  /*把消息&quot;转发&quot;作为IO线程的任务来处理*/
    EventLoop::Functor f = boost::bind(&amp;ChatServer::distributeMessage, this, message);
    LOG_DEBUG;
    /*转发消息给所有客户端，高效率(多线程来转发),转发到不同的IO线程,
 
    */
    MutexLockGuard lock(mutex_);
    /*for 循环和f达到异步进行*/
    for (std::set&lt;EventLoop*&gt;::iterator it = loops_.begin();
        it != loops_.end();
        ++it)
    {/*
    1.让对应的IO线程来执行distributeMessage
    2.distributeMessage放到IO线程队列中执行，因此，这里的mutex_锁竞争大大减小
    3.distributeMesssge 不受mutex_保护
            */
      (*it)-&gt;queueInLoop(f);
    }
    LOG_DEBUG;
  }
 
  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;
 
  void distributeMessage(const string&amp; message)
  {
    LOG_DEBUG &lt;&lt; &quot;begin&quot;;
    // connectionList_是线程局部变量
    for (ConnectionList::iterator it = connections_.instance().begin();
        it != connections_.instance().end();
        ++it)
    {
      codec_.send(get_pointer(*it), message);
    }
    LOG_DEBUG &lt;&lt; &quot;end&quot;;
  }
/*IO线程执行前时的前回调函数*/
  void threadInit(EventLoop* loop)
  {
    assert(connections_.pointer() == NULL);
    /*实例化一个对象*/
    connections_.instance();
    assert(connections_.pointer() != NULL);
    MutexLockGuard lock(mutex_);
    loops_.insert(loop);
  }
 
  EventLoop* loop_; //loop_传递给server_
  TcpServer server_;
  LengthHeaderCodec codec_;
  /*线程局部单例变量，每个线程都有一个connections_(连接列表)实例*/
  ThreadLocalSingleton&lt;ConnectionList&gt; connections_;
 
  MutexLock mutex_;
  std::set&lt;EventLoop*&gt; loops_;        //eventLoop列表
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();
  if (argc &gt; 1)
  {
    EventLoop loop;//acceptor loop
    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));
    InetAddress serverAddr(port);
    ChatServer server(&amp;loop, serverAddr);
    if (argc &gt; 2)
    {
      server.setThreadNum(atoi(argv[2])); //多个subIO线程
    }
    server.start();
    loop.loop();
  }
  else
  {
    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);
  }
}
</code></pre>

<h2 id="47-限制服务器最大并发连接数">[47] 限制服务器最大并发连接数</h2>

<p>限制服务器最大并发连接数（<code>MuduoManual.pdf P108</code>）
用<code>Timing wheel</code>踢掉空闲连接（<code>MuduoManual.pdf P122</code>）</p>

<h3 id="timing-wheel">Timing wheel</h3>

<p>echo.h</p>

<pre><code class="language-c++">#ifndef MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H
#define MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H
 
#include &lt;muduo/net/TcpServer.h&gt;
//#include &lt;muduo/base/Types.h&gt;
 
#include &lt;boost/circular_buffer.hpp&gt;
#include &lt;boost/unordered_set.hpp&gt;
#include &lt;boost/version.hpp&gt;
 
#if BOOST_VERSION &lt; 104700
namespace boost
{
template &lt;typename T&gt;
inline size_t hash_value(const boost::shared_ptr&lt;T&gt;&amp; x)
{
  return boost::hash_value(x.get());
}
}
#endif
 
// RFC 862
class EchoServer
{
 public:
  EchoServer(muduo::net::EventLoop* loop,
             const muduo::net::InetAddress&amp; listenAddr,
             int idleSeconds);
 
  void start();
 
 private:
  void onConnection(const muduo::net::TcpConnectionPtr&amp; conn);
 
  void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,
                 muduo::net::Buffer* buf,
                 muduo::Timestamp time);
 
  void onTimer();
 
  void dumpConnectionBuckets() const;
 
  typedef boost::weak_ptr&lt;muduo::net::TcpConnection&gt; WeakTcpConnectionPtr;
 
  struct Entry : public muduo::copyable
  {
    explicit Entry(const WeakTcpConnectionPtr&amp; weakConn)
      : weakConn_(weakConn) //这是一个弱指针，所以创建一个对象时，引用计数不会加一
    {
    }
 
    ~Entry()
    {/*当引用计数为0时，会调用虚构函数；
将弱指针提升为强指针，然后关闭连接
    */
      muduo::net::TcpConnectionPtr conn = weakConn_.lock();
      if (conn)
      {
        conn-&gt;shutdown();
      }
    }
 
    WeakTcpConnectionPtr weakConn_;
  };
  typedef boost::shared_ptr&lt;Entry&gt; EntryPtr; //共享型Entry指针
  typedef boost::weak_ptr&lt;Entry&gt; WeakEntryPtr;//弱指针Entry型
  typedef boost::unordered_set&lt;EntryPtr&gt; Bucket;//共享型Entry集合
  typedef boost::circular_buffer&lt;Bucket&gt; WeakConnectionList;
 
  muduo::net::EventLoop* loop_;
  muduo::net::TcpServer server_;
  WeakConnectionList connectionBuckets_;
};
 
#endif  // MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H
</code></pre>

<p>echo.cc</p>

<pre><code class="language-c++">#include &quot;echo.h&quot;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
 
EchoServer::EchoServer(EventLoop* loop,
                       const InetAddress&amp; listenAddr,
                       int idleSeconds)
  : loop_(loop),
    server_(loop, listenAddr, &quot;EchoServer&quot;),
    connectionBuckets_(idleSeconds)
{
  server_.setConnectionCallback(
      boost::bind(&amp;EchoServer::onConnection, this, _1));
  server_.setMessageCallback(
      boost::bind(&amp;EchoServer::onMessage, this, _1, _2, _3));
  loop-&gt;runEvery(1.0, boost::bind(&amp;EchoServer::onTimer, this));
  connectionBuckets_.resize(idleSeconds);
  dumpConnectionBuckets();
}
 
void EchoServer::start()
{
  server_.start();
}
/*连接到来时的回调函数*/
void EchoServer::onConnection(const TcpConnectionPtr&amp; conn)
{
  LOG_INFO &lt;&lt; &quot;EchoServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
 
  if (conn-&gt;connected())
  {
  /*将连接和entryptr绑定
  引用计数为1，这是一个临时对象*/
    EntryPtr entry(new Entry(conn));
  /*插入到队尾，这时候引用计数位2*/
    connectionBuckets_.back().insert(entry);
  /*打出桶的连接数*/
    dumpConnectionBuckets();
    WeakEntryPtr weakEntry(entry);
    /*设置一下上下文，不使用强引用，防止引用计数加1
    这也是为了在OnMessage()函数调用时可以使用
    */
    conn-&gt;setContext(weakEntry);
  }//临时对象无效，引用计数减1
 
  else
  {
    assert(!conn-&gt;getContext().empty());
    /*输出一下引用计数*/
    WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));
    LOG_DEBUG &lt;&lt; &quot;Entry use_count = &quot; &lt;&lt; weakEntry.use_count();
  }
}
 
/*消息到达时的回调函数*/
void EchoServer::onMessage(const TcpConnectionPtr&amp; conn,
                           Buffer* buf,
                           Timestamp time)
{
  string msg(buf-&gt;retrieveAllAsString());
  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; &quot; echo &quot; &lt;&lt; msg.size()
           &lt;&lt; &quot; bytes at &quot; &lt;&lt; time.toString();
  conn-&gt;send(msg);
 
  assert(!conn-&gt;getContext().empty());
  WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));
  EntryPtr entry(weakEntry.lock());//+1
  if (entry)
  {
  /*在tail后面插入一个entry*/
    connectionBuckets_.back().insert(entry);//+1
    dumpConnectionBuckets();
  }//-1
}
 
/*时钟达到*/
void EchoServer::onTimer()
{
/*清空该位置上的集合，集合里面的指针引用计数都减1*/
  connectionBuckets_.push_back(Bucket());
  dumpConnectionBuckets();
}
/*打出桶的连接数*/
 
void EchoServer::dumpConnectionBuckets() const
{
  LOG_INFO &lt;&lt; &quot;size = &quot; &lt;&lt; connectionBuckets_.size();
  int idx = 0;
  /*弱引用*/
  for (WeakConnectionList::const_iterator bucketI = connectionBuckets_.begin();
      bucketI != connectionBuckets_.end();
      ++bucketI, ++idx)
  {
    const Bucket&amp; bucket = *bucketI;
    printf(&quot;[%d] len = %zd : &quot;, idx, bucket.size());
    for (Bucket::const_iterator it = bucket.begin();
        it != bucket.end();
        ++it)
    {
      bool connectionDead = (*it)-&gt;weakConn_.expired();
      printf(&quot;%p(%ld)%s, &quot;, get_pointer(*it), it-&gt;use_count(),
          connectionDead ? &quot; DEAD&quot; : &quot;&quot;);
    }
    puts(&quot;&quot;);
  }
}
</code></pre>

<p>sortedlist.h</p>

<pre><code class="language-c++">#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;boost/bind.hpp&gt;
#include &lt;list&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
// RFC 862
class EchoServer
{
 public:
  EchoServer(EventLoop* loop,
             const InetAddress&amp; listenAddr,
             int idleSeconds);
 
  void start()
  {
    server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn);
 
  void onMessage(const TcpConnectionPtr&amp; conn,
                 Buffer* buf,
                 Timestamp time);
 
  void onTimer();
 
  void dumpConnectionList() const;
 
  typedef boost::weak_ptr&lt;TcpConnection&gt; WeakTcpConnectionPtr;//弱连接指针
  typedef std::list&lt;WeakTcpConnectionPtr&gt; WeakConnectionList;//连接列表(元素是指针)
 
  struct Node : public muduo::copyable
  {
    Timestamp lastReceiveTime;  //该连接最后一次活跃时刻
    WeakConnectionList::iterator position; //该连接在连接列表中的位置
  };
 
  EventLoop* loop_;
  TcpServer server_;
  int idleSeconds_;
  WeakConnectionList connectionList_;//连接列表
};
 
EchoServer::EchoServer(EventLoop* loop,
                       const InetAddress&amp; listenAddr,
                       int idleSeconds)
  : loop_(loop),
    server_(loop, listenAddr, &quot;EchoServer&quot;),
    idleSeconds_(idleSeconds)
{
  server_.setConnectionCallback(
      boost::bind(&amp;EchoServer::onConnection, this, _1));
  server_.setMessageCallback(
      boost::bind(&amp;EchoServer::onMessage, this, _1, _2, _3));
  loop-&gt;runEvery(1.0, boost::bind(&amp;EchoServer::onTimer, this));
  dumpConnectionList();
}
 
void EchoServer::onConnection(const TcpConnectionPtr&amp; conn)
{
  LOG_INFO &lt;&lt; &quot;EchoServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;
           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
 
  if (conn-&gt;connected())
  {
    Node node;
    node.lastReceiveTime = Timestamp::now();
    connectionList_.push_back(conn);
    node.position = --connectionList_.end();
    conn-&gt;setContext(node);
  }
  else
  {
    assert(!conn-&gt;getContext().empty());
    const Node&amp; node = boost::any_cast&lt;const Node&amp;&gt;(conn-&gt;getContext());
    connectionList_.erase(node.position);
  }
  dumpConnectionList();
}
 
void EchoServer::onMessage(const TcpConnectionPtr&amp; conn,
                           Buffer* buf,
                           Timestamp time)
{
  string msg(buf-&gt;retrieveAllAsString());
  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; &quot; echo &quot; &lt;&lt; msg.size()
           &lt;&lt; &quot; bytes at &quot; &lt;&lt; time.toString();
  conn-&gt;send(msg);
 
  assert(!conn-&gt;getContext().empty());
  Node* node = boost::any_cast&lt;Node&gt;(conn-&gt;getMutableContext());
  node-&gt;lastReceiveTime = time;
  // move node inside list with list::splice()
  connectionList_.erase(node-&gt;position);
  connectionList_.push_back(conn);
  node-&gt;position = --connectionList_.end();
 
  dumpConnectionList();
}
/*时钟回调函数*/
void EchoServer::onTimer()
{
  dumpConnectionList();
  Timestamp now = Timestamp::now();
  for (WeakConnectionList::iterator it = connectionList_.begin();
      it != connectionList_.end();)
  {
    TcpConnectionPtr conn = it-&gt;lock();
    if (conn)
    {
      Node* n = boost::any_cast&lt;Node&gt;(conn-&gt;getMutableContext());
      double age = timeDifference(now, n-&gt;lastReceiveTime);
      if (age &gt; idleSeconds_)
      {/*剔除超时的连接*/
        conn-&gt;shutdown();
      }
      else if (age &lt; 0)
      {
        LOG_WARN &lt;&lt; &quot;Time jump&quot;;
        n-&gt;lastReceiveTime = now;
      }
      else
      {
        break;
      }
      ++it;
    }
    else
    {
      LOG_WARN &lt;&lt; &quot;Expired&quot;;
      it = connectionList_.erase(it);
    }
  }
}
 
void EchoServer::dumpConnectionList() const
{
  LOG_INFO &lt;&lt; &quot;size = &quot; &lt;&lt; connectionList_.size();
 
  for (WeakConnectionList::const_iterator it = connectionList_.begin();
      it != connectionList_.end(); ++it)
  {
    TcpConnectionPtr conn = it-&gt;lock();
    if (conn)
    {
      printf(&quot;conn %p\n&quot;, get_pointer(conn));
      const Node&amp; n = boost::any_cast&lt;const Node&amp;&gt;(conn-&gt;getContext());
      printf(&quot;    time %s\n&quot;, n.lastReceiveTime.toString().c_str());
    }
    else
    {
      printf(&quot;expired\n&quot;);
    }
  }
}
 
int main(int argc, char* argv[])
{
  EventLoop loop;
  InetAddress listenAddr(2007);
  int idleSeconds = 10;
  if (argc &gt; 1)
  {
    idleSeconds = atoi(argv[1]);
  }
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, idle seconds = &quot; &lt;&lt; idleSeconds;
  EchoServer server(&amp;loop, listenAddr, idleSeconds);
  server.start();
  loop.loop();
}
</code></pre>

<pre><code class="language-c++">#include &quot;echo.h&quot;
#include &lt;stdio.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
void testHash()
{
  boost::hash&lt;boost::shared_ptr&lt;int&gt; &gt; h;
  boost::shared_ptr&lt;int&gt; x1(new int(10));
  boost::shared_ptr&lt;int&gt; x2(new int(10));
  h(x1);
  assert(h(x1) != h(x2));
  x1 = x2;
  assert(h(x1) == h(x2));
  x1.reset();
  assert(h(x1) != h(x2));
  x2.reset();
  assert(h(x1) == h(x2));
}
 
int main(int argc, char* argv[])
{
  testHash();
  EventLoop loop;
  InetAddress listenAddr(2007);
  int idleSeconds = 10;
  if (argc &gt; 1)
  {
    idleSeconds = atoi(argv[1]);
  }
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, idle seconds = &quot; &lt;&lt; idleSeconds;
  EchoServer server(&amp;loop, listenAddr, idleSeconds);
  server.start();
  loop.loop();
}
</code></pre>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Rg </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://laohanlinux.github.io/2014/muduo-simple-example/>https://laohanlinux.github.io/2014/muduo-simple-example/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://laohanlinux.github.io/tags/muduo/">
                    #muduo</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://laohanlinux.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://laohanlinux.github.io/2013/muduo-base-library-2/" class="prev" rel="prev" title="muduo_base_library_2"><i class="iconfont icon-left"></i>&nbsp;muduo_base_library_2</a>
         
        
        <a href="https://laohanlinux.github.io/2015/cowboy/" class="next" rel="next" title="cowboy">cowboy&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
        
<div id="gitalk-container" style="border:0" ></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css/" style="border:0" >
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js/" style="border:0" ></script>
<script>
    const gitalk = new Gitalk({
        clientID: '88e50f263d090b13460f',
    clientSecret: 'f1007eb6cff0af3b461be3a4b73d808ab7058a21',
    repo: 'blog',
    owner: 'laohanlinux',
    admin: ['laohanlinux'],
    id: location.pathname, 
    distractionFreeMode: false 
    })

gitalk.render('gitalk-container')
</script>


    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2014 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://laohanlinux.github.io">Rg</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
