<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to Rg Home on Welcome to Rg Home</title>
    <link>https://laohanlinux.github.io/</link>
    <description>Recent content in Welcome to Rg Home on Welcome to Rg Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Apr 2019 17:20:45 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Embark on a New Journey</title>
      <link>https://laohanlinux.github.io/2019/04/04/embark-on-a-new-journey/</link>
      <pubDate>Thu, 04 Apr 2019 17:20:45 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/04/04/embark-on-a-new-journey/</guid>
      <description>

&lt;p&gt;好久没写博客了，整个人快要废了，是时候改写东西了。&lt;code&gt;Flag&lt;/code&gt;立得有点晚，希望能来得急.&lt;/p&gt;

&lt;h3 id=&#34;golang&#34;&gt;Golang&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[] Memory Manage&lt;/li&gt;
&lt;li&gt;[] GC&lt;/li&gt;
&lt;li&gt;[] Schedule&lt;/li&gt;
&lt;li&gt;[] Lock/RWLock&lt;/li&gt;
&lt;li&gt;[] Channel&lt;/li&gt;
&lt;li&gt;[] Select&lt;/li&gt;
&lt;li&gt;[] Map/SyncMap&lt;/li&gt;
&lt;li&gt;[] Slice&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;distribute-system&#34;&gt;Distribute System&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[] Tikv&lt;/li&gt;
&lt;li&gt;[] Use Tikv to design a Distribute KV support MVCC、sharding System&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;k8s&#34;&gt;k8s&lt;/h3&gt;

&lt;p&gt;如果有机会，也实践一下&lt;code&gt;k8s&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Memory Manager</title>
      <link>https://laohanlinux.github.io/2019/04/04/go-memory-manager/</link>
      <pubDate>Thu, 04 Apr 2019 17:12:18 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/04/04/go-memory-manager/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;内存管理是&lt;code&gt;runtime&lt;/code&gt;比较重要的一部分，&lt;code&gt;Go&lt;/code&gt;内存管理算法来至于&lt;code&gt;TCMalloc&lt;/code&gt;，非常类似。&lt;code&gt;tcmalloc&lt;/code&gt;已经发展好长一段时间了，是非常高效的一种内存管理算法，下面简单聊一下&lt;code&gt;tcmalloc&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;tcmalloc&#34;&gt;TCMalloc&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tcmalloc&lt;/code&gt;采用分层的设计，其内存对象被划分为&lt;code&gt;Small&lt;/code&gt;、&lt;code&gt;Medium&lt;/code&gt;、&lt;code&gt;Large&lt;/code&gt;三个等级，每个等级的对象占用内存各不相同。&lt;/p&gt;

&lt;h3 id=&#34;memory-level&#34;&gt;Memory Level&lt;/h3&gt;

&lt;h4 id=&#34;small&#34;&gt;Small&lt;/h4&gt;

&lt;h4 id=&#34;medium&#34;&gt;Medium&lt;/h4&gt;

&lt;h4 id=&#34;large&#34;&gt;Large&lt;/h4&gt;

&lt;h3 id=&#34;层次&#34;&gt;层次&lt;/h3&gt;

&lt;h4 id=&#34;thread-cache&#34;&gt;Thread Cache&lt;/h4&gt;

&lt;h4 id=&#34;centralcache&#34;&gt;CentralCache&lt;/h4&gt;

&lt;h4 id=&#34;pageheap&#34;&gt;PageHeap&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Nothing</title>
      <link>https://laohanlinux.github.io/about/</link>
      <pubDate>Thu, 04 Apr 2019 13:07:28 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/about/</guid>
      <description>&lt;p&gt;Talk is cheap, Show me the code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rocket Girls</title>
      <link>https://laohanlinux.github.io/2019/04/04/rocket-girls/</link>
      <pubDate>Thu, 04 Apr 2019 00:45:37 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/04/04/rocket-girls/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcgy1g1pyawo1wjj30zk0j142h.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2019/03/30&lt;/code&gt;看了人生中的第一场演唱会，总体来说，比较满足，唯一不爽的是坐得太远了，看不清！😂应该买前排的，涨涨经验也好，起码得携带个望眼镜，否则总能看看投影了。&lt;/p&gt;

&lt;p&gt;写写经过吧!&lt;/p&gt;

&lt;h2 id=&#34;买票&#34;&gt;买票&lt;/h2&gt;

&lt;p&gt;其实在去年的时候，主办方就安排火少的第一场&lt;code&gt;Flower&lt;/code&gt;主题演出在广州开，哥一大早就在大麦网预订了&lt;code&gt;960&lt;/code&gt;的票，可惜到快要开的时候，既然说是春运安全问题给停掉了。等到3月份的时候，不知道啥时候，主办方把票都出售完了，没办法啊，那就到闲鱼网碰碰运气呗，最后买了一张&lt;code&gt;480&lt;/code&gt;的票，黄牛竟然开口价买到&lt;code&gt;800&lt;/code&gt;，这还不如去抢算了。杀价到&lt;code&gt;500&lt;/code&gt;成交，真心多一毛钱都不想给黄牛。&lt;/p&gt;

&lt;p&gt;本来是想买杨超越的团票，可惜找了好久都没有，可能是超越人气太高了！中间也有&lt;code&gt;sunnee&lt;/code&gt;的票，可是对方一听说是超越的粉丝，就不卖了！😂😂😂&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tKfTcgy1g1q050gxc9j311i0u0b2e.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;应援&#34;&gt;应援&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tKfTcgy1g1qhtpb3wqj30sg0lcjyg.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tKfTcgy1g1qhupt3p3j30lc0sgadl.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tKfTcgy1g1qhuwmlwwj30lc0sggql.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcgy1g1qhvacm0zj30lc0sg7gk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcgy1g1qhvfln7ij30lc0sgqbg.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tKfTcgy1g1qhvs57m8j30sg0lc7bd.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;现场&#34;&gt;现场&lt;/h2&gt;

&lt;h3 id=&#34;开场白&#34;&gt;开场白&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34;  src=&#34;https://v.qq.com/txp/iframe/player.html?vid=a0857e6d2gs&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=v08573uc8ib&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
从现场看，孟美岐、吴宣仪、sunnee、杨超越的粉丝人数相差不大，接下来就是张紫宁、小七、Yami、傅菁、段奥娟、小彩虹、李紫婷。&lt;/p&gt;

&lt;h3 id=&#34;rocket-girl&#34;&gt;Rocket Girl&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=t0857f59bq1&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
是我啊，是我啊！😃&lt;/p&gt;

&lt;h3 id=&#34;土味情话&#34;&gt;土味情话&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=j0857bf160r&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;大娟faded&#34;&gt;大娟Faded&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=g0857r6x4h3&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;福利&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://youtu.be/y9HaphHtzCg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://youtu.be/y9HaphHtzCg&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;solo&#34;&gt;Solo&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=g0857r6x4h3&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;生而为赢&#34;&gt;生而为赢&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=v0857fkutxr&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;服装不错，舞蹈也ok！&lt;/p&gt;

&lt;h3 id=&#34;横冲直撞下一站&#34;&gt;横冲直撞下一站&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;   width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=p0857lq0stu&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
运动风！&lt;/p&gt;

&lt;h3 id=&#34;混奏&#34;&gt;混奏&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;   width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=l08571x0v6t&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;卡路里&#34;&gt;卡路里&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=q08572xwdv6&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
好奶的卡路里&lt;/p&gt;

&lt;h3 id=&#34;light&#34;&gt;Light&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=r0857k1zdhv&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
有些伤感的&lt;code&gt;Light&lt;/code&gt;，2年限团不容易，望大家都工作顺利，身体健康！&lt;/p&gt;

&lt;h2 id=&#34;离场&#34;&gt;离场&lt;/h2&gt;

&lt;p&gt;希望明年还有火少的演唱会吧！&lt;/p&gt;

&lt;h3 id=&#34;有感&#34;&gt;有感&lt;/h3&gt;

&lt;p&gt;在知乎上看到门票的问题，感到有些痛心，试想一下，从大老远跑过来，一句话-&lt;strong&gt;没票&lt;/strong&gt;就把人给打发了，这是什么心情。果然商人重利益，百年不变。&lt;/p&gt;

&lt;p&gt;如何评价2019年3月30日火箭少女101广州演唱会？ - 知乎
&lt;a href=&#34;https://www.zhihu.com/question/317403907&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.zhihu.com/question/317403907&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go内存管理</title>
      <link>https://laohanlinux.github.io/2019/03/03/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 03 Mar 2019 17:12:18 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/03/03/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;内存管理是&lt;code&gt;runtime&lt;/code&gt;比较重要的一部分，&lt;code&gt;Go&lt;/code&gt;内存管理算法来至于&lt;code&gt;TCMalloc&lt;/code&gt;，非常类似。&lt;code&gt;tcmalloc&lt;/code&gt;已经发展好长一段时间了，是非常高效的一种内存管理算法，下面简单聊一下&lt;code&gt;tcmalloc&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;tcmalloc&#34;&gt;TCMalloc&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tcmalloc&lt;/code&gt;采用分层的设计，其内存对象被划分为&lt;code&gt;Small&lt;/code&gt;、&lt;code&gt;Medium&lt;/code&gt;、&lt;code&gt;Large&lt;/code&gt;三个等级，每个等级的对象占用内存各不相同。&lt;/p&gt;

&lt;h3 id=&#34;memory-level&#34;&gt;Memory Level&lt;/h3&gt;

&lt;h4 id=&#34;small&#34;&gt;Small&lt;/h4&gt;

&lt;h4 id=&#34;medium&#34;&gt;Medium&lt;/h4&gt;

&lt;h4 id=&#34;large&#34;&gt;Large&lt;/h4&gt;

&lt;h3 id=&#34;层次&#34;&gt;层次&lt;/h3&gt;

&lt;h4 id=&#34;thread-cache&#34;&gt;Thread Cache&lt;/h4&gt;

&lt;h4 id=&#34;centralcache&#34;&gt;CentralCache&lt;/h4&gt;

&lt;h4 id=&#34;pageheap&#34;&gt;PageHeap&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>raft源码分析</title>
      <link>https://laohanlinux.github.io/2017/09/11/raft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 11 Sep 2017 12:08:30 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2017/09/11/raft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;p&gt;这篇文章主要是从源码的级别来看&lt;code&gt;Raft&lt;/code&gt;算法的实现。在网上找到了一个简化版：&lt;a href=&#34;https://github.com/peterbourgon/raft&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;源码&lt;/a&gt;.
一个&lt;code&gt;Server&lt;/code&gt;结构代表&lt;code&gt;Raft&lt;/code&gt;网络中的一个&lt;code&gt;节点&lt;/code&gt;。节点会创建一个&lt;code&gt;Server&lt;/code&gt;，并且通过&lt;code&gt;端(peers)&lt;/code&gt;接口的方式暴露给其他节点。
传输层采用&lt;code&gt;http&lt;/code&gt;包装，&lt;code&gt;端对端&lt;/code&gt;通信通过&lt;code&gt;rest http&lt;/code&gt;方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;|http transport| ---&amp;gt; |peers| ---&amp;gt; |server|
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;项目简介&#34;&gt;项目简介&lt;/h1&gt;

&lt;h2 id=&#34;节点的增加和删除&#34;&gt;节点的增加和删除&lt;/h2&gt;

&lt;p&gt;支持动态增删节点，采用一个简单的&lt;code&gt;共识&lt;/code&gt;算法(节点更新时，接受配置更新的节点需要超过1/2，即新集群要大于旧集群)。&lt;/p&gt;

&lt;h2 id=&#34;roadmap&#34;&gt;roadmap&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;leader选举&lt;/li&gt;
&lt;li&gt;日志复制&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;http 传输层&lt;/li&gt;
&lt;li&gt;配置变更&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，还有一些是未完成的
- net/rpc 传输层或者其他类型的传输层
- 日志压缩
- 快照安装以及恢复
- 完整的&lt;code&gt;demo&lt;/code&gt;应用
- 一些比较复杂的测试用例
  具体细节，看下面的代码分析。&lt;/p&gt;

&lt;h1 id=&#34;源码分析&#34;&gt;源码分析&lt;/h1&gt;

&lt;h2 id=&#34;源码目录结构&#34;&gt;源码目录结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;├── JOINT-CONSENSUS.md
├── LICENSE
├── README.md
├── configuration.go // 配置
├── example_test.go // demo
├── log.go // 日志
├── log_test.go // 日志测试模块
├── peers.go // 端
├── peers_test.go // 端模块
├── rpc.go // rpc 对象模块
├── server.go //  server模块
├── server_internals_test.go // server内部测试模块
├── server_test.go //  server测试模块
├── transport.go // 传输层
└── transport_test.go // 传输层模块
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;主要的数据结构&#34;&gt;主要的数据结构&lt;/h2&gt;

&lt;h3 id=&#34;rpc-go&#34;&gt;rpc.go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 日志追加
type appendEntriesTuple struct {
        // 日志追加请求
       	Request  appendEntries 
       	// 应答通道
       	Response chan appendEntriesResponse 
}
// 投票选举
type requestVoteTuple struct {
        // 选举内容
       	Request  requestVote 
       	// 选举结构应答
       	Response chan requestVoteResponse
}

// appendEntries represents an appendEntries RPC.
// 日志追加-实体
type appendEntries struct {
        // 任期号
       	Term         uint64     `json:&amp;quot;term&amp;quot;` 
   	    // leader 标识
       	LeaderID     uint64     `json:&amp;quot;leader_id&amp;quot;` 
   	    // 前一个日志索引
       	PrevLogIndex uint64     `json:&amp;quot;prev_log_index&amp;quot;` 
       	// 前一个日志任期号
       	PrevLogTerm  uint64     `json:&amp;quot;prev_log_term&amp;quot;` 
       	// 要追加的实体数组-支持批量追加
       	Entries      []logEntry `json:&amp;quot;entries&amp;quot;` 
       	// 已经committed的缩影
       	CommitIndex  uint64     `json:&amp;quot;commit_index&amp;quot;` 
}

// appendEntriesResponse represents the response to an appendEntries RPC.
// 日志追加应答
type appendEntriesResponse struct {
        // 应答节点的任期号
       	Term    uint64 `json:&amp;quot;term&amp;quot;` 
       	// 是否追加成功
       	Success bool   `json:&amp;quot;success&amp;quot;` 
       	// 失败的原因
       	reason  string 
}

// requestVote represents a requestVote RPC.
// 投票请求实体
type requestVote struct {
         // 发起者的任期号 
       	Term         uint64 `json:&amp;quot;term&amp;quot;`
   	    // 发起者的id
       	CandidateID  uint64 `json:&amp;quot;candidate_id&amp;quot;`
   	    // 发起者的最新条目
       	LastLogIndex uint64 `json:&amp;quot;last_log_index&amp;quot;`
   	    // 发起者的最新任期号
       	LastLogTerm  uint64 `json:&amp;quot;last_log_term&amp;quot;`
}

// requestVoteResponse represents the response to a requestVote RPC.
// 投票应答
type requestVoteResponse struct {
        // 应答者任期号
       	Term        uint64 `json:&amp;quot;term&amp;quot;`
   	    // 应答结果，true赞同，false反对
       	VoteGranted bool   `json:&amp;quot;vote_granted&amp;quot;`
        // 反对原因
       	reason      string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;log-go&#34;&gt;log.go&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/raft-rs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
        // 任期号太小
       	errTermTooSmall    = errors.New(&amp;quot;term too small&amp;quot;)
       	// 日志索引太小
       	errIndexTooSmall   = errors.New(&amp;quot;index too small&amp;quot;)
       	// 日志缩影太大
       	errIndexTooBig     = errors.New(&amp;quot;commit index too big&amp;quot;)
       	// 日志条目内容已损坏
       	errInvalidChecksum = errors.New(&amp;quot;invalid checksum&amp;quot;)
	   // 无效的命令
       	errNoCommand       = errors.New(&amp;quot;no command&amp;quot;)
       	// 错误的日志索引
       	errBadIndex        = errors.New(&amp;quot;bad index&amp;quot;)
       	// 错误任期号
       	errBadTerm         = errors.New(&amp;quot;bad term&amp;quot;)
)
// 日志结构
type raftLog struct {
        // 日志读写锁
       	sync.RWMutex
       	// 日志存储接口
       	store     io.Writer
   	    // 日志镜像，现在存储于内存
       	entries   []logEntry
       	// 下一条日志commit索引
       	commitPos int
       	// &amp;quot;操作&amp;quot;的回调函数，这个函数比较重要，可以&amp;quot;操作集合&amp;quot;镜像，
       	// 在快照时，只需要将&amp;quot;结果&amp;quot;快到存储层即可
       	apply     func(uint64, []byte) []byte
}

func newRaftLog(store io.ReadWriter, apply func(uint64, []byte) []byte) *raftLog {
       	l := &amp;amp;raftLog{
       		store:     store,
       		entries:   []logEntry{},
       		commitPos: -1, // no commits to begin with
       		apply:     apply,
       	}
       	l.recover(store)
       	return l
}

// recover reads from the log&#39;s store, to populate the log with log entries
// from persistent storage. It should be called once, at log instantiation.
// 日志恢复，当服务重启时，重建日志条目(一般重建都是居于于快照和日志的，可是这里没有实现快照，所以从日志中重建即可)
// 1、这里的日志时commited之后的日志，所以重建时，commitPos也会更新
// 2、重建日志条目，会调用apply函数，对日志进行处理，这个函数相当于&amp;quot;状态机&amp;quot;功能；如果有快照(相当于Redis 的RDB)，先将安装快照，再恢复日志(相当于Redis 的aof)
func (l *raftLog) recover(r io.Reader) error {
       	for {
       		var entry logEntry
       		switch err := entry.decode(r); err {
       		case io.EOF:
       			return nil // successful completion
       		case nil:
       			if err := l.appendEntry(entry); err != nil {
       				return err
       			}
       			l.commitPos++
       			l.apply(entry.Index, entry.Command)
       		default:
       			return err // unsuccessful completion
       		}
       	}
}

// entriesAfter returns a slice of log entries after (i.e. not including) the
// passed index, and the term of the log entry specified by index, as a
// convenience to the caller. (This function is only used by a leader attempting
// to flush log entries to its followers.)
//
// This function is called to populate an AppendEntries RPC. That implies they
// are destined for a follower, which implies the application of the commands
// should have the response thrown away, which implies we shouldn&#39;t pass a
// commandResponse channel (see: commitTo implementation). In the normal case,
// the raftLogEntries we return here will get serialized as they pass thru their
// transport, and lose their commandResponse channel anyway. But in the case of
// a LocalPeer (or equivalent) this doesn&#39;t happen. So, we must make sure to
// proactively strip commandResponse channels.
// 检索index之后的日志条目
func (l *raftLog) entriesAfter(index uint64) ([]logEntry, uint64) {
       	l.RLock()
       	defer l.RUnlock()

  		// 1.检索出index对应term以及在实体集合entries中的位置Pos
       	pos := 0
       	lastTerm := uint64(0)
       	for ; pos &amp;lt; len(l.entries); pos++ {
       		if l.entries[pos].Index &amp;gt; index {
       			break
       		}
       		lastTerm = l.entries[pos].Term
       	}

       	a := l.entries[pos:]
       	if len(a) == 0 {
       		return []logEntry{}, lastTerm
       	}
		// 除去command Response channel
       	return stripResponseChannels(a), lastTerm
}

func stripResponseChannels(a []logEntry) []logEntry {
       	stripped := make([]logEntry, len(a))
       	for i, entry := range a {
       		stripped[i] = logEntry{
       			Index:           entry.Index,
       			Term:            entry.Term,
       			Command:         entry.Command,
       			commandResponse: nil,
       		}
       	}
       	return stripped
}

// contains returns true if a log entry with the given index and term exists in
// the log.
// 判断是够包含{term, index}条目
func (l *raftLog) contains(index, term uint64) bool {
       	l.RLock()
       	defer l.RUnlock()

       	// It&#39;s not necessarily true that l.entries[i] has index == i.
       	for _, entry := range l.entries {
       		if entry.Index == index &amp;amp;&amp;amp; entry.Term == term {
       			return true
       		}
       		if entry.Index &amp;gt; index || entry.Term &amp;gt; term {
       			break
       		}
       	}
       	return false
}

// 判断{term, index}是否为最新的日志条目，如果是,则将则将在其之后的日志清理掉,
// 这个条目应该在[commit_index, last_index]范围内
func (l *raftLog) ensureLastIs(index, term uint64) error {
       	l.Lock()
       	defer l.Unlock()

       	// Taken loosely from benbjohnson&#39;s impl

       	if index &amp;lt; l.getCommitIndexWithLock() {
       		return errIndexTooSmall
       	}

       	if index &amp;gt; l.lastIndexWithLock() {
       		return errIndexTooBig
       	}

       	// It&#39;s possible that the passed index is 0. It means the leader has come to
       	// decide we need a complete log rebuild. Of course, that&#39;s only valid if we
       	// haven&#39;t committed anything, so this check comes after that one.
  		// 全部重建，前提是没有commited过任何的条目
       	if index == 0 {
       		for pos := 0; pos &amp;lt; len(l.entries); pos++ {
       			if l.entries[pos].commandResponse != nil {
       				close(l.entries[pos].commandResponse)
       				l.entries[pos].commandResponse = nil
       			}
       			if l.entries[pos].committed != nil {
       				l.entries[pos].committed &amp;lt;- false
       				close(l.entries[pos].committed)
       				l.entries[pos].committed = nil
       			}
       		}
       		l.entries = []logEntry{}
       		return nil
       	}

       	// Normal case: find the position of the matching log entry.
       	pos := 0
       	for ; pos &amp;lt; len(l.entries); pos++ {
       		if l.entries[pos].Index &amp;lt; index {
       			continue // didn&#39;t find it yet
       		}
       		if l.entries[pos].Index &amp;gt; index {
       			return errBadIndex // somehow went past it
       		}
       		if l.entries[pos].Index != index {
       			panic(&amp;quot;not &amp;lt;, not &amp;gt;, but somehow !=&amp;quot;)
       		}
       		if l.entries[pos].Term != term {
       			return errBadTerm
       		}
       		break // good
       	}

       	// Sanity check.
        // ? 怎么可能出现这种情况？
       	if pos &amp;lt; l.commitPos {
       		panic(&amp;quot;index &amp;gt;= commitIndex, but pos &amp;lt; commitPos&amp;quot;)
       	}

       	// `pos` is the position of log entry matching index and term.
       	// We want to truncate everything after that.
  		// 应为{term, index}是最新的了，所以将在其之后的所有条目给cut掉
       	truncateFrom := pos + 1
       	if truncateFrom &amp;gt;= len(l.entries) {
       		return nil // nothing to truncate
       	}

       	// If we blow away log entries that haven&#39;t yet sent responses to clients,
       	// signal the clients to stop waiting, by closing the channel without a
       	// response value.
       	for pos = truncateFrom; pos &amp;lt; len(l.entries); pos++ {
       		if l.entries[pos].commandResponse != nil {
       			close(l.entries[pos].commandResponse)
       			l.entries[pos].commandResponse = nil
       		}
       		if l.entries[pos].committed != nil {
       			l.entries[pos].committed &amp;lt;- false
       			close(l.entries[pos].committed)
       			l.entries[pos].committed = nil
       		}
       	}

       	// Truncate the log.
       	l.entries = l.entries[:truncateFrom]

       	// Done.
       	return nil
}

// getCommitIndex returns the commit index of the log. That is, the index of the
// last log entry which can be considered committed.
// 获取最新的commited日志条目
func (l *raftLog) getCommitIndex() uint64 {
       	l.RLock()
       	defer l.RUnlock()
       	return l.getCommitIndexWithLock()
}

// 获取最新的日志条目
func (l *raftLog) getCommitIndexWithLock() uint64 {
       	if l.commitPos &amp;lt; 0 {
       		return 0
       	}
       	if l.commitPos &amp;gt;= len(l.entries) {
       		panic(fmt.Sprintf(&amp;quot;commitPos %d &amp;gt; len(l.entries) %d; bad bookkeeping in raftLog&amp;quot;, l.commitPos, len(l.entries)))
       	}
       	return l.entries[l.commitPos].Index
}

// lastIndex returns the index of the most recent log entry.
func (l *raftLog) lastIndex() uint64 {
       	l.RLock()
       	defer l.RUnlock()
       	return l.lastIndexWithLock()
}

func (l *raftLog) lastIndexWithLock() uint64 {
       	if len(l.entries) &amp;lt;= 0 {
       		return 0
       	}
       	return l.entries[len(l.entries)-1].Index
}

// lastTerm returns the term of the most recent log entry.
func (l *raftLog) lastTerm() uint64 {
       	l.RLock()
       	defer l.RUnlock()
       	return l.lastTermWithLock()
}

func (l *raftLog) lastTermWithLock() uint64 {
       	if len(l.entries) &amp;lt;= 0 {
       		return 0
       	}
       	return l.entries[len(l.entries)-1].Term
}

// appendEntry appends the passed log entry to the log. It will return an error
// if the entry&#39;s term is smaller than the log&#39;s most recent term, or if the
// entry&#39;s index is too small relative to the log&#39;s most recent entry.
// 追加日志，注意此时还没有commit该条目
func (l *raftLog) appendEntry(entry logEntry) error {
       	l.Lock()
       	defer l.Unlock()
  		// 判定{entry.term, entry.index} &amp;gt; {last_term, last_index}
       	if len(l.entries) &amp;gt; 0 {
       		lastTerm := l.lastTermWithLock()
       		if entry.Term &amp;lt; lastTerm {
       			return errTermTooSmall
       		}
       		lastIndex := l.lastIndexWithLock()
       		if entry.Term == lastTerm &amp;amp;&amp;amp; entry.Index &amp;lt;= lastIndex {
       			return errIndexTooSmall
       		}
       	}

       	l.entries = append(l.entries, entry)
       	return nil
}

// commitTo commits all log entries up to and including the passed commitIndex.
// Commit means: synchronize the log entry to persistent storage, and call the
// state machine apply function for the log entry&#39;s command.
// 注意:
// 1、commit是一个后端任务，再此并没有&amp;quot;1/2&amp;quot;确认的概念(实际上是不是这样呢，这得去参考raft的论文了)
// 2、apply函数是在commit过程中调用，而不是在append的时候调用
// 3、apply相当于状态机函数，一般用户会将这些操作结果保存起来，用于快照

// 比如，想实现一个kv存储，那么用户只要将kv相关的逻辑植入这个函数即可

// committed &amp;lt;= commitIndex &amp;lt;= last_index
func (l *raftLog) commitTo(commitIndex uint64) error {
       	if commitIndex == 0 {
       		panic(&amp;quot;commitTo(0)&amp;quot;)
       	}

       	l.Lock()
       	defer l.Unlock()

       	// Reject old commit indexes
       	if commitIndex &amp;lt; l.getCommitIndexWithLock() {
       		return errIndexTooSmall
       	}

       	// Reject new commit indexes
       	if commitIndex &amp;gt; l.lastIndexWithLock() {
       		return errIndexTooBig
       	}

       	// If we&#39;ve already committed to the commitIndex, great!
       	if commitIndex == l.getCommitIndexWithLock() {
       		return nil
       	}

       	// We should start committing at precisely the last commitPos + 1
       	pos := l.commitPos + 1
       	if pos &amp;lt; 0 {
       		panic(&amp;quot;pending commit pos &amp;lt; 0&amp;quot;)
       	}

       	// Commit entries between our existing commit index and the passed index.
       	// Remember to include the passed index.
       	for {
       		// Sanity checks. TODO replace with plain `for` when this is stable.
       		if pos &amp;gt;= len(l.entries) {
       			panic(fmt.Sprintf(&amp;quot;commitTo pos=%d advanced past all log entries (%d)&amp;quot;, pos, len(l.entries)))
       		}
       		if l.entries[pos].Index &amp;gt; commitIndex {
       			panic(&amp;quot;commitTo advanced past the desired commitIndex&amp;quot;)
       		}

       		// Encode the entry to persistent storage.
       		if err := l.entries[pos].encode(l.store); err != nil {
       			return err
       		}

       		// Forward non-configuration commands to the state machine.
       		// Send the responses to the waiting client, if applicable.
       		// 如果不是配置类型的Log，则调用apply function
       		// 配置类型的Log，在其他地方处理
       		if !l.entries[pos].isConfiguration {
       			resp := l.apply(l.entries[pos].Index, l.entries[pos].Command)
       			if l.entries[pos].commandResponse != nil {
       				select {
       				case l.entries[pos].commandResponse &amp;lt;- resp:
       					break
				    // 问什么选取这个时间？？？
       				case &amp;lt;-time.After(maximumElectionTimeout()): // &amp;lt;&amp;lt; ElectionInterval
       					panic(&amp;quot;uncoöperative command response receiver&amp;quot;)
       				}
       				close(l.entries[pos].commandResponse)
       				l.entries[pos].commandResponse = nil
       			}
       		}

       		// Signal the entry has been committed, if applicable.
       		if l.entries[pos].committed != nil {
       			l.entries[pos].committed &amp;lt;- true
       			close(l.entries[pos].committed)
       			l.entries[pos].committed = nil
       		}

       		// Mark our commit position cursor.
       		l.commitPos = pos

       		// If that was the last one, we&#39;re done.
       		if l.entries[pos].Index == commitIndex {
       			break
       		}
       		if l.entries[pos].Index &amp;gt; commitIndex {
       			panic(fmt.Sprintf(
       				&amp;quot;current entry Index %d is beyond our desired commitIndex %d&amp;quot;,
       				l.entries[pos].Index,
       				commitIndex,
       			))
       		}

       		// Otherwise, advance!
       		pos++
       	}

       	// Done.
       	return nil
}

// logEntry is the atomic unit being managed by the distributed log. A log entry
// always has an index (monotonically increasing), a term in which the Raft
// network leader first sees the entry, and a command. The command is what gets
// executed against the node state machine when the log entry is successfully
// replicated.
type logEntry struct {
  		// 日志索引号
       	Index           uint64        `json:&amp;quot;index&amp;quot;`
       	// 任期号
  		Term            uint64        `json:&amp;quot;term&amp;quot;` // when received by leader
  		// 日志内容
       	Command         []byte        `json:&amp;quot;command,omitempty&amp;quot;`
  		// commited 通道
       	committed       chan bool     `json:&amp;quot;-&amp;quot;`
  		// 命令应答 通道
       	commandResponse chan&amp;lt;- []byte `json:&amp;quot;-&amp;quot;` // only non-nil on receiver&#39;s log
  		// 日志类型标示
       	isConfiguration bool          `json:&amp;quot;-&amp;quot;` // for configuration change entries
}

// encode serializes the log entry to the passed io.Writer.
//
// Entries are serialized in a simple binary format:
//
//     		 ---------------------------------------------
//     		| uint32 | uint64 | uint64 | uint32 | []byte  |
//     		 ---------------------------------------------
//     		| CRC    | TERM   | INDEX  | SIZE   | COMMAND |
//     		 ---------------------------------------------
//

// 序列化，大端
func (e *logEntry) encode(w io.Writer) error {
       	if len(e.Command) &amp;lt;= 0 {
       		return errNoCommand
       	}
       	if e.Index &amp;lt;= 0 {
       		return errBadIndex
       	}
       	if e.Term &amp;lt;= 0 {
       		return errBadTerm
       	}

       	commandSize := len(e.Command)
       	buf := make([]byte, 24+commandSize)

       	binary.LittleEndian.PutUint64(buf[4:12], e.Term)
       	binary.LittleEndian.PutUint64(buf[12:20], e.Index)
       	binary.LittleEndian.PutUint32(buf[20:24], uint32(commandSize))

       	copy(buf[24:], e.Command)

       	binary.LittleEndian.PutUint32(
       		buf[0:4],
       		crc32.ChecksumIEEE(buf[4:]),
       	)

       	_, err := w.Write(buf)
       	return err
}

// 反序列化
// decode deserializes one log entry from the passed io.Reader.
func (e *logEntry) decode(r io.Reader) error {
       	header := make([]byte, 24)

       	if _, err := r.Read(header); err != nil {
       		return err
       	}

       	command := make([]byte, binary.LittleEndian.Uint32(header[20:24]))

       	if _, err := r.Read(command); err != nil {
       		return err
       	}

       	crc := binary.LittleEndian.Uint32(header[:4])

       	check := crc32.NewIEEE()
       	check.Write(header[4:])
       	check.Write(command)

       	if crc != check.Sum32() {
       		return errInvalidChecksum
       	}

       	e.Term = binary.LittleEndian.Uint64(header[4:12])
       	e.Index = binary.LittleEndian.Uint64(header[12:20])
       	e.Command = command

       	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;peers-go&#34;&gt;Peers.go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	errTimeout = errors.New(&amp;quot;timeout&amp;quot;)
)
// peers为节点的一个抽象，对外提供了一些访问接口，
// 需要注意的地方是peers的序列化
type Peer interface {
  	// 返回server标示
	id() uint64
  	// 日志追加接口
	callAppendEntries(appendEntries) appendEntriesResponse
  	// 投票选举接口
	callRequestVote(requestVote) requestVoteResponse
  	// 命令调用
	callCommand([]byte, chan&amp;lt;- []byte) error
  	// 集群配置变化接口
	callSetConfiguration(...Peer) error
}

// localPeer is the simplest kind of peer, mapped to a server in the
// same process-space. Useful for testing and demonstration; not so
// useful for networks of independent processes.
// 本地local peers，用于测试，不用经过网络
type localPeer struct {
	server *Server
}

func newLocalPeer(server *Server) *localPeer { return &amp;amp;localPeer{server} }

func (p *localPeer) id() uint64 { return p.server.id }

// 追加日志
func (p *localPeer) callAppendEntries(ae appendEntries) appendEntriesResponse {
	return p.server.appendEntries(ae)
}

// 投票选举
func (p *localPeer) callRequestVote(rv requestVote) requestVoteResponse {
	return p.server.requestVote(rv)
}

// 命令
// 实际调用为Leader
func (p *localPeer) callCommand(cmd []byte, response chan&amp;lt;- []byte) error {
	return p.server.Command(cmd, response)
}

// 设置配置
func (p *localPeer) callSetConfiguration(peers ...Peer) error {
	return p.server.SetConfiguration(peers...)
}

// requestVoteTimeout issues the requestVote to the given peer.
// If no response is received before timeout, an error is returned.
// 投票
func requestVoteTimeout(p Peer, rv requestVote, timeout time.Duration) (requestVoteResponse, error) {
	c := make(chan requestVoteResponse, 1)
	go func() { c &amp;lt;- p.callRequestVote(rv) }()

	select {
	case resp := &amp;lt;-c:
		return resp, nil
	case &amp;lt;-time.After(timeout):
		return requestVoteResponse{}, errTimeout
	}
}

// peerMap is a collection of Peer interfaces. It provides some convenience
// functions for actions that should apply to multiple Peers.
type peerMap map[uint64]Peer

// makePeerMap constructs a peerMap from a list of peers.
func makePeerMap(peers ...Peer) peerMap {
	pm := peerMap{}
	for _, peer := range peers {
		pm[peer.id()] = peer
	}
	return pm
}

// explodePeerMap converts a peerMap into a slice of peers.
func explodePeerMap(pm peerMap) []Peer {
	a := []Peer{}
	for _, peer := range pm {
		a = append(a, peer)
	}
	return a
}

func (pm peerMap) except(id uint64) peerMap {
	except := peerMap{}
	for id0, peer := range pm {
		if id0 == id {
			continue
		}
		except[id0] = peer
	}
	return except
}

func (pm peerMap) count() int { return len(pm) }

// 法定人数
func (pm peerMap) quorum() int {
	switch n := len(pm); n {
	case 0, 1:
		return 1
	default:
		return (n / 2) + 1
	}
}

// requestVotes sends the passed requestVote RPC to every peer in Peers. It
// forwards responses along the returned requestVoteResponse channel. It makes
// the RPCs with a timeout of BroadcastInterval * 2 (chosen arbitrarily). Peers
// that don&#39;t respond within the timeout are retried forever. The retry loop
// stops only when all peers have responded, or a Cancel signal is sent via the
// returned canceler.
func (pm peerMap) requestVotes(r requestVote) (chan voteResponseTuple, canceler) {
	// &amp;quot;[A server entering the candidate stage] issues requestVote RPCs in
	// parallel to each of the other servers in the cluster. If the candidate
	// receives no response for an RPC, it reissues the RPC repeatedly until a
	// response arrives or the election concludes.&amp;quot;

	// construct the channels we&#39;ll return
	abortChan := make(chan struct{})
	tupleChan := make(chan voteResponseTuple)

	go func() {
		// We loop until all Peers have given us a response.
		// Track which Peers have responded.
		respondedAlready := peerMap{} // none yet

		for {
			notYetResponded := disjoint(pm, respondedAlready)
			if len(notYetResponded) &amp;lt;= 0 {
				return // done
			}

			// scatter
			tupleChan0 := make(chan voteResponseTuple, len(notYetResponded))
			for id, peer := range notYetResponded {
				go func(id uint64, peer Peer) {
					resp, err := requestVoteTimeout(peer, r, 2*maximumElectionTimeout())
					tupleChan0 &amp;lt;- voteResponseTuple{id, resp, err}
				}(id, peer)
			}

			// gather
			for i := 0; i &amp;lt; cap(tupleChan0); i++ {
				select {
				case t := &amp;lt;-tupleChan0:
					if t.err != nil {
						continue // will need to retry
					}
					respondedAlready[t.id] = nil // set membership semantics
					tupleChan &amp;lt;- t

				case &amp;lt;-abortChan:
					return // give up
				}
			}
		}
	}()

	return tupleChan, cancel(abortChan)
}

// 选举应答
type voteResponseTuple struct {
	id       uint64
	response requestVoteResponse
	err      error
}

type canceler interface {
	Cancel()
}

type cancel chan struct{}

func (c cancel) Cancel() { close(c) }

// 过滤peers
func disjoint(all, except peerMap) peerMap {
	d := peerMap{}
	for id, peer := range all {
		if _, ok := except[id]; ok {
			continue
		}
		d[id] = peer
	}
	return d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;server-go&#34;&gt;server.go&lt;/h3&gt;

&lt;p&gt;这是最重要的一个逻辑&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/raft-consensus-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;节点配置变更&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/raft-state.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 角色分类  
const (
	follower  = &amp;quot;Follower&amp;quot;
	candidate = &amp;quot;Candidate&amp;quot;
	leader    = &amp;quot;Leader&amp;quot;
)

const (
	unknownLeader = 0
	noVote        = 0
)

// 选举时间随机范围[MinimumElectionTimeoutMS, maximumElectionTimeoutMS]
var (
	MinimumElectionTimeoutMS int32 = 250

	maximumElectionTimeoutMS = 2 * MinimumElectionTimeoutMS
)

var (
	errNotLeader             = errors.New(&amp;quot;not the leader&amp;quot;)
	errUnknownLeader         = errors.New(&amp;quot;unknown leader&amp;quot;)
	errDeposed               = errors.New(&amp;quot;deposed during replication&amp;quot;)
	errAppendE#008000ntriesRejected = errors.New(&amp;quot;appendEntries RPC rejected&amp;quot;)
	errReplicationFailed     = errors.New(&amp;quot;command replication failed (but will keep retrying)&amp;quot;)
	errOutOfSync             = errors.New(&amp;quot;out of sync&amp;quot;)
	errAlreadyRunning        = errors.New(&amp;quot;already running&amp;quot;)
)

// 重置选举时间
func resetElectionTimeoutMS(newMin, newMax int) (int, int) {
	oldMin := atomic.LoadInt32(&amp;amp;MinimumElectionTimeoutMS)
	oldMax := atomic.LoadInt32(&amp;amp;maximumElectionTimeoutMS)
	atomic.StoreInt32(&amp;amp;MinimumElectionTimeoutMS, int32(newMin))
	atomic.StoreInt32(&amp;amp;maximumElectionTimeoutMS, int32(newMax))
	return int(oldMin), int(oldMax)
}

// minimumElectionTimeout returns the current minimum election timeout.
func minimumElectionTimeout() time.Duration {
	return time.Duration(MinimumElectionTimeoutMS) * time.Millisecond
}

// maximumElectionTimeout returns the current maximum election time.
func maximumElectionTimeout() time.Duration {
	return time.Duration(maximumElectionTimeoutMS) * time.Millisecond
}

// 选举时间随机函数
func electionTimeout() time.Duration {
	n := rand.Intn(int(maximumElectionTimeoutMS - MinimumElectionTimeoutMS))
	d := int(MinimumElectionTimeoutMS) + n
	return time.Duration(d) * time.Millisecond
}

// broadcastInterval returns the interval between heartbeats (AppendEntry RPCs)
// broadcast from the leader. It is the minimum election timeout / 10, as
// dictated by the spec: BroadcastInterval &amp;lt;&amp;lt; ElectionTimeout &amp;lt;&amp;lt; MTBF.
// 广播时间，用于Leader发送心跳广播，这个时间应小于选举时间；否则，非Leader节点会产生选举操作
func broadcastInterval() time.Duration {
	d := MinimumElectionTimeoutMS / 10
	return time.Duration(d) * time.Millisecond
}

// protectedString is just a string protected by a mutex.
type protectedString struct {
	sync.RWMutex
	value string
}

func (s *protectedString) Get() string {
	s.RLock()
	defer s.RUnlock()
	return s.value
}

func (s *protectedString) Set(value string) {
	s.Lock()
	defer s.Unlock()
	s.value = value
}

// protectedBool is just a bool protected by a mutex.
type protectedBool struct {
	sync.RWMutex
	value bool
}

func (s *protectedBool) Get() bool {
	s.RLock()
	defer s.RUnlock()
	return s.value
}

func (s *protectedBool) Set(value bool) {
	s.Lock()
	defer s.Unlock()
	s.value = value
}

// Server is the agent that performs all of the Raft protocol logic.
// In a typical application, each running process that wants to be part of
// the distributed state machine will contain a server component.
type Server struct {
	id      uint64 // id of this server
    // 节点状态
	state   *protectedString
    // 节点运行状态
	running *protectedBool
    // Leader节点标示
	leader  uint64 
    // 当前节点任期号
	term    uint64 // &amp;quot;current term number, which increases monotonically&amp;quot;
    // 0表示，当前节点还有投出自己的票;
    // 非零表示节点已经投票了，值是获票者的标示ID
	vote    uint64 // who we voted for this term, if applicable
	log     *raftLog
	config  *configuration

    // 追加日志信道
	appendEntriesChan chan appendEntriesTuple
  	// 投票信道
	requestVoteChan   chan requestVoteTuple
  	// 命令信道
	commandChan       chan commandTuple
  	// 配置修改信道
	configurationChan chan configurationTuple

  	// 选举信道
	electionTick &amp;lt;-chan time.Time
  	// 退出信道
	quit         chan chan struct{}
}

// 状态机函数
// 该函数不可并发执行，否则就达不到一致性状态机的效果(执行时间不要超过选举时间)

// 正常来说，只有&amp;quot;共识&amp;quot;达成的时候，才会调用该函数，然后返回给客户端
// 但是，在这里为了简化实现，&amp;quot;共识“算法是放在后台任务操作的，客户端发送命令单Leader时，Leader马上
// 应答客户端，并没有等”共识算法“的共识结果
type ApplyFunc func(commitIndex uint64, cmd []byte) []byte

// 初始化节点
// 1. 构建日志 2.初始化为&amp;quot;follower&amp;quot;角色 3.leader为&amp;quot;unknown&amp;quot;
func NewServer(id uint64, store io.ReadWriter, a ApplyFunc) *Server {
	if id &amp;lt;= 0 {
		panic(&amp;quot;server id must be &amp;gt; 0&amp;quot;)
	}

	// 5.2 Leader election: &amp;quot;the latest term this server has seen is persisted,
	// and is initialized to 0 on first boot.&amp;quot;
	log := newRaftLog(store, a)
	latestTerm := log.lastTerm()

	s := &amp;amp;Server{
		id:      id,
		state:   &amp;amp;protectedString{value: follower}, // &amp;quot;when servers start up they begin as followers&amp;quot;
		running: &amp;amp;protectedBool{value: false},
		leader:  unknownLeader, // unknown at startup
		log:     log,
		term:    latestTerm,
		config:  newConfiguration(peerMap{}),

		appendEntriesChan: make(chan appendEntriesTuple),
		requestVoteChan:   make(chan requestVoteTuple),
		commandChan:       make(chan commandTuple),
		configurationChan: make(chan configurationTuple),

		electionTick: nil,
		quit:         make(chan chan struct{}),
	}
	s.resetElectionTimeout()
	return s
}

type configurationTuple struct {
	Peers []Peer
	Err   chan error
}

// 设置配置
// 1. 服务启动时，先设置配置
// 2. 集群变更时，设置配置
func (s *Server) SetConfiguration(peers ...Peer) error {
    // 节点刚启动
	if !s.running.Get() {
		s.config.directSet(makePeerMap(peers...))
		return nil
	}

	err := make(chan error)
    // 节点已经启动了
	s.configurationChan &amp;lt;- configurationTuple{peers, err}
	return &amp;lt;-err
}

// Start triggers the server to begin communicating with its peers.
func (s *Server) Start() {
	go s.loop()
}

// Stop terminates the server. Stopped servers should not be restarted.
func (s *Server) Stop() {
	q := make(chan struct{})
	s.quit &amp;lt;- q
	&amp;lt;-q
	s.logGeneric(&amp;quot;server stopped&amp;quot;)
}

// 命令元组
type commandTuple struct {
  	// 命令内容
	Command         []byte
  	// 命令信道
	CommandResponse chan&amp;lt;- []byte
	Err             chan error
}

// 命令接口
func (s *Server) Command(cmd []byte, response chan&amp;lt;- []byte) error {
	err := make(chan error)
	s.commandChan &amp;lt;- commandTuple{cmd, response, err}
	return &amp;lt;-err
}

// 日志追加
func (s *Server) appendEntries(ae appendEntries) appendEntriesResponse {
	t := appendEntriesTuple{
		Request:  ae,
		Response: make(chan appendEntriesResponse),
	}
	s.appendEntriesChan &amp;lt;- t
	return &amp;lt;-t.Response
}

// 投票
func (s *Server) requestVote(rv requestVote) requestVoteResponse {
	t := requestVoteTuple{
		Request:  rv,
		Response: make(chan requestVoteResponse),
	}
	s.requestVoteChan &amp;lt;- t
	return &amp;lt;-t.Response
}

//                                  times out,
//                                 new election
//     |                             .-----.
//     |                             |     |
//     v         times out,          |     v     receives votes from
// +----------+  starts election  +-----------+  majority of servers  +--------+
// | Follower |------------------&amp;gt;| Candidate |----------------------&amp;gt;| Leader |
// +----------+                   +-----------+                       +--------+
//     ^ ^                              |                                 |
//     | |    discovers current leader  |                                 |
//     | |                 or new term  |                                 |
//     | &#39;------------------------------&#39;                                 |
//     |                                                                  |
//     |                               discovers server with higher term  |
//     &#39;------------------------------------------------------------------&#39;
//
//

func (s *Server) loop() {
	s.running.Set(true)
	for s.running.Get() {
		switch state := s.state.Get(); state {
		case follower:
			s.followerSelect()
		case candidate:
			s.candidateSelect()
		case leader:
			s.leaderSelect()
		default:
			panic(fmt.Sprintf(&amp;quot;unknown Server State &#39;%s&#39;&amp;quot;, state))
		}
	}
}

func (s *Server) resetElectionTimeout() {
	s.electionTick = time.NewTimer(electionTimeout()).C
}

func (s *Server) logGeneric(format string, args ...interface{}) {
	prefix := fmt.Sprintf(&amp;quot;id=%d term=%d state=%s: &amp;quot;, s.id, s.term, s.state.Get())
	log.Printf(prefix+format, args...)
}

func (s *Server) logAppendEntriesResponse(req appendEntries, resp appendEntriesResponse, stepDown bool) {
	s.logGeneric(
		&amp;quot;got appendEntries, sz=%d leader=%d prevIndex/Term=%d/%d commitIndex=%d: responded with success=%v (reason=&#39;%s&#39;) stepDown=%v&amp;quot;,
		len(req.Entries),
		req.LeaderID,
		req.PrevLogIndex,
		req.PrevLogTerm,
		req.CommitIndex,
		resp.Success,
		resp.reason,
		stepDown,
	)
}

func (s *Server) logRequestVoteResponse(req requestVote, resp requestVoteResponse, stepDown bool) {
	s.logGeneric(
		&amp;quot;got RequestVote, candidate=%d: responded with granted=%v (reason=&#39;%s&#39;) stepDown=%v&amp;quot;,
		req.CandidateID,
		resp.VoteGranted,
		resp.reason,
		stepDown,
	)
}

func (s *Server) handleQuit(q chan struct{}) {
	s.logGeneric(&amp;quot;got quit signal&amp;quot;)
	s.running.Set(false)
	close(q)
}

// 命令转发
// 如果当前节点不是Leader节点，并且已存在Leader节点，则其会以&amp;quot;代理“的角色，将命令转发至Leader节点
func (s *Server) forwardCommand(t commandTuple) {
	switch s.leader {
	case unknownLeader:
		s.logGeneric(&amp;quot;got command, but don&#39;t know leader&amp;quot;)
		t.Err &amp;lt;- errUnknownLeader

	case s.id: // I am the leader
		panic(&amp;quot;impossible state in forwardCommand&amp;quot;)

	default:
		leader, ok := s.config.get(s.leader)
		if !ok {
			panic(&amp;quot;invalid state in peers&amp;quot;)
		}
		s.logGeneric(&amp;quot;got command, forwarding to leader (%d)&amp;quot;, s.leader)
		// We&#39;re blocking our {follower,candidate}Select function in the
		// receive-command branch. If we continue to block while forwarding
		// the command, the leader won&#39;t be able to get a response from us!
		go func() { t.Err &amp;lt;- leader.callCommand(t.Command, t.CommandResponse) }()
	}
}

// 配置变更
// 转发规则和命令转发一样
func (s *Server) forwardConfiguration(t configurationTuple) {
	switch s.leader {
	case unknownLeader:
		s.logGeneric(&amp;quot;got configuration, but don&#39;t know leader&amp;quot;)
		t.Err &amp;lt;- errUnknownLeader

	case s.id: // I am the leader
		panic(&amp;quot;impossible state in forwardConfiguration&amp;quot;)

	default:
		leader, ok := s.config.get(s.leader)
		if !ok {
			panic(&amp;quot;invalid state in peers&amp;quot;)
		}
		s.logGeneric(&amp;quot;got configuration, forwarding to leader (%d)&amp;quot;, s.leader)
		go func() { t.Err &amp;lt;- leader.callSetConfiguration(t.Peers...) }()
	}
}

// follower 节点逻辑
func (s *Server) followerSelect() {
	for {
		select {
		case q := &amp;lt;-s.quit:
			s.handleQuit(q)
			return
		// 命令转发
		case t := &amp;lt;-s.commandChan:
			s.forwardCommand(t)
		// 集群变更转发
		case t := &amp;lt;-s.configurationChan:
			s.forwardConfiguration(t)
		// Leader选举
		case &amp;lt;-s.electionTick:
			// 5.2 Leader election: &amp;quot;A follower increments its current term and
			// transitions to candidate state.&amp;quot;
			if s.config == nil {
				s.logGeneric(&amp;quot;election timeout, but no configuration: ignoring&amp;quot;)
				s.resetElectionTimeout()
				continue
			}
			s.logGeneric(&amp;quot;election timeout, becoming candidate&amp;quot;)
          	// 提高自己的任期号
			s.term++
          	// 投票置为空
			s.vote = noVote
          	// Leader 
			s.leader = unknownLeader
          	// 设置节点角色为&amp;quot;候选人&amp;quot;
			s.state.Set(candidate)
          	// 重置选举时间，防止马上再次出发选举
			s.resetElectionTimeout()
			return
        // 日志追加(除了客户端请求，leader的心跳也会出发这个行为)
		case t := &amp;lt;-s.appendEntriesChan:
			if s.leader == unknownLeader {
				s.leader = t.Request.LeaderID
				s.logGeneric(&amp;quot;discovered Leader %d&amp;quot;, s.leader)
			}
          	// 处理日志最佳操作
			resp, stepDown := s.handleAppendEntries(t.Request)
			s.logAppendEntriesResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
          	// 如果节点已经脱离了当前的集群，需要跟新Leader地址
			if stepDown {
				// stepDown as a Follower means just to reset the leader
				if s.leader != unknownLeader {
					s.logGeneric(&amp;quot;abandoning old leader=%d&amp;quot;, s.leader)
				}
				s.logGeneric(&amp;quot;following new leader=%d&amp;quot;, t.Request.LeaderID)
				s.leader = t.Request.LeaderID
			}
		// 选举
		case t := &amp;lt;-s.requestVoteChan:
          	// 选举处理
			resp, stepDown := s.handleRequestVote(t.Request)
			s.logRequestVoteResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
          	// 如果落后于当前节点了，把当前的Leader修改为&amp;quot;unkownleader&amp;quot;，等待讯据成功后，进行切换
			if stepDown {
				// stepDown as a Follower means just to reset the leader
				if s.leader != unknownLeader {
					s.logGeneric(&amp;quot;abandoning old leader=%d&amp;quot;, s.leader)
				}
				s.logGeneric(&amp;quot;new leader unknown&amp;quot;)
				s.leader = unknownLeader
			}
		}
	}
}

// 候选状态
func (s *Server) candidateSelect() {
	if s.leader != unknownLeader {
		panic(&amp;quot;known leader when entering candidateSelect&amp;quot;)
	}
	if s.vote != 0 {
		panic(&amp;quot;existing vote when entering candidateSelect&amp;quot;)
	}

	// &amp;quot;[A server entering the candidate stage] issues requestVote RPCs in
	// parallel to each of the other servers in the cluster. If the candidate
	// receives no response for an RPC, it reissues the RPC repeatedly until a
	// response arrives or the election concludes.&amp;quot;
	// 发起选举RPC
	requestVoteResponses, canceler := s.config.allPeers().except(s.id).requestVotes(requestVote{
		Term:         s.term,
		CandidateID:  s.id,
		LastLogIndex: s.log.lastIndex(),
		LastLogTerm:  s.log.lastTerm(),
	})
	defer canceler.Cancel()

	// Set up vote tallies (plus, vote for myself)
	votes := map[uint64]bool{s.id: true}
	s.vote = s.id
	s.logGeneric(&amp;quot;term=%d election started (configuration state %s)&amp;quot;, s.term, s.config.state)

	// 如果已经达到了选举“共识”，则成功选举
	if s.config.pass(votes) {
		s.logGeneric(&amp;quot;I immediately won the election&amp;quot;)
		s.leader = s.id
		s.state.Set(leader)
		s.vote = noVote
		return
	}

	// &amp;quot;A candidate continues in this state until one of three things happens:
	// (a) it wins the election, (b) another server establishes itself as
	// leader, or (c) a period of time goes by with no winner.&amp;quot;
	for {
		select {
		case q := &amp;lt;-s.quit:
			s.handleQuit(q)
			return
		// 命令转发
		case t := &amp;lt;-s.commandChan:
			s.forwardCommand(t)
		// 配置更新转发，注意和Leader的不同
		case t := &amp;lt;-s.configurationChan:
			s.forwardConfiguration(t)
		// 收到选举的应答
		case t := &amp;lt;-requestVoteResponses:
			s.logGeneric(&amp;quot;got vote: id=%d term=%d granted=%v&amp;quot;, t.id, t.response.Term, t.response.VoteGranted)
			// &amp;quot;A candidate wins the election if it receives votes from a
			// majority of servers in the full cluster for the same term.&amp;quot;
          	// 本节点落后于其他几点
			if t.response.Term &amp;gt; s.term {
				s.logGeneric(&amp;quot;got vote from future term (%d&amp;gt;%d); abandoning election&amp;quot;, t.response.Term, s.term)
				s.leader = unknownLeader
				s.state.Set(follower)
				s.vote = noVote
				return // lose
			}
          	// 收到了&amp;quot;落后&amp;quot;当前节点的应答，忽略掉它
			if t.response.Term &amp;lt; s.term {
				s.logGeneric(&amp;quot;got vote from past term (%d&amp;lt;%d); ignoring&amp;quot;, t.response.Term, s.term)
				break
			}
          	
          	// 收到赞同票
			if t.response.VoteGranted {
				s.logGeneric(&amp;quot;%d voted for me&amp;quot;, t.id)
				votes[t.id] = true
			}
			// &amp;quot;Once a candidate wins an election, it becomes leader.&amp;quot;
          	// “共识”达成
			if s.config.pass(votes) {
				s.logGeneric(&amp;quot;I won the election&amp;quot;)
				s.leader = s.id
				s.state.Set(leader)
				s.vote = noVote
				return // win
			}
          // 收到日志追加(在这里，心跳也当做日志追加的方式发送)
		case t := &amp;lt;-s.appendEntriesChan:
			// &amp;quot;While waiting for votes, a candidate may receive an
			// appendEntries RPC from another server claiming to be leader.
			// If the leader&#39;s term (included in its RPC) is at least as
			// large as the candidate&#39;s current term, then the candidate
			// recognizes the leader as legitimate and steps down, meaning
			// that it returns to follower state.&amp;quot;
            // 处理日志
			resp, stepDown := s.handleAppendEntries(t.Request)
			s.logAppendEntriesResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
          	// candidate节点落后于Leader节点
			if stepDown {
				s.logGeneric(&amp;quot;after an appendEntries, stepping down to Follower (leader=%d)&amp;quot;, t.Request.LeaderID)
				s.leader = t.Request.LeaderID
				s.state.Set(follower)
				return // lose
			}

        // 虽然当前节点是candidate节点，但集群中此时可能存在多个candidate节点
		case t := &amp;lt;-s.requestVoteChan:
			// We can also be defeated by a more recent candidate
			resp, stepDown := s.handleRequestVote(t.Request)
			s.logRequestVoteResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
			if stepDown {
              	// 当前candidate节点落后于集群中已存在的candidate节点，将自己的角色变为follower，
              	// 并且也会投赞同票
				s.logGeneric(&amp;quot;after a requestVote, stepping down to Follower (leader unknown)&amp;quot;)
				s.leader = unknownLeader
				s.state.Set(follower)
				return // lose
			}
		
        // 选举
		case &amp;lt;-s.electionTick:
			// &amp;quot;The third possible outcome is that a candidate neither wins nor
			// loses the election: if many followers become candidates at the
			// same time, votes could be split so that no candidate obtains a
			// majority. When this happens, each candidate will start a new
			// election by incrementing its term and initiating another round of
			// requestVote RPCs.&amp;quot;
			s.logGeneric(&amp;quot;election ended with no winner; incrementing term and trying again&amp;quot;)
			s.resetElectionTimeout()
			s.term++
			s.vote = noVote
			return // draw
		}
	}
}

// Leader 保存的Follower节点的所有最新同步条目
type nextIndex struct {
	sync.RWMutex
	m map[uint64]uint64 // followerId: nextIndex
}

func newNextIndex(pm peerMap, defaultNextIndex uint64) *nextIndex {
	ni := &amp;amp;nextIndex{
		m: map[uint64]uint64{},
	}
	for id := range pm {
		ni.m[id] = defaultNextIndex
	}
	return ni
}

// 找出已经同步Follower的最小日志
func (ni *nextIndex) bestIndex() uint64 {
	ni.RLock()
	defer ni.RUnlock()

	if len(ni.m) &amp;lt;= 0 {
		return 0
	}

	i := uint64(math.MaxUint64)
	for _, nextIndex := range ni.m {
		if nextIndex &amp;lt; i {
			i = nextIndex
		}
	}
	return i
}

// 返回节点(id)最新的同步日志
func (ni *nextIndex) prevLogIndex(id uint64) uint64 {
	ni.RLock()
	defer ni.RUnlock()
	if _, ok := ni.m[id]; !ok {
		panic(fmt.Sprintf(&amp;quot;peer %d not found&amp;quot;, id))
	}
	return ni.m[id]
}

// 自减节点(id)的最新同步日志，用于同步失败时的回滚
func (ni *nextIndex) decrement(id uint64, prev uint64) (uint64, error) {
	ni.Lock()
	defer ni.Unlock()

	i, ok := ni.m[id]
	if !ok {
		panic(fmt.Sprintf(&amp;quot;peer %d not found&amp;quot;, id))
	}

	if i != prev {
		return i, errOutOfSync
	}

	if i &amp;gt; 0 {
		ni.m[id]--
	}
	return ni.m[id], nil
}

// 更新节点(id)的同步日志
func (ni *nextIndex) set(id, index, prev uint64) (uint64, error) {
	ni.Lock()
	defer ni.Unlock()

	i, ok := ni.m[id]
	if !ok {
		panic(fmt.Sprintf(&amp;quot;peer %d not found&amp;quot;, id))
	}
	if i != prev {
		return i, errOutOfSync
	}

	ni.m[id] = index
	return index, nil
}

// 心跳、复制命令都会用到该函数，flush是同步的，如果对端节点不可达，则阻塞
func (s *Server) flush(peer Peer, ni *nextIndex) error {
	peerID := peer.id()
	// Leader的任期号
	currentTerm := s.term
	// 节点(peer)的最新同步索引
	prevLogIndex := ni.prevLogIndex(peerID)
	// 检索出peers节点落后于Leader几点的日志条目，然后进行同步
	entries, prevLogTerm := s.log.entriesAfter(prevLogIndex)
	// 获取Leader committed的最新索引
	commitIndex := s.log.getCommitIndex()
	s.logGeneric(&amp;quot;flush to %d: term=%d leaderId=%d prevLogIndex/Term=%d/%d sz=%d commitIndex=%d&amp;quot;, peerID, currentTerm, s.id, prevLogIndex, prevLogTerm, len(entries), commitIndex)
	
	// 日志追加RPC
	resp := peer.callAppendEntries(appendEntries{
		Term:         currentTerm,
		LeaderID:     s.id,
		PrevLogIndex: prevLogIndex,
		PrevLogTerm:  prevLogTerm,
		Entries:      entries,
		CommitIndex:  commitIndex,
	})

	if resp.Term &amp;gt; currentTerm {
		// 应答的节点比当前节点的任期号大，当前的Leader被罢免
		s.logGeneric(&amp;quot;flush to %d: responseTerm=%d &amp;gt; currentTerm=%d: deposed&amp;quot;, peerID, resp.Term, currentTerm)
		return errDeposed
	}

	
	if !resp.Success {
		// 应答失败，可能是leader RPC等待超时，或者出现了网络错误(包括脑裂)，回滚
		newPrevLogIndex, err := ni.decrement(peerID, prevLogIndex)
		if err != nil {
			s.logGeneric(&amp;quot;flush to %d: while decrementing prevLogIndex: %s&amp;quot;, peerID, err)
			return err
		}
		s.logGeneric(&amp;quot;flush to %d: rejected; prevLogIndex(%d) becomes %d&amp;quot;, peerID, peerID, newPrevLogIndex)
		return errAppendEntriesRejected
	}

	if len(entries) &amp;gt; 0 {
		// 复制成功，更新同步状态
		newPrevLogIndex, err := ni.set(peer.id(), entries[len(entries)-1].Index, prevLogIndex)
		if err != nil {
			s.logGeneric(&amp;quot;flush to %d: while moving prevLogIndex forward: %s&amp;quot;, peerID, err)
			return err
		}
		s.logGeneric(&amp;quot;flush to %d: accepted; prevLogIndex(%d) becomes %d&amp;quot;, peerID, peerID, newPrevLogIndex)
		return nil
	}

	s.logGeneric(&amp;quot;flush to %d: accepted; prevLogIndex(%d) remains %d&amp;quot;, peerID, peerID, ni.prevLogIndex(peerID))
	return nil
}

// Leader并发同步日志
func (s *Server) concurrentFlush(pm peerMap, ni *nextIndex, timeout time.Duration) (int, bool) {
	type tuple struct {
		id  uint64
		err error
	}
	responses := make(chan tuple, len(pm))
	for _, peer := range pm {
		go func(peer Peer) {
			errChan := make(chan error, 1)
			go func() { errChan &amp;lt;- s.flush(peer, ni) }()
			go func() { time.Sleep(timeout); errChan &amp;lt;- errTimeout }()
			responses &amp;lt;- tuple{peer.id(), &amp;lt;-errChan} // first responder wins
		}(peer)
	}

	successes, stepDown := 0, false
	for i := 0; i &amp;lt; cap(responses); i++ {
		switch t := &amp;lt;-responses; t.err {
		case nil:
			s.logGeneric(&amp;quot;concurrentFlush: peer %d: OK (prevLogIndex(%d)=%d)&amp;quot;, t.id, t.id, ni.prevLogIndex(t.id))
			successes++
		case errDeposed:
			// 当前的Leder节点落后于其他节点
			s.logGeneric(&amp;quot;concurrentFlush: peer %d: deposed!&amp;quot;, t.id)
			stepDown = true
		default:
			s.logGeneric(&amp;quot;concurrentFlush: peer %d: %s (prevLogIndex(%d)=%d)&amp;quot;, t.id, t.err, t.id, ni.prevLogIndex(t.id))
			// nothing to do but log and continue
		}
	}
	return successes, stepDown
}

// 作为Leader角色运行
func (s *Server) leaderSelect() {
	if s.leader != s.id {
		panic(fmt.Sprintf(&amp;quot;leader (%d) not me (%d) when entering leaderSelect&amp;quot;, s.leader, s.id))
	}
	if s.vote != 0 {
		panic(fmt.Sprintf(&amp;quot;vote (%d) not zero when entering leaderSelect&amp;quot;, s.leader))
	}

	// 5.3 Log replication: &amp;quot;The leader maintains a nextIndex for each follower,
	// which is the index of the next log entry the leader will send to that
	// follower. When a leader first comes to power it initializes all nextIndex
	// values to the index just after the last one in its log.&amp;quot;
	//
	// I changed this from lastIndex+1 to simply lastIndex. Every initial
	// communication from leader to follower was being rejected and we were
	// doing the decrement. This was just annoying, except if you manage to
	// sneak in a command before the first heartbeat. Then, it will never get
	// properly replicated (it seemed).
	
	// Leader为每个Follower保存了最新的同步日志索引
	ni := newNextIndex(s.config.allPeers().except(s.id), s.log.lastIndex()) // +1)

	flush := make(chan struct{})
	heartbeat := time.NewTicker(broadcastInterval())
	defer heartbeat.Stop()
	go func() {
      	// 发送心跳，除了检测心跳外，还有防止Follower发送选举
		for _ = range heartbeat.C {
			flush &amp;lt;- struct{}{}
		}
	}()

	for {
		select {
		case q := &amp;lt;-s.quit:
			s.handleQuit(q)
			return
		// 收到命令
		case t := &amp;lt;-s.commandChan:
			// Append the command to our (leader) log
			s.logGeneric(&amp;quot;got command, appending&amp;quot;)
			currentTerm := s.term
			entry := logEntry{
				Index:           s.log.lastIndex() + 1,
				Term:            currentTerm,
				Command:         t.Command,
				commandResponse: t.CommandResponse,
			}
          	// 追加日志
			if err := s.log.appendEntry(entry); err != nil {
				t.Err &amp;lt;- err
				continue
			}
			s.logGeneric(
				&amp;quot;after append, commitIndex=%d lastIndex=%d lastTerm=%d&amp;quot;,
				s.log.getCommitIndex(),
				s.log.lastIndex(),
				s.log.lastTerm(),
			)

			// Now that the entry is in the log, we can fall back to the
			// normal flushing mechanism to attempt to replicate the entry
			// and advance the commit index. We trigger a manual flush as a
			// convenience, so our caller might get a response a bit sooner.
          	// 这里将日志同步放到了同步队列就返回给客户端了，正常来说，需要&amp;quot;共识&amp;quot;达成才返回给客户端
			go func() { flush &amp;lt;- struct{}{} }()
			t.Err &amp;lt;- nil
        // 收到配置变更
		case t := &amp;lt;-s.configurationChan:
			// Attempt to change our local configuration
			if err := s.config.changeTo(makePeerMap(t.Peers...)); err != nil {
				t.Err &amp;lt;- err
				continue
			}

			// Serialize the local (C_old,new) configuration
			encodedConfiguration, err := s.config.encode()
			if err != nil {
				t.Err &amp;lt;- err
				continue
			}

			// We&#39;re gonna write+replicate that config via log mechanisms.
			// Prepare the on-commit callback.
			entry := logEntry{
				Index:           s.log.lastIndex() + 1,
				Term:            s.term,
				Command:         encodedConfiguration,
				isConfiguration: true,
				committed:       make(chan bool),
			}
			go func() {
              	// 当日志被commited时，committed将被回调
				committed := &amp;lt;-entry.committed
				if !committed {
					s.config.changeAborted()
					return
				}
             	// 日志被committed了，说明其他节点都应用了最新的配置，所以当前的节点配置也需要更新
				s.config.changeCommitted()
				if _, ok := s.config.allPeers()[s.id]; !ok {
                  	// 当前节点已被新集群剔除
					s.logGeneric(&amp;quot;leader expelled; shutting down&amp;quot;)
					q := make(chan struct{})
					s.quit &amp;lt;- q
                  	// 节点已退出
					&amp;lt;-q
				}
			}()
          	// 日志追加
			if err := s.log.appendEntry(entry); err != nil {
				t.Err &amp;lt;- err
				continue
			}

		case &amp;lt;-flush:
          	// 获取需要同步的节点
			recipients := s.config.allPeers().except(s.id)

			// Special case: network of 1
			if len(recipients) &amp;lt;= 0 {
				ourLastIndex := s.log.lastIndex()
				if ourLastIndex &amp;gt; 0 {
					if err := s.log.commitTo(ourLastIndex); err != nil {
						s.logGeneric(&amp;quot;commitTo(%d): %s&amp;quot;, ourLastIndex, err)
						continue
					}
					s.logGeneric(&amp;quot;after commitTo(%d), commitIndex=%d&amp;quot;, ourLastIndex, s.log.getCommitIndex())
				}
				continue
			}

			// Normal case: network of at-least-2
          	// 并发同步日志
			successes, stepDown := s.concurrentFlush(recipients, ni, 2*broadcastInterval())
			if stepDown {
              	// 节点已被卸任
				s.logGeneric(&amp;quot;deposed during flush&amp;quot;)
				s.state.Set(follower)
				s.leader = unknownLeader
				return
			}

			// Only when we know all followers accepted the flush can we
			// consider incrementing commitIndex and pushing out another
			// round of flushes.
			if successes == len(recipients) {
              	// 最小被同步的Index
				peersBestIndex := ni.bestIndex()
				ourLastIndex := s.log.lastIndex()
				ourCommitIndex := s.log.getCommitIndex()
				if peersBestIndex &amp;gt; ourLastIndex {
					// safety check: we&#39;ve probably been deposed
					s.logGeneric(&amp;quot;peers&#39; best index %d &amp;gt; our lastIndex %d&amp;quot;, peersBestIndex, ourLastIndex)
					s.logGeneric(&amp;quot;this is crazy, I&#39;m gonna become a follower&amp;quot;)
					s.leader = unknownLeader
					s.vote = noVote
					s.state.Set(follower)
					return
				}
				if peersBestIndex &amp;gt; ourCommitIndex {
					// committed Leader Index
                  	if err := s.log.commitTo(peersBestIndex); err != nil {
						s.logGeneric(&amp;quot;commitTo(%d): %s&amp;quot;, peersBestIndex, err)
                      	// 比如某个Follower在同步Index时失败了，
						continue // oh well, next time?
					}
					
					if s.log.getCommitIndex() &amp;gt; ourCommitIndex {
						// 继续同步日志
						s.logGeneric(&amp;quot;after commitTo(%d), commitIndex=%d -- queueing another flush&amp;quot;, peersBestIndex, s.log.getCommitIndex())
						go func() { flush &amp;lt;- struct{}{} }()
					}
				}
			}
		// 追加日志， 正常来说，Leader节点是不会受到该命令的，出现这种的可能是集群存在一个新的Leader节点，这命令就是该Leader发送过来的
		case t := &amp;lt;-s.appendEntriesChan:
			resp, stepDown := s.handleAppendEntries(t.Request)
			s.logAppendEntriesResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
			if stepDown {
				s.logGeneric(&amp;quot;after an appendEntries, deposed to Follower (leader=%d)&amp;quot;, t.Request.LeaderID)
				s.leader = t.Request.LeaderID
				s.state.Set(follower)
				return // deposed
			}
		// 受到投票请求
		case t := &amp;lt;-s.requestVoteChan:
			resp, stepDown := s.handleRequestVote(t.Request)
			s.logRequestVoteResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
			if stepDown {
				s.logGeneric(&amp;quot;after a requestVote, deposed to Follower (leader unknown)&amp;quot;)
				s.leader = unknownLeader
				s.state.Set(follower)
				return // deposed
			}
		}
	}
}

// handleRequestVote will modify s.term and s.vote, but nothing else.
// stepDown means you need to: s.leader=unknownLeader, s.state.Set(Follower).
// 处理投票
// 可能会修改s.term和s.vote 的值; stepDown意味着需要设置s.leader = unkownLeader, s.state.Set(Follower)
func (s *Server) handleRequestVote(rv requestVote) (requestVoteResponse, bool) {
	// Spec is ambiguous here; basing this (loosely!) on benbjohnson&#39;s impl

	// If the request is from an old term, reject
	if rv.Term &amp;lt; s.term {
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason:      fmt.Sprintf(&amp;quot;Term %d &amp;lt; %d&amp;quot;, rv.Term, s.term),
		}, false
	}

	// If the request is from a newer term, reset our state
	stepDown := false
	if rv.Term &amp;gt; s.term {
		// 本地节点落后于集群的其他节点，需要更新一下自己的任期号
		s.logGeneric(&amp;quot;requestVote from newer term (%d): we defer&amp;quot;, rv.Term)
		s.term = rv.Term
		s.vote = noVote
		s.leader = unknownLeader
		stepDown = true
	}

	// Special case: if we&#39;re the leader, and we haven&#39;t been deposed by a more
	// recent term, then we should always deny the vote
	if s.state.Get() == leader &amp;amp;&amp;amp; !stepDown {
		// 如果本地节点是Leader，并且又不落后于req 节点，则投反对票
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason:      &amp;quot;already the leader&amp;quot;,
		}, stepDown
	}

	// If we&#39;ve already voted for someone else this term, reject
	// 如果已经投过票，则投失败票
	if s.vote != 0 &amp;amp;&amp;amp; s.vote != rv.CandidateID {
		if stepDown {
			panic(&amp;quot;impossible state in handleRequestVote&amp;quot;)
		}
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason:      fmt.Sprintf(&amp;quot;already cast vote for %d&amp;quot;, s.vote),
		}, stepDown
	}

	// If the candidate log isn&#39;t at least as recent as ours, reject
	if s.log.lastIndex() &amp;gt; rv.LastLogIndex || s.log.lastTerm() &amp;gt; rv.LastLogTerm {
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason: fmt.Sprintf(
				&amp;quot;our index/term %d/%d &amp;gt; %d/%d&amp;quot;,
				s.log.lastIndex(),
				s.log.lastTerm(),
				rv.LastLogIndex,
				rv.LastLogTerm,
			),
		}, stepDown
	}

	// We passed all the tests: cast vote in favor
	s.vote = rv.CandidateID
	s.resetElectionTimeout()
	return requestVoteResponse{
		Term:        s.term,
		VoteGranted: true,
	}, stepDown
}

// handleAppendEntries will modify s.term and s.vote, but nothing else.
// stepDown means you need to: s.leader=r.LeaderID, s.state.Set(Follower).
// 追加日志，需要注意的是，handleAppendEntries也会修改s.term和s.vote
// stepDown也会修改s.Leader, s,state
// 需要注意的是，本地节点的state不同时，其行为也是不用的
func (s *Server) handleAppendEntries(r appendEntries) (appendEntriesResponse, bool) {
	// Spec is ambiguous here; basing this on benbjohnson&#39;s impl

	// Maybe a nicer way to handle this is to define explicit handler functions
	// for each Server state. Then, we won&#39;t try to hide too much logic (i.e.
	// too many protocol rules) in one code path.

	// If the request is from an old term, reject
	if r.Term &amp;lt; s.term {
		return appendEntriesResponse{
			Term:    s.term,
			Success: false,
			reason:  fmt.Sprintf(&amp;quot;Term %d &amp;lt; %d&amp;quot;, r.Term, s.term),
		}, false
	}

	// If the request is from a newer term, reset our state
	stepDown := false
	if r.Term &amp;gt; s.term {
		s.term = r.Term
		s.vote = noVote
		stepDown = true
	}

	// Special case for candidates: &amp;quot;While waiting for votes, a candidate may
	// receive an appendEntries RPC from another server claiming to be leader.
	// If the leader’s term (included in its RPC) is at least as large as the
	// candidate’s current term, then the candidate recognizes the leader as
	// legitimate and steps down, meaning that it returns to follower state.&amp;quot;
	if s.state.Get() == candidate &amp;amp;&amp;amp; r.LeaderID != s.leader &amp;amp;&amp;amp; r.Term &amp;gt;= s.term {
		s.term = r.Term
		s.vote = noVote
		stepDown = true
	}

	// In any case, reset our election timeout
	s.resetElectionTimeout()

	// Reject if log doesn&#39;t contain a matching previous entry
	// 如果{PreLogIndex, PreLogTerm} 不是最新的条目，则失败
	// [{1, 2},{1, 3},		{1,4},{1,5},{1,6}] =&amp;gt; {1,5} =&amp;gt; [{1, 2},{1, 3},		{1,4},{1,5}]
	if err := s.log.ensureLastIs(r.PrevLogIndex, r.PrevLogTerm); err != nil {
		return appendEntriesResponse{
			Term:    s.term,
			Success: false,
			reason: fmt.Sprintf(
				&amp;quot;while ensuring last log entry had index=%d term=%d: error: %s&amp;quot;,
				r.PrevLogIndex,
				r.PrevLogTerm,
				err,
			),
		}, stepDown
	}

	// Process the entries
	for i, entry := range r.Entries {
		// Configuration changes requre special preprocessing
		var pm peerMap
		// 处理配置
		if entry.isConfiguration {
			commandBuf := bytes.NewBuffer(entry.Command)
			if err := gob.NewDecoder(commandBuf).Decode(&amp;amp;pm); err != nil {
				panic(&amp;quot;gob decode of peers failed&amp;quot;)
			}

			if s.state.Get() == leader {
				// TODO should we instead just ignore this entry?
				return appendEntriesResponse{
					Term:    s.term,
					Success: false,
					reason: fmt.Sprintf(
						&amp;quot;AppendEntry %d/%d failed (configuration): %s&amp;quot;,
						i+1,
						len(r.Entries),
						&amp;quot;Leader shouldn&#39;t receive configurations via appendEntries&amp;quot;,
					),
				}, stepDown
			}

			// Expulsion recognition
			if _, ok := pm[s.id]; !ok {
				entry.committed = make(chan bool)
				go func() {
					if &amp;lt;-entry.committed {
						s.logGeneric(&amp;quot;non-leader expelled; shutting down&amp;quot;)
						q := make(chan struct{})
						s.quit &amp;lt;- q
						&amp;lt;-q
					}
				}()
			}
		}

		// Append entry to the log
		if err := s.log.appendEntry(entry); err != nil {
			return appendEntriesResponse{
				Term:    s.term,
				Success: false,
				reason: fmt.Sprintf(
					&amp;quot;AppendEntry %d/%d failed: %s&amp;quot;,
					i+1,
					len(r.Entries),
					err,
				),
			}, stepDown
		}

		// &amp;quot;Once a given server adds the new configuration entry to its log, it
		// uses that configuration for all future decisions (it does not wait
		// for the entry to become committed).&amp;quot;
		if entry.isConfiguration {
			if err := s.config.directSet(pm); err != nil {
				return appendEntriesResponse{
					Term:    s.term,
					Success: false,
					reason: fmt.Sprintf(
						&amp;quot;AppendEntry %d/%d failed (configuration): %s&amp;quot;,
						i+1,
						len(r.Entries),
						err,
					),
				}, stepDown
			}
		}
	}

	// Commit up to the commit index.
	//
	// &amp;lt; ptrb&amp;gt; ongardie: if the new leader sends a 0-entry appendEntries
	//  with lastIndex=5 commitIndex=4, to a follower that has lastIndex=5
	//  commitIndex=5 -- in my impl, this fails, because commitIndex is too
	//  small. shouldn&#39;t be?
	// &amp;lt;@ongardie&amp;gt; ptrb: i don&#39;t think that should fail
	// &amp;lt;@ongardie&amp;gt; there are 4 ways an appendEntries request can fail: (1)
	//  network drops packet (2) caller has stale term (3) would leave gap in
	//  the recipient&#39;s log (4) term of entry preceding the new entries doesn&#39;t
	//  match the term at the same index on the recipient
	// 
	// 出现这种情况的原因可能是本地节点运行到committed逻辑的时候出现了问题，或者说应答给Leader时，网络出现了问题等等。
	// 这些情况都会造成数据不同步的情况，也就是本地节点的commiitted情况和Leader节点保存的Follower(本地节点)不一致
	if r.CommitIndex &amp;gt; 0 &amp;amp;&amp;amp; r.CommitIndex &amp;gt; s.log.getCommitIndex() {
		if err := s.log.commitTo(r.CommitIndex); err != nil {
			return appendEntriesResponse{
				Term:    s.term,
				Success: false,
				reason:  fmt.Sprintf(&amp;quot;CommitTo(%d) failed: %s&amp;quot;, r.CommitIndex, err),
			}, stepDown
		}
	}

	// all good
	return appendEntriesResponse{
		Term:    s.term,
		Success: true,
	}, stepDown
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configuration-go&#34;&gt;configuration.go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
       	errConfigurationAlreadyChanging = errors.New(&amp;quot;configuration already changing&amp;quot;)
)

const (
       	cOld    = &amp;quot;C_old&amp;quot;
       	cOldNew = &amp;quot;C_old,new&amp;quot;
)

// configuration represents the sets of peers and behaviors required to
// implement joint-consensus.
type configuration struct {
       	sync.RWMutex
       	state     string
       	// 老配置
       	cOldPeers peerMap
       	// 新配置-》用于过度
       	cNewPeers peerMap
}

// newConfiguration returns a new configuration in stable (C_old) state based
// on the passed peers.
func newConfiguration(pm peerMap) *configuration {
       	return &amp;amp;configuration{
       		state:     cOld, // start in a stable state,
       		cOldPeers: pm,   // with only C_old
       	}
}

// directSet is used when bootstrapping, and when receiving a replicated
// configuration from a leader. It directly sets the configuration to the
// passed peers. It&#39;s assumed this is called on a non-leader, and therefore
// requires no consistency dance.
// 配置变更
func (c *configuration) directSet(pm peerMap) error {
       	c.Lock()
       	defer c.Unlock()

       	c.cOldPeers = pm
       	c.cNewPeers = peerMap{}
       	c.state = cOld
       	return nil
}

func (c *configuration) get(id uint64) (Peer, bool) {
       	c.RLock()
       	defer c.RUnlock()

       	if peer, ok := c.cOldPeers[id]; ok {
       		return peer, true
       	}
       	if peer, ok := c.cNewPeers[id]; ok {
       		return peer, true
       	}
       	return nil, false
}

func (c *configuration) encode() ([]byte, error) {
       	buf := &amp;amp;bytes.Buffer{}
       	if err := gob.NewEncoder(buf).Encode(c.allPeers()); err != nil {
       		return []byte{}, err
       	}
       	return buf.Bytes(), nil
}

// allPeers returns the union set of all peers in the configuration.
func (c *configuration) allPeers() peerMap {
       	c.RLock()
       	defer c.RUnlock()

       	union := peerMap{}
       	for id, peer := range c.cOldPeers {
       		union[id] = peer
       	}
       	for id, peer := range c.cNewPeers {
       		union[id] = peer
       	}
       	return union
}

// pass returns true if the votes represented by the votes map are sufficient
// to constitute a quorum. pass respects C_old,new requirements, which dictate
// that any request must receive a majority from both C_old and C_new to pass.
// 共识判断
func (c *configuration) pass(votes map[uint64]bool) bool {
       	c.RLock()
       	defer c.RUnlock()

       	// Count the votes
       	cOldHave, cOldRequired := 0, c.cOldPeers.quorum()
       	for id := range c.cOldPeers {
       		if votes[id] {
       			cOldHave++
       		}
       		if cOldHave &amp;gt;= cOldRequired {
       			break
       		}
       	}

       	// If we&#39;ve already failed, we can stop here
       	if cOldHave &amp;lt; cOldRequired {
       		return false
       	}

       	// C_old passes: if we&#39;re in C_old, we pass
       	if c.state == cOld {
       		return true
       	}

       	// Not in C_old, so make sure we have some peers in C_new
       	if len(c.cNewPeers) &amp;lt;= 0 {
       		panic(fmt.Sprintf(&amp;quot;configuration state &#39;%s&#39;, but no C_new peers&amp;quot;, c.state))
       	}

       	// Since we&#39;re in C_old,new, we need to also pass C_new to pass overall.
       	// It&#39;s important that we range through C_new and check our votes map, and
       	// not the other way around: if a server casts a vote but doesn&#39;t exist in
       	// a particular configuration, that vote should not be counted.
       	cNewHave, cNewRequired := 0, c.cNewPeers.quorum()
       	for id := range c.cNewPeers {
       		if votes[id] {
       			cNewHave++
       		}
       		if cNewHave &amp;gt;= cNewRequired {
       			break
       		}
       	}

       	return cNewHave &amp;gt;= cNewRequired
}

// 配置变更准备, prepare-change
func (c *configuration) changeTo(pm peerMap) error {
       	c.Lock()
       	defer c.Unlock()

       	if c.state != cOld {
       		return errConfigurationAlreadyChanging
       	}

       	if len(c.cNewPeers) &amp;gt; 0 {
       		panic(fmt.Sprintf(&amp;quot;configuration ChangeTo in state &#39;%s&#39;, but have C_new peers already&amp;quot;, c.state))
       	}

       	c.cNewPeers = pm
       	c.state = cOldNew
       	return nil
}

// 提交变更逻辑
func (c *configuration) changeCommitted() {
       	c.Lock()
       	defer c.Unlock()

       	if c.state != cOldNew {
       		panic(&amp;quot;configuration ChangeCommitted, but not in C_old,new&amp;quot;)
       	}

       	if len(c.cNewPeers) &amp;lt;= 0 {
       		panic(&amp;quot;configuration ChangeCommitted, but C_new peers are empty&amp;quot;)
       	}

       	c.cOldPeers = c.cNewPeers
       	c.cNewPeers = peerMap{}
       	c.state = cOld
}

// 中断变更
func (c *configuration) changeAborted() {
       	c.Lock()
       	defer c.Unlock()

       	if c.state != cOldNew {
       		panic(&amp;quot;configuration ChangeAborted, but not in C_old,new&amp;quot;)
       	}

       	c.cNewPeers = peerMap{}
       	c.state = cOld
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;demo&#34;&gt;Demo&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
       	&amp;quot;bytes&amp;quot;
       	&amp;quot;fmt&amp;quot;
       	&amp;quot;hash/fnv&amp;quot;
       	&amp;quot;net/http&amp;quot;
       	&amp;quot;net/url&amp;quot;
       	&amp;quot;time&amp;quot;

       	&amp;quot;github.com/peterbourgon/raft&amp;quot;
)

func main() {
       	a := func(idx uint64, cmd []byte) []byte {
       		fmt.Printf(&amp;quot;%d, apply function: %s\n&amp;quot;, idx, cmd)
       		return cmd
       	}

       	mustParseURL := func(rawURL string) *url.URL {
       		u, _ := url.Parse(rawURL)
       		u.Path = &amp;quot;&amp;quot;
       		return u
       	}
       	mustNewHTTPPeer := func(u *url.URL) raft.Peer {
       		p, err := raft.NewHTTPPeer(u)
       		if err != nil {
       			panic(err)
       		}
       		return p
       	}
       	peersAddr := []string{
       		&amp;quot;127.0.0.1:7090&amp;quot;,
       		&amp;quot;127.0.0.1:7091&amp;quot;,
       		&amp;quot;127.0.0.1:7092&amp;quot;,
       		&amp;quot;127.0.0.1:7093&amp;quot;,
       		&amp;quot;127.0.0.1:7094&amp;quot;}
       	var ss []*raft.Server
       	for _, addr := range peersAddr {
       		hash := fnv.New64()
       		hash.Write([]byte(addr))
       		id := hash.Sum64()
       		hash.Reset()
       		s := raft.NewServer(id, &amp;amp;bytes.Buffer{}, a)
       		mux := http.NewServeMux()
       		raft.HTTPTransport(mux, s)
       		go func(addr string) {
       			if err := http.ListenAndServe(addr, mux); err != nil {
       				panic(err)
       			}
       		}(addr)
       		ss = append(ss, s)
       	}
       	time.Sleep(time.Second)
       	for _, s := range ss {
       		s.SetConfiguration(
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7090&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7091&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7092&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7093&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7094&amp;quot;)),
       		)
       		s.Start()
       	}

       	for {
       		cmd := []byte(time.Now().String())
       		cmdChan := make(chan []byte)
       		go ss[0].Command(cmd, cmdChan)
       		&amp;lt;-cmdChan
       		time.Sleep(time.Millisecond * 500)
       	}

       	time.Sleep(time.Hour)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Run&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;» go run raft-server.go 2&amp;gt;/dev/null     
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
7, apply function: 2017-09-11 11:41:16.677758823 +0800 CST
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>200行区块链</title>
      <link>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97/</link>
      <pubDate>Sun, 12 Mar 2017 23:46:57 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97/</guid>
      <description>&lt;pre&gt;&lt;code&gt;talk is cheap, show me the code!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;crypto/sha256&amp;quot;
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	log &amp;quot;github.com/laohanlinux/utils/gokitlog&amp;quot;
	&amp;quot;github.com/laohanlinux/utils/netrpc&amp;quot;
	pool &amp;quot;github.com/laohanlinux/utils/pool/rpc&amp;quot;
)

var (
	blockChain       = []Block{GetGenesiseBlock()}
	initialPeers     = flag.String(&amp;quot;peers&amp;quot;, &amp;quot;localhost:6660,localhost:6661,localhost:6662&amp;quot;, &amp;quot;&amp;quot;)
	httpPort         = flag.String(&amp;quot;http_port&amp;quot;, &amp;quot;localhost:7000&amp;quot;, &amp;quot;&amp;quot;)
	p2pPort          = flag.String(&amp;quot;p2p_port&amp;quot;, &amp;quot;localhost:6660&amp;quot;, &amp;quot;&amp;quot;)
	peersConnections = make(map[string]*pool.NetRPCRing)
	s                Service
)

func main() {
	flag.Parse()
	l, err := initP2PServer()
	if err != nil {
		log.Crit(&amp;quot;err&amp;quot;, err)
	}
	log.Debug(&amp;quot;p2pServer listener address&amp;quot;, *p2pPort)
	defer l.Close()
	peers := strings.Split(*initialPeers, &amp;quot;,&amp;quot;)
	conncetToPeers(peers)
	initHttpServer()
	time.Sleep(time.Hour * 10000)
}

type Block struct {
	Index        int64
	PreviousHash string
	TimeStamp    int64
	Data         []byte
	Hash         string
}

func NewBlock(index int64, previousHash string, timeStamp int64, Data []byte, Hash string) Block {
	return Block{
		Index:        index,
		PreviousHash: previousHash,
		TimeStamp:    timeStamp,
		Data:         Data,
		Hash:         Hash,
	}
}

func CalculationHashForBlock(block Block) string {
	return CalculationHash(block.Index, block.PreviousHash, block.TimeStamp, block.Data)
}

func CalculationHash(index int64, previousHash string, timeStamp int64, data []byte) string {
	return fmt.Sprintf(&amp;quot;%x&amp;quot;, sha256.Sum256([]byte(fmt.Sprintf(&amp;quot;%v%v%v%s&amp;quot;, index, previousHash, timeStamp, data))))
}

func GenerateNextBlock(blockData []byte) Block {
	var (
		previousBlock = getLatestBlock()
		nextIndex     = previousBlock.Index + 1
		nextTimeStamp = time.Now().Unix()
		nextHash      = CalculationHash(nextIndex, previousBlock.Hash, nextTimeStamp, blockData)
	)
	return NewBlock(nextIndex, previousBlock.Hash, nextTimeStamp, blockData, nextHash)
}

func GetGenesiseBlock() Block {
	return NewBlock(0, &amp;quot;0&amp;quot;, 1465154705, []byte(&amp;quot;my genesis block!!&amp;quot;), &amp;quot;816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7&amp;quot;)
}

func AddBlock(newBlock Block) {
	if isValidNewBlock(newBlock, getLatestBlock()) {
		blockChain = append(blockChain, newBlock)
	}
}

func replaceChain(newBlocks []Block) {
	if isValidBlock(newBlocks) &amp;amp;&amp;amp; len(newBlocks) &amp;gt; len(blockChain) {
		log.Warnf(&amp;quot;received blockchain is valid, replacing current blockchain with received blockchain&amp;quot;)
		blockChain = newBlocks
		// broadcast
		for _, peerClient := range peersConnections {
			go peerClient.Call(serviceAddBlockChain, &amp;amp;AddBlockChainArgs{NewBlockChain: blockChain}, &amp;amp;AddBlockChainReply{})
		}
	} else {
		log.Debugf(&amp;quot;received blockchain invalid&amp;quot;)
	}
}

func isValidNewBlock(newBlock, previousBlock Block) bool {
	if previousBlock.Index+1 != newBlock.Index {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid index&amp;quot;)
		return false
	}
	if previousBlock.Hash != newBlock.PreviousHash {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid previousHash&amp;quot;)
		return false
	}
	// check wether newBlock.Hash is right calculation by his content
	if CalculationHashForBlock(newBlock) != newBlock.Hash {
		log.Debugf(&amp;quot;invalid hash: %v, %v&amp;quot;, CalculationHashForBlock(newBlock), newBlock.Hash)
		return false
	}
	return true
}

func isValidBlock(blockChainToValidate []Block) bool {
	// check genesis block
	if blockChainToValidate[0].Hash != GetGenesiseBlock().Hash {
		return false
	}

	for i := 1; i &amp;lt; len(blockChainToValidate); i++ {
		if !isValidNewBlock(blockChainToValidate[i], blockChainToValidate[i-1]) {
			return false
		}
	}
	return true
}

func getLatestBlock() Block { return blockChain[len(blockChain)-1] }

func initHttpServer() {
	router := gin.Default()
	router.GET(&amp;quot;/blocks&amp;quot;, func(c *gin.Context) { json.NewEncoder(c.Writer).Encode(blockChain) })
	router.POST(&amp;quot;/mineBlock&amp;quot;, func(c *gin.Context) {
		var (
			buf []byte
			err error
		)
		if buf, err = ioutil.ReadAll(c.Request.Body); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusInternalServerError)
			return
		}
		AddBlock(GenerateNextBlock(buf))
		// broadcast to notify peers our has add new block
		for _, peerClient := range peersConnections {
			go func() {
				var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: blockChain}, AddBlockChainReply{}
				if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
					log.Error(&amp;quot;err&amp;quot;, err)
				}
			}()
		}
		c.Writer.WriteHeader(http.StatusOK)
	})
	router.GET(&amp;quot;/peers&amp;quot;, func(c *gin.Context) {
		var peers []string
		for peer, _ := range peersConnections {
			peers = append(peers, peer)
		}
		if err := json.NewEncoder(c.Writer).Encode(peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		}
	})
	router.POST(&amp;quot;/addPeer&amp;quot;, func(c *gin.Context) {
		var peers []string
		if err := json.NewDecoder(c.Request.Body).Decode(&amp;amp;peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusBadRequest)
			return
		}
		conncetToPeers(peers)
	})
	go http.ListenAndServe(*httpPort, router)
}

func initP2PServer() (net.Listener, error) {

	l, err := net.Listen(&amp;quot;tcp&amp;quot;, *p2pPort)
	if err != nil {
		return nil, err
	}
	server := netrpc.NewServer()
	server.Register(&amp;amp;s)
	server.Register(&amp;amp;netrpc.HealthCheck{})
	go server.Accept(l)

	return l, nil
}

func conncetToPeers(peers []string) {
	var (
		rpcOpt pool.NetRPCRingOpt
	)
	for _, peer := range peers {
		if _, ok := peersConnections[peer]; ok {
			continue
		}
		rpcOpt.Addr, rpcOpt.NetWork, rpcOpt.PoolSize = peer, &amp;quot;tcp&amp;quot;, 1
		if pools, err := pool.NewNetRPCRing([]pool.NetRPCRingOpt{rpcOpt}); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		} else {
			peersConnections[peer] = pools
		}
	}
}

// AddBlockChain add new blockchain into cluster
// if the new block is new than local lasted block, agree it
func handleBlockChain(args AddBlockChainArgs) {
	log.Debug(&amp;quot;who&amp;quot;, *p2pPort, &amp;quot;do&amp;quot;, &amp;quot;handle blockchain&amp;quot;)
	var (
		receivedBlocks      = args.NewBlockChain
		latestBlockReceived = receivedBlocks[len(receivedBlocks)-1]
		latestBlockHeld     = getLatestBlock()
	)
	if latestBlockReceived.Index &amp;gt; latestBlockHeld.Index {
		log.Warnf(&amp;quot;blockchain possibly behind. We got: %v Peer got: %v&amp;quot;, latestBlockHeld.Index, latestBlockReceived.Index)
		if latestBlockHeld.Hash == latestBlockReceived.PreviousHash {
			log.Warnf(&amp;quot;We can append the received block to our block&amp;quot;)
			blockChain = append(blockChain, latestBlockReceived)
			// broadcast to other
			for _, peerClient := range peersConnections {
				go func() {
					var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: args.NewBlockChain}, AddBlockChainReply{}
					if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					}
				}()
			}
		} else if len(receivedBlocks) == 1 {
			log.Warnf(&amp;quot;we have must query the chain from our peer&amp;quot;)
			// broadcast
			for _, peersClient := range peersConnections {
				go func() {
					var (
						rpcArgs  QueryAllBlockChainsArgs
						rpcreply QueryAllBlockChainsReply
						err      error
					)
					if err = peersClient.Call(serviceQueryAllBlockChains, &amp;amp;rpcArgs, &amp;amp;rpcreply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					} else {
						handleBlockChain(AddBlockChainArgs{NewBlockChain: rpcreply.NewBlockChains})
					}
				}()
			}
		} else {
			log.Debugf(&amp;quot;Received blockchain is longer than current blockchain&amp;quot;)
			replaceChain(receivedBlocks)
		}
	} else {
		log.Debug(&amp;quot;received blockchain is not longer than received blockchain. Do nothing&amp;quot;)
	}
}

const (
	serviceName                = &amp;quot;Service&amp;quot;
	serviceAddBlockChain       = serviceName + &amp;quot;.AddBlockChain&amp;quot;
	serviceQueryAllBlockChains = serviceName + &amp;quot;.QueryAllBlockChains&amp;quot;
)

type AddBlockChainArgs struct{ NewBlockChain []Block }

type AddBlockChainReply struct{}

///////
type QueryAllBlockChainsArgs struct{}
type QueryAllBlockChainsReply struct{ NewBlockChains []Block }

//////
type Service struct{}

func (s *Service) QueryAllMsg(_ context.Context, _ *QueryAllBlockChainsArgs, reply *QueryAllBlockChainsReply) error {
	reply.NewBlockChains = blockChain
	return nil
}

func (s *Service) AddBlockChain(_ context.Context, args *AddBlockChainArgs, reply *AddBlockChainReply) error {
	handleBlockChain(*args)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build -o blockchain main.go

sudo pkill -9 blockchain 

./blockchain -http_port=&amp;quot;localhost:7000&amp;quot; -p2p_port=&amp;quot;localhost:6660&amp;quot;   -peers=&amp;quot;localhost:6661&amp;quot; &amp;amp;

./blockchain -http_port=&amp;quot;localhost:7001&amp;quot; -p2p_port=&amp;quot;localhost:6661&amp;quot;   -peers=&amp;quot;localhost:6660&amp;quot; &amp;amp; 

sleep 1 

curl -v -XPOST &amp;quot;http://localhost:7001/addPeer&amp;quot; -d &#39;[localhost:6660]&#39; | jq 
sleep 2
curl -v -XPOST &amp;quot;http://localhost:7000/addPeer&amp;quot; -d &#39;[localhost:6661]&#39; | jq 
sleep 2

curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 


curl -v &amp;quot;http://localhost:7001/blocks&amp;quot; | jq 
sleep 1 

curl -v &amp;quot;http://localhost:7000/blocks&amp;quot; | jq 

curl -v &amp;quot;http://localhost:7000/peers&amp;quot; | jq 
curl -v &amp;quot;http://localhost:7001/peers&amp;quot; | jq 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较简单，拿来看看就好了，别太在意&amp;hellip;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原版 &lt;a href=&#34;https://github.com/lhartikk/naivechain.git&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/lhartikk/naivechain.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>200行区块链-go语言版本</title>
      <link>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97%E9%93%BE-go%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sun, 12 Mar 2017 23:46:57 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97%E9%93%BE-go%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/</guid>
      <description>&lt;pre&gt;&lt;code&gt;talk is cheap, show me the code!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;crypto/sha256&amp;quot;
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	log &amp;quot;github.com/laohanlinux/utils/gokitlog&amp;quot;
	&amp;quot;github.com/laohanlinux/utils/netrpc&amp;quot;
	pool &amp;quot;github.com/laohanlinux/utils/pool/rpc&amp;quot;
)

var (
	blockChain       = []Block{GetGenesiseBlock()}
	initialPeers     = flag.String(&amp;quot;peers&amp;quot;, &amp;quot;localhost:6660,localhost:6661,localhost:6662&amp;quot;, &amp;quot;&amp;quot;)
	httpPort         = flag.String(&amp;quot;http_port&amp;quot;, &amp;quot;localhost:7000&amp;quot;, &amp;quot;&amp;quot;)
	p2pPort          = flag.String(&amp;quot;p2p_port&amp;quot;, &amp;quot;localhost:6660&amp;quot;, &amp;quot;&amp;quot;)
	peersConnections = make(map[string]*pool.NetRPCRing)
	s                Service
)

func main() {
	flag.Parse()
	l, err := initP2PServer()
	if err != nil {
		log.Crit(&amp;quot;err&amp;quot;, err)
	}
	log.Debug(&amp;quot;p2pServer listener address&amp;quot;, *p2pPort)
	defer l.Close()
	peers := strings.Split(*initialPeers, &amp;quot;,&amp;quot;)
	conncetToPeers(peers)
	initHttpServer()
	time.Sleep(time.Hour * 10000)
}

type Block struct {
	Index        int64
	PreviousHash string
	TimeStamp    int64
	Data         []byte
	Hash         string
}

func NewBlock(index int64, previousHash string, timeStamp int64, Data []byte, Hash string) Block {
	return Block{
		Index:        index,
		PreviousHash: previousHash,
		TimeStamp:    timeStamp,
		Data:         Data,
		Hash:         Hash,
	}
}

func CalculationHashForBlock(block Block) string {
	return CalculationHash(block.Index, block.PreviousHash, block.TimeStamp, block.Data)
}

func CalculationHash(index int64, previousHash string, timeStamp int64, data []byte) string {
	return fmt.Sprintf(&amp;quot;%x&amp;quot;, sha256.Sum256([]byte(fmt.Sprintf(&amp;quot;%v%v%v%s&amp;quot;, index, previousHash, timeStamp, data))))
}

func GenerateNextBlock(blockData []byte) Block {
	var (
		previousBlock = getLatestBlock()
		nextIndex     = previousBlock.Index + 1
		nextTimeStamp = time.Now().Unix()
		nextHash      = CalculationHash(nextIndex, previousBlock.Hash, nextTimeStamp, blockData)
	)
	return NewBlock(nextIndex, previousBlock.Hash, nextTimeStamp, blockData, nextHash)
}

func GetGenesiseBlock() Block {
	return NewBlock(0, &amp;quot;0&amp;quot;, 1465154705, []byte(&amp;quot;my genesis block!!&amp;quot;), &amp;quot;816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7&amp;quot;)
}

func AddBlock(newBlock Block) {
	if isValidNewBlock(newBlock, getLatestBlock()) {
		blockChain = append(blockChain, newBlock)
	}
}

func replaceChain(newBlocks []Block) {
	if isValidBlock(newBlocks) &amp;amp;&amp;amp; len(newBlocks) &amp;gt; len(blockChain) {
		log.Warnf(&amp;quot;received blockchain is valid, replacing current blockchain with received blockchain&amp;quot;)
		blockChain = newBlocks
		// broadcast
		for _, peerClient := range peersConnections {
			go peerClient.Call(serviceAddBlockChain, &amp;amp;AddBlockChainArgs{NewBlockChain: blockChain}, &amp;amp;AddBlockChainReply{})
		}
	} else {
		log.Debugf(&amp;quot;received blockchain invalid&amp;quot;)
	}
}

func isValidNewBlock(newBlock, previousBlock Block) bool {
	if previousBlock.Index+1 != newBlock.Index {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid index&amp;quot;)
		return false
	}
	if previousBlock.Hash != newBlock.PreviousHash {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid previousHash&amp;quot;)
		return false
	}
	// check wether newBlock.Hash is right calculation by his content
	if CalculationHashForBlock(newBlock) != newBlock.Hash {
		log.Debugf(&amp;quot;invalid hash: %v, %v&amp;quot;, CalculationHashForBlock(newBlock), newBlock.Hash)
		return false
	}
	return true
}

func isValidBlock(blockChainToValidate []Block) bool {
	// check genesis block
	if blockChainToValidate[0].Hash != GetGenesiseBlock().Hash {
		return false
	}

	for i := 1; i &amp;lt; len(blockChainToValidate); i++ {
		if !isValidNewBlock(blockChainToValidate[i], blockChainToValidate[i-1]) {
			return false
		}
	}
	return true
}

func getLatestBlock() Block { return blockChain[len(blockChain)-1] }

func initHttpServer() {
	router := gin.Default()
	router.GET(&amp;quot;/blocks&amp;quot;, func(c *gin.Context) { json.NewEncoder(c.Writer).Encode(blockChain) })
	router.POST(&amp;quot;/mineBlock&amp;quot;, func(c *gin.Context) {
		var (
			buf []byte
			err error
		)
		if buf, err = ioutil.ReadAll(c.Request.Body); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusInternalServerError)
			return
		}
		AddBlock(GenerateNextBlock(buf))
		// broadcast to notify peers our has add new block
		for _, peerClient := range peersConnections {
			go func() {
				var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: blockChain}, AddBlockChainReply{}
				if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
					log.Error(&amp;quot;err&amp;quot;, err)
				}
			}()
		}
		c.Writer.WriteHeader(http.StatusOK)
	})
	router.GET(&amp;quot;/peers&amp;quot;, func(c *gin.Context) {
		var peers []string
		for peer, _ := range peersConnections {
			peers = append(peers, peer)
		}
		if err := json.NewEncoder(c.Writer).Encode(peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		}
	})
	router.POST(&amp;quot;/addPeer&amp;quot;, func(c *gin.Context) {
		var peers []string
		if err := json.NewDecoder(c.Request.Body).Decode(&amp;amp;peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusBadRequest)
			return
		}
		conncetToPeers(peers)
	})
	go http.ListenAndServe(*httpPort, router)
}

func initP2PServer() (net.Listener, error) {

	l, err := net.Listen(&amp;quot;tcp&amp;quot;, *p2pPort)
	if err != nil {
		return nil, err
	}
	server := netrpc.NewServer()
	server.Register(&amp;amp;s)
	server.Register(&amp;amp;netrpc.HealthCheck{})
	go server.Accept(l)

	return l, nil
}

func conncetToPeers(peers []string) {
	var (
		rpcOpt pool.NetRPCRingOpt
	)
	for _, peer := range peers {
		if _, ok := peersConnections[peer]; ok {
			continue
		}
		rpcOpt.Addr, rpcOpt.NetWork, rpcOpt.PoolSize = peer, &amp;quot;tcp&amp;quot;, 1
		if pools, err := pool.NewNetRPCRing([]pool.NetRPCRingOpt{rpcOpt}); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		} else {
			peersConnections[peer] = pools
		}
	}
}

// AddBlockChain add new blockchain into cluster
// if the new block is new than local lasted block, agree it
func handleBlockChain(args AddBlockChainArgs) {
	log.Debug(&amp;quot;who&amp;quot;, *p2pPort, &amp;quot;do&amp;quot;, &amp;quot;handle blockchain&amp;quot;)
	var (
		receivedBlocks      = args.NewBlockChain
		latestBlockReceived = receivedBlocks[len(receivedBlocks)-1]
		latestBlockHeld     = getLatestBlock()
	)
	if latestBlockReceived.Index &amp;gt; latestBlockHeld.Index {
		log.Warnf(&amp;quot;blockchain possibly behind. We got: %v Peer got: %v&amp;quot;, latestBlockHeld.Index, latestBlockReceived.Index)
		if latestBlockHeld.Hash == latestBlockReceived.PreviousHash {
			log.Warnf(&amp;quot;We can append the received block to our block&amp;quot;)
			blockChain = append(blockChain, latestBlockReceived)
			// broadcast to other
			for _, peerClient := range peersConnections {
				go func() {
					var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: args.NewBlockChain}, AddBlockChainReply{}
					if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					}
				}()
			}
		} else if len(receivedBlocks) == 1 {
			log.Warnf(&amp;quot;we have must query the chain from our peer&amp;quot;)
			// broadcast
			for _, peersClient := range peersConnections {
				go func() {
					var (
						rpcArgs  QueryAllBlockChainsArgs
						rpcreply QueryAllBlockChainsReply
						err      error
					)
					if err = peersClient.Call(serviceQueryAllBlockChains, &amp;amp;rpcArgs, &amp;amp;rpcreply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					} else {
						handleBlockChain(AddBlockChainArgs{NewBlockChain: rpcreply.NewBlockChains})
					}
				}()
			}
		} else {
			log.Debugf(&amp;quot;Received blockchain is longer than current blockchain&amp;quot;)
			replaceChain(receivedBlocks)
		}
	} else {
		log.Debug(&amp;quot;received blockchain is not longer than received blockchain. Do nothing&amp;quot;)
	}
}

const (
	serviceName                = &amp;quot;Service&amp;quot;
	serviceAddBlockChain       = serviceName + &amp;quot;.AddBlockChain&amp;quot;
	serviceQueryAllBlockChains = serviceName + &amp;quot;.QueryAllBlockChains&amp;quot;
)

type AddBlockChainArgs struct{ NewBlockChain []Block }

type AddBlockChainReply struct{}

///////
type QueryAllBlockChainsArgs struct{}
type QueryAllBlockChainsReply struct{ NewBlockChains []Block }

//////
type Service struct{}

func (s *Service) QueryAllMsg(_ context.Context, _ *QueryAllBlockChainsArgs, reply *QueryAllBlockChainsReply) error {
	reply.NewBlockChains = blockChain
	return nil
}

func (s *Service) AddBlockChain(_ context.Context, args *AddBlockChainArgs, reply *AddBlockChainReply) error {
	handleBlockChain(*args)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build -o blockchain main.go

sudo pkill -9 blockchain 

./blockchain -http_port=&amp;quot;localhost:7000&amp;quot; -p2p_port=&amp;quot;localhost:6660&amp;quot;   -peers=&amp;quot;localhost:6661&amp;quot; &amp;amp;

./blockchain -http_port=&amp;quot;localhost:7001&amp;quot; -p2p_port=&amp;quot;localhost:6661&amp;quot;   -peers=&amp;quot;localhost:6660&amp;quot; &amp;amp; 

sleep 1 

curl -v -XPOST &amp;quot;http://localhost:7001/addPeer&amp;quot; -d &#39;[localhost:6660]&#39; | jq 
sleep 2
curl -v -XPOST &amp;quot;http://localhost:7000/addPeer&amp;quot; -d &#39;[localhost:6661]&#39; | jq 
sleep 2

curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 


curl -v &amp;quot;http://localhost:7001/blocks&amp;quot; | jq 
sleep 1 

curl -v &amp;quot;http://localhost:7000/blocks&amp;quot; | jq 

curl -v &amp;quot;http://localhost:7000/peers&amp;quot; | jq 
curl -v &amp;quot;http://localhost:7001/peers&amp;quot; | jq 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较简单，拿来看看就好了，别太在意&amp;hellip;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原版 &lt;a href=&#34;https://github.com/lhartikk/naivechain.git&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/lhartikk/naivechain.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>goim源码剖析1</title>
      <link>https://laohanlinux.github.io/2016/12/22/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%901/</link>
      <pubDate>Thu, 22 Dec 2016 00:47:22 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/12/22/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%901/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Goim Analysis of Source Code</title>
      <link>https://laohanlinux.github.io/2016/12/04/goim-analysis-of-source-code/</link>
      <pubDate>Sun, 04 Dec 2016 15:03:15 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/12/04/goim-analysis-of-source-code/</guid>
      <description>

&lt;h2 id=&#34;comet&#34;&gt;Comet&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;comet&lt;/code&gt;为用户代理服务器，用于客户端的连接，根据情况可部署多个&lt;code&gt;comet&lt;/code&gt;(部署机房选择以用户接入为基础，如：最近接入、按运营商接入)。&lt;/p&gt;

&lt;h3 id=&#34;流程图&#34;&gt;流程图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;comet&lt;/code&gt;支持&lt;code&gt;tcp&lt;/code&gt;以及&lt;code&gt;websocket&lt;/code&gt;的方式和客户端交互，而和&lt;code&gt;logic&lt;/code&gt;、&lt;code&gt;job&lt;/code&gt;模块之间的交互采用&lt;code&gt;rpc&lt;/code&gt;的方式，&lt;code&gt;comet&lt;/code&gt;的主要流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/comet-websocket.png&#34; alt=&#34;websocket&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; 图 1-1： comet websocket protoc&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/comet-tcp.png&#34; alt=&#34;tcp&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; 图 1-2： comet tcp protoc&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端首先连接到&lt;code&gt;comet&lt;/code&gt;服务，&lt;code&gt;comet&lt;/code&gt;调用&lt;code&gt;logic&lt;/code&gt;来校验用户的合法性，&lt;code&gt;logic&lt;/code&gt;会返回一个&lt;code&gt;subKey&lt;/code&gt;给&lt;code&gt;comet&lt;/code&gt;，该&lt;code&gt;subKey&lt;/code&gt;成为该连接的唯一标示；&lt;/li&gt;
&lt;li&gt;客户端接下来可以发心跳包给&lt;code&gt;comet&lt;/code&gt;，同时，&lt;code&gt;job&lt;/code&gt;服务将&lt;code&gt;MQ-Kafka&lt;/code&gt;的消息转发到对应&lt;code&gt;comet&lt;/code&gt;，&lt;code&gt;comet&lt;/code&gt;再将其转发到对应的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;其中Logic前面可以加上一层4层代理服务器，如LVS。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;主要逻辑代码分析&#34;&gt;主要逻辑代码分析&lt;/h3&gt;

&lt;h4 id=&#34;bucket&#34;&gt;bucket&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type BucketOptions struct {
	ChannelSize   int 
	RoomSize      int   // 房间（Bucket.rooms）的初始化个数
	RoutineAmount int64 // Bucket.routines数组大小
    RoutineSize   int   // 房间信道通信(proto.BoardcastRoomArg)缓冲区的大小
}

// Bucket is a channel holder.
type Bucket struct {
	cLock    sync.RWMutex        // protect the channels for chs
	chs      map[string]*Channel // map sub key to a channel
	boptions BucketOptions
	// room
	rooms       map[int32]*Room // bucket room channels
	routines    []chan *proto.BoardcastRoomArg // 节点房间的总信道数
	routinesNum uint64 // 处理routines信道的goroutine个数，用于消费房播的信道消息
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bucket-goroutine.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;图 1-3&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;房间信息推送流程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1、job通过rpc的方式发送msg到comet
2、comet内部将消息推送到至bucket.routines，bucket.routines以轮询的方式选出一个proto.BoardcastRoomArg信道进行消息转发
3、bucket.routines&#39;s worker 消费消息，根据msg&#39;roomid从roomsMap(bucket.rooms)选出该room的所有客户端Channels，再将消息一一转发至client&#39;Channel
4、dispatchWorker消费client&#39;Channel消息，通过websocket或者tcp协议发送到客户端
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单播推送流程：&lt;/p&gt;

&lt;p&gt;单播相对于&amp;rdquo;房播（群播）&amp;rdquo;，简化了房间检索的步骤。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1、job通过rpc的方式发送msg到comet
2、comet内部根据消息的subKey，从buckets中找出对应的channel，将消息转发到对应的Channel
3、dispatchWorker消费client&#39;Channel消息，通过websocket或者tcp协议发送到客户端
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; subKey的生成采用city32的hash算法，bucket是一个大小为n的hashMap slice，其主要目的是将数据切分成更小的块，从而降低资源的竞争。
&amp;gt; ```

多播以单播推送流程类似，广播也类似。

#### room

```go
type Room struct {
	id     int32        // 房间号
	rLock  sync.RWMutex // 锁
	next   *Channel     // 该房间的所有客户端的Channel
	drop   bool         // 标示房间是否存活
	Online int          // 房间的channel数量，即房间的在线用户的多少
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;next *Channel&lt;/code&gt;是一个双向链表，复杂度为&lt;code&gt;o(1)&lt;/code&gt;，效率比较高。&lt;/p&gt;

&lt;h4 id=&#34;tcp&#34;&gt;tcp&lt;/h4&gt;

&lt;p&gt;协议：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/tcp-proto.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;图 1-4&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BodySize&lt;/code&gt;范围：&lt;code&gt;0&amp;lt;=BodySize&amp;lt;=MaxBodySize = int32(1&amp;lt;&amp;lt;10)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PackSize&lt;/code&gt;范围：&lt;code&gt;RawHeaderSize&amp;lt;=PackSize&amp;lt;=MacPackSize(RawHeaderSize+BodySize)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Terry-Mao/goim/blob/master/doc/protocol.png&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;websocket&#34;&gt;websocket&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Terry-Mao/goim/blob/master/doc/proto.md&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;websocket协议&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;rpc&#34;&gt;RPC&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;rpc&lt;/code&gt;用于&lt;code&gt;logic&lt;/code&gt;、&lt;code&gt;job service&lt;/code&gt;模块的通信。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Push RPC
type PushRPC struct {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) Ping(arg *proto.NoArg, reply *proto.NoReply) error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;心跳&lt;code&gt;rpc&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) PushMsg(arg *proto.PushMsgArg, reply *proto.NoReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据指定的&lt;code&gt;subKey&lt;/code&gt;推送消息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) MPushMsg(arg *proto.MPushMsgArg, reply *proto.MPushMsgReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据指定的&lt;code&gt;subKey&lt;/code&gt;一次推送多个消息，主要用于&lt;code&gt;群播&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) MPushMsgs(arg *proto.MPushMsgsArg, reply *proto.MPushMsgsReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多播&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) Broadcast(arg *proto.BoardcastArg, reply *proto.NoReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;广播&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) BroadcastRoom(arg *proto.BoardcastRoomArg, reply *proto.NoReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按房间推送&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) Rooms(arg *proto.NoArg, reply *proto.RoomsReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;获取所有房间，包括下线的房间&lt;/p&gt;

&lt;h4 id=&#34;ring&#34;&gt;ring&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/comet-ring.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;图 1-5&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ring&lt;/code&gt;是一个环形对象池，用于管理协议对象-&lt;code&gt;proto&lt;/code&gt;，其内存结构如图所示，&lt;code&gt;rp&lt;/code&gt;为可读游标，wp为可写游标，内存的大小为&lt;code&gt;4&lt;/code&gt;的整数倍。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) Get() (proto *proto.Proto, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;获取一个&lt;code&gt;proto&lt;/code&gt;对象的引用，用于读，不会移动可读游标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) GetAdv()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移动可读游标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) Set() (proto *proto.Proto, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;获取一个&lt;code&gt;proto&lt;/code&gt;对象的引用，用于写，不会移动可写游标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) SetAdv()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移动可写游标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) Reset()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重置&lt;code&gt;pool&lt;/code&gt;对象&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 如果wp移动过快，会影响rp游标指向的数据，如图：
&amp;gt; ```

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/comet-ring-1.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;图 1-6&amp;lt;/center&amp;gt;

当程序运行到第`3`步的时候，`wp`已经又重新超过`rp`的索引了，这时候，第`6`个对象还没被`rp`读取过，但是它的数据已经被修改了，这样即使`rp`读取第6个对象，也是一个`dirty`对象。

#### Signal

信号处理模块，可用于在线加载配置，配置动态加载的信号为`SIGHUP`。

## Job

`Job`负责消费`kafka`消息，然后转发至`comet`。

### 单/多播

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt;多播.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;图 2-1&amp;lt;/center&amp;gt;

### 广播

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt; 广播.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;图 2-2&amp;lt;/center&amp;gt;

### 按房间推送

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt;按房间推送.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;图 2-3&amp;lt;/center&amp;gt;

### 主要逻辑代码分析

#### comet

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt;comet.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;图 3-4&amp;lt;/center&amp;gt;

```go
type CometOptions struct {
	RoutineSize int64 // 每个comet rpc goroutine个数
	RoutineChan int   // 每个协议通道的缓冲大小
}

type Comet struct {
	serverId             int32                      		// comet service id
	rpcClient            *xrpc.Clients              		// rpc连接对象
	pushRoutines         []chan *proto.MPushMsgArg  		// 单/多播信道
	broadcastRoutines    []chan *proto.BoardcastArg      	// 广播信道
	roomRoutines         []chan *proto.BoardcastRoomArg  	// 群播-房播信道
	pushRoutinesNum      int64 								// 单/多播协议信道=》用于循环
	roomRoutinesNum      int64 								// 房播-群播协议信道=》
	broadcastRoutinesNum int64 								// 广播协议信道=》
	options              CometOptions
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) Push(arg *proto.MPushMsgArg) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;循环选择一个&lt;code&gt;MPushMsgArg channel&lt;/code&gt;，将消息推送至该信道&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) BroadcastRoom(arg *proto.BoardcastRoomArg) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按照房间推送，循环选择一个&lt;code&gt;BoardcastRoomArg Channel&lt;/code&gt;，将消息推送至该信道&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) Broadcast(arg *proto.BoardcastArg) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;广播，循环选择一个&lt;code&gt;BoardcastArg Channe&lt;/code&gt;，将消息推送至该信道&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) process(pushChan chan *proto.MPushMsgArg, roomChan chan *proto.BoardcastRoomArg, broadcastChan chan *proto.BoardcastArg)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;IO&lt;/code&gt;复用协程，作为&lt;code&gt;pushChan&lt;/code&gt;，&lt;code&gt;roomChan&lt;/code&gt;，&lt;code&gt;broadcastChan&lt;/code&gt;信道的消费者，消费完后，转发&lt;code&gt;comet service&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;room&#34;&gt;room&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RoomBucket struct {
	roomNum int 
	rooms   map[int32]*Room
	rwLock  sync.RWMutex
	options RoomOptions
	round   *Round
}
type RoomOptions struct {
	BatchNum   int  			//汇总阈值
	SignalTime time.Duration
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;room&lt;/code&gt;模块用于接收&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;push&lt;/code&gt;模块发送的消息，每个&lt;code&gt;room&lt;/code&gt;都有一个协程，其协程的信道缓冲区的大小为&lt;code&gt;RoomOptions.BatchNum&lt;/code&gt;的两倍。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 1、room协程在接收到的消息条数&amp;gt;=BatchNum*2或者timeout时，才会触发转发消息的行为(转发至broadcastRoutines)，即其具有汇总操作。
&amp;gt; 
&amp;gt; 2、房间的消息使用了Libs/bytes.Writer进行汇总缓存。
&amp;gt; ```

#### push/kafka

`push/kafka`模块用于预处理消息，消息从`kafka集群`流出，经过`kafka`模块转发至`push`模块，`push`模块对消息预处理/过滤/分类，然后发至不同的`comet 信道`中，具体使用请参照`Job的`前3章图.

消息的分类：

- `KAFKA_MESSAGE_MULTI`=&amp;gt;多播

- `KAFKA_MESSAGE_BROADCAST`=&amp;gt;广播

- `KAFKA_MESSAGE_BROADCAST_ROOM`=&amp;gt;群播/房播

#### Round/RoundOptions

时钟管理器



## Logic

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/logic-router.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;图 3-5&amp;lt;/center&amp;gt;

`Logic`是`goim`是主要业务处理模块，负责的内容有：

- 注册/注销
- 验证
- 消息`Push`代理

### 协议

#### Push协议

[linked](https://github.com/Terry-Mao/goim/blob/master/doc/push.md)

其中`ensure`参数是额外的参数，用于控制消息是否必达，为布偶值。

#### 其他http协议

##### 删除comet service

| 接口名                                | URL             | 访问方式 |
| ------------------------------------- | --------------- | -------- |
| 删除`comet service`                   | `/1/server/del` | `POST`   |
| 获取所有`comet service`或者`room`信息 | `/1/count`      | `POST`   |

请求例子：

- `/1/server/del`

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl -XPOST &amp;ldquo;&lt;a href=&#34;http://127.0.0.1:7172/1/server/del?server=1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://127.0.0.1:7172/1/server/del?server=1&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
- `/1/count`

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl -XPOST &amp;ldquo;&lt;a href=&#34;http://127.0.0.1:7172/1/count?type=room&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://127.0.0.1:7172/1/count?type=room&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
### 主要逻辑代码分析

#### Auth

```go
type Auther interface {
	Auth(token string) (userId int64, roomId int32)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;用户验证模块&lt;/p&gt;

&lt;h4 id=&#34;router&#34;&gt;router&lt;/h4&gt;

&lt;p&gt;负责与&lt;code&gt;Router Service&lt;/code&gt;交互，多个&lt;code&gt;Router Service&lt;/code&gt;采用的是一致性&lt;code&gt;hash&lt;/code&gt;算法，&lt;code&gt;hash&lt;/code&gt;的输入为&lt;code&gt;Router Serviceid&lt;/code&gt;，默认所有的&lt;code&gt;Router Service&lt;/code&gt;权值是一样的，如果需要控制不同的权值，可以在配置&lt;code&gt;router service&lt;/code&gt;的时候加多个端口实例或者同一个节点配置成多个&lt;code&gt;serviceid&lt;/code&gt;标签。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 一致性hash没有实现动态扩容，即没有自动平衡，所以不能够动态改变Router service映射配置，且每个Logic节点的Router Service配置项需保持一致。
&amp;gt; ```

- func getRouterByServer(server string) (*xrpc.Clients, error)

通过`router serverid`获取对应的`router service client`

- func getRouterByUID(userID int64) (*xrpc.Clients, error)

通过`userID`获取`router service client`

- func getRouterNode(userID int64) string

通过`userID`获取到`Router 节点`

- func connect(userID int64, server, roomId int32) (seq int32, err error)

注册、验证用户，返回一个自增序列号(`cometServiceID_incr`)

- func disconnect(userID int64, seq, roomId int32) (has bool, err error)

注销一个用户

- func delServer(server int32) (err error)

下线一个`comet service`

- func allRoomCount(client *xrpc.Clients) (counter map[int32]int32, err error

获取所有房间个数

- func allServerCount(client *xrpc.Clients) (counter map[int32]int32, err error)

获取所有`comet-service`

- func genSubKey(userId int64) (res map[int32][]string)

通过用户`ID`生成`subKey`；同一个用户可以同时多处登陆或者同处多实例登陆，它们都会被同等对待。

`subKey生成代码：`

```go
func encode(userId int64, seq int32) string {
	return fmt.Sprintf(&amp;quot;%d_%d&amp;quot;, userId, seq)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;seq&lt;/code&gt;为每个&lt;code&gt;comet service&lt;/code&gt;的自增长序索引，假设&lt;code&gt;comet service 1&lt;/code&gt;接受到一个用户请求，用户的&lt;code&gt;ID&lt;/code&gt;为&lt;code&gt;10&lt;/code&gt;，而此时&lt;code&gt;Router buckets&lt;/code&gt;的&lt;code&gt;seqIdx&lt;/code&gt;为&lt;code&gt;9&lt;/code&gt;，则&lt;code&gt;subKey = 10_9&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func getSubKeys(res chan *proto.MGetReply, serverId string, userIds []int64) | func genSubKeys(userIds []int64) (divide map[int32][]string)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并行获取多个用户信息，返回值为&lt;code&gt;map[comet.serverId][]subkey&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;rpc-1&#34;&gt;rpc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RPC
type RPC struct {
	auther Auther
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LogicService&lt;/code&gt;用于心跳的检测以及客户端的注册/注销。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *RPC) Connect(arg *proto.ConnArg, reply *proto.ConnReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注册&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *RPC) Disconnect(arg *proto.DisconnArg, reply *proto.DisconnReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注销&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; goim不支持离线消息，如果需要支持离线消息的推送，应hook该模块，实现离线消息推送逻辑
&amp;gt; ```

## Router

### 主要逻辑代码分析

#### session

```go
type Session struct {
	seq     int32                     // 序列号自增标记器
	servers map[int32]int32           // seq:server
	rooms   map[int32]map[int32]int32 // roomid:seq:server with specified room id
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;客户端会话信息管理，以用户&lt;code&gt;id&lt;/code&gt;为单位，即每个用户有且拥有一个&lt;code&gt;session&lt;/code&gt;，&lt;code&gt;session&lt;/code&gt;包含了用户每个连接的&lt;code&gt;comet service&lt;/code&gt;信息，以及每个连接所属的&lt;code&gt;roomid&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Put(server int32) (seq int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关联一个&lt;code&gt;subKey&lt;/code&gt;和&lt;code&gt;session&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) PutRoom(server int32, roomId int32) (seq int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关联一个&lt;code&gt;subKey&lt;/code&gt;到&lt;code&gt;comet servicey&lt;/code&gt; 以及&lt;code&gt;room&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Servers() (seqs []int32, servers []int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回&lt;code&gt;session&lt;/code&gt;关联的所有&lt;code&gt;comet service&lt;/code&gt;信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Del(seq int32) (has, empty bool, server int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;删除指定的&lt;code&gt;subKey&lt;/code&gt;所关联的&lt;code&gt;Session.Servers&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) DelRoom(seq int32, roomId int32) (has, empty bool, server int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;删除指定的&lt;code&gt;subKey&lt;/code&gt;、&lt;code&gt;roomid&lt;/code&gt;所关联的&lt;code&gt;Session.rooms&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Count() int&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回&lt;code&gt;session&lt;/code&gt;所关联的所有&lt;code&gt;comet service&lt;/code&gt;信息&lt;/p&gt;

&lt;h4 id=&#34;bucket-1&#34;&gt;bucket&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Bucket struct {
	bLock             sync.RWMutex
	server            int                       // session server map init num
	session           int                       // bucket session init num
	sessions          map[int64]*Session        // userid-&amp;gt;sessions, 一个可能同时多处登陆
	roomCounter       map[int32]int32           // roomid-&amp;gt;count
	serverCounter     map[int32]int32           // server-&amp;gt;count
	userServerCounter map[int32]map[int64]int32 // serverid-&amp;gt;userid count
	cleaner           *Cleaner                  // bucket map cleaner
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) counter(userId int64, server int32, roomId int32, incr bool)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;增加一个用户或者减少一个用户&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) Put(userId int64, server int32, roomId int32) (seq int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关联&lt;code&gt;channel(session)&lt;/code&gt;到指定的用户&lt;code&gt;id&lt;/code&gt;，&lt;code&gt;comet id&lt;/code&gt;以及&lt;code&gt;room id&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) Get(userId int64) (seqs []int32, servers []int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;指定用户的&lt;code&gt;session&lt;/code&gt;信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) GetAll() (userIds []int64, seqs [][]int32, servers [][]int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回该&lt;code&gt;bucket&lt;/code&gt;的所有用户、&lt;code&gt;subKey&lt;/code&gt;、&lt;code&gt;comet&lt;/code&gt;信息&lt;/p&gt;

&lt;p&gt;其他函数省略&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;cleaner&#34;&gt;cleaner&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type CleanData struct {
	Key        int64
	expireTime time.Time
	next, prev *CleanData
}

type Cleaner struct {
	cLock sync.Mutex
	size  int
	root  CleanData
	maps  map[int64]*CleanData
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lru&lt;/code&gt;对象管理器，只负责管理，不负责触发&lt;code&gt;GC&lt;/code&gt;，&lt;code&gt;GC&lt;/code&gt;交给&lt;code&gt;Runtime&lt;/code&gt;处理。&lt;/p&gt;

&lt;p&gt;主要应用于客户端的&lt;code&gt;session&lt;/code&gt;管理，定时处理掉一些过期的&lt;code&gt;session&lt;/code&gt;对象。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1、数据结构使用map和双向列表，map用于快速检索；&lt;/p&gt;

&lt;p&gt;2、双向链表用于快速剔除数据：因为从map中剔除数据，map的结构会实时改变，每剔除一个都得再次从起点开始遍历map，而使用链表不用重新遍历，时间复杂度为&lt;code&gt;O(logN)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;libs&#34;&gt;Libs&lt;/h2&gt;

&lt;h3 id=&#34;缓冲io-bufio&#34;&gt;缓冲io-bufio&lt;/h3&gt;

&lt;h4 id=&#34;reader&#34;&gt;Reader&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Reader struct {
  	buf []byte
  	rd	io.Reader
  	r, w int
  	err error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt;是一个具有缓存的可读&lt;code&gt;IO&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bufio-reader.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;图 5-1&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;主要函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Reset(r io.Reader)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重置&lt;code&gt;IO&lt;/code&gt;，可读游标重置为&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) ResetBuffer(r io.Reader, buf []byte)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重置&lt;code&gt;IO&lt;/code&gt;，可读游标重置为&lt;code&gt;0&lt;/code&gt;，且&lt;code&gt;b.buf&lt;/code&gt;变为&lt;code&gt;buf&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Peek(n int) ([]byte, error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;窥探缓存的&lt;code&gt;n&lt;/code&gt;个字节，可读游标维持不变，可写游标可能会改变;&lt;/p&gt;

&lt;p&gt;如果可窥探的数据少于&lt;code&gt;n&lt;/code&gt;，则调用&lt;code&gt;b.fill()&lt;/code&gt;尝试读取远端数据用于填充&lt;code&gt;b.buf&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Pop(n int) ([]byte, error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回&lt;code&gt;[b.r:b.r+n]&lt;/code&gt;处的数据，该函数会调用&lt;code&gt;b.Peek&lt;/code&gt;，而且会改变可读游标和科协游标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Discard(n int) (discarded int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;丢弃&lt;code&gt;n&lt;/code&gt;个数据；如果缓冲区的可读数据小于&lt;code&gt;n&lt;/code&gt;，则一致调用&lt;code&gt;b.fill()&lt;/code&gt;尝试读取远程的数据，直到&lt;code&gt;b.buf&lt;/code&gt;的可读缓冲区大于或者等于&lt;code&gt;n&lt;/code&gt;或者出现网络异常为止&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Read(p []byte) (n int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读取缓冲区数据；&lt;/p&gt;

&lt;p&gt;如果缓冲区为空，为了提高效率，避免应用层的数据拷贝（&lt;code&gt;kernel net stack=&amp;gt;b.buf==&amp;gt;p&lt;/code&gt;），直接将&lt;code&gt;kernel net stack&lt;/code&gt;拷贝到&lt;code&gt;p []byte&lt;/code&gt;，并且调用&lt;code&gt;f.fill()&lt;/code&gt;整理缓冲区.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) fill()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bufio-reader-fill.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;图 5-2&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;读取远程新块数据到本地缓冲区的&lt;code&gt;b.buf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;会有数据的移动，如&lt;code&gt;图 5-2&lt;/code&gt;所示。&lt;/p&gt;

&lt;h4 id=&#34;writer&#34;&gt;Writer&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Writer struct {
	err error
	buf []byte
	n   int
	wr  io.Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Writer&lt;/code&gt;是一个具有缓存的可写&lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Reset(w io.Writer) {&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重置&lt;code&gt;IO&lt;/code&gt;，可写游标重置为&lt;code&gt;0&lt;/code&gt;，句柄变为&lt;code&gt;w&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) ResetBuffer(w io.Writer, buf []byte)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重置&lt;code&gt;IO&lt;/code&gt;，可写游标重置为&lt;code&gt;0&lt;/code&gt;，句柄变为&lt;code&gt;w&lt;/code&gt;，缓冲区变为&lt;code&gt;buf&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) flush() error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;刷新缓冲区，将本地缓冲区的数据发送至内核网络栈；&lt;/p&gt;

&lt;p&gt;游标被重置（不一定会被重置为0，可能为其他值，因为本地缓冲的数据大于内核可写缓冲区，这时还会造成数据的搬迁）。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bufio-writer.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Available() int&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可写字节数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Buffered()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;已写缓冲大小&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Write(p []byte) (nn int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将&lt;code&gt;p []byte&lt;/code&gt;写到缓冲区或者直接写到网络内核栈（此时缓冲区已满），可能造成可写游标的移动&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) WriteRaw(p []byte) (nn int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和b.Write()类似&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Peek(n int) ([]byte, error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;窥探可写缓冲区剩余值，如果可写缓冲区的剩余值小于&lt;code&gt;n&lt;/code&gt;，会调用&lt;code&gt;flush&lt;/code&gt;，可写游标相应可能会改变&lt;/p&gt;

&lt;h4 id=&#34;timer&#34;&gt;timer&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;timer&lt;/code&gt;是一个最小堆算法实现的时钟对象，串行执行时钟任务，所以时钟任务应该尽量小，&lt;code&gt;timer&lt;/code&gt;不适合太耗时的任务，当然用户可以控制时钟任务的并发。&lt;/p&gt;

&lt;h3 id=&#34;bytes&#34;&gt;bytes&lt;/h3&gt;

&lt;h4 id=&#34;pool&#34;&gt;Pool&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Buffer struct {
	buf  []byte
	next *Buffer // next free buffer
}
type Pool struct {
	lock sync.Mutex
	free *Buffer
	max  int
	num  int
	size int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pool&lt;/code&gt;内存组织如下，&lt;code&gt;pool&lt;/code&gt;是一个链式存储的&lt;code&gt;栈&lt;/code&gt;，数据从栈顶出，同时数据也从栈顶回收。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bytes.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (p *Pool) Get() (b *Buffer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;获取一个缓冲区&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (p *Pool) Put(b *Buffer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;归还一个缓冲区&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (p *Pool) grow()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重置&lt;code&gt;Pool&lt;/code&gt;对象&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; pool 是一个不限大小的内存池，如果栈没有数据了，那么pool会调用glow()重新生成数据，所以最后可能造成的内存架构如下图所示
&amp;gt; ```

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/bytes-2.png)&amp;lt;/center&amp;gt;

如果租借的速度大于归还的速度，会造成内存的溢出。

#### Writer

```go
type Writer struct {
	n   int 	//游标
	buf []byte
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;writer&lt;/code&gt;是一个具有缓冲的可写&lt;code&gt;IO&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Size()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缓冲区的大小&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Reset()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重置缓冲区，游标重置为&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Buffer() []byte&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回缓冲区的内容&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Peek(n int) []byte&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;窥探缓冲区的&lt;code&gt;n&lt;/code&gt;个字节，如果缓冲区的剩余空间小于&lt;code&gt;n&lt;/code&gt;，则会调用&lt;code&gt;w.grow()&lt;/code&gt;自增长数据缓冲区，游标会移动&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) grow(n int)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按照&lt;code&gt;2&lt;/code&gt;倍的大小增长缓冲区，会发生数据的移动&lt;/p&gt;

&lt;h3 id=&#34;net&#34;&gt;net&lt;/h3&gt;

&lt;h4 id=&#34;xrpc&#34;&gt;xrpc&lt;/h4&gt;

&lt;p&gt;根据原生的&lt;code&gt;rpc&lt;/code&gt;封装的，其调用采用异步的方式，具有重连功能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xrpc&lt;/code&gt;并没有做负载均衡的工作，只是简单做一下容灾而已，相对来时不是很灵活，用户可以稍微修改一下，就支持负载均衡了。&lt;/p&gt;

&lt;p&gt;同时&lt;code&gt;xrpc&lt;/code&gt;也没有在代码层面上实现&lt;code&gt;[host:por]&lt;/code&gt;连接池，即同一个&lt;code&gt;[host:port]&lt;/code&gt;配置只会有一个&lt;code&gt;rpc&lt;/code&gt;长链接，除非增加多配置。&lt;/p&gt;

&lt;h4 id=&#34;proto&#34;&gt;proto&lt;/h4&gt;

&lt;p&gt;主要的&lt;code&gt;rpc&lt;/code&gt;协议说明：&lt;/p&gt;

&lt;h5 id=&#34;job&#34;&gt;job&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type KafkaMsg struct {
	OP       string   `json:&amp;quot;op&amp;quot;` 				//操作类型
	RoomId   int32    `json:&amp;quot;roomid,omitempty&amp;quot;` //房间号
	ServerId int32    `json:&amp;quot;server,omitempty&amp;quot;`	//comet id
	SubKeys  []string `json:&amp;quot;subkeys,omitempty&amp;quot;`
	Msg      []byte   `json:&amp;quot;msg&amp;quot;`
	Ensure   bool     `json:&amp;quot;ensure,omitempty&amp;quot;`	//是否强推送(伪强推)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;logic&#34;&gt;logic&lt;/h5&gt;

&lt;p&gt;客户端上线：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 用于comet发送客户端的校验信息
type ConnArg struct {
	Token  string // Token
	Server int32  // comet id
}

// logic 校验应答
type ConnReply struct {
	Key    string 	// subKey
	RoomId int32	// 房间号
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端下线：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 用于comet发送客户端连接下线
type DisconnArg struct {
	Key    string	// subKey
	RoomId int32	// 房间号
}
// 应答客户端下线
type DisconnReply struct {
	Has bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;comet-1&#34;&gt;comet&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Push RPC&lt;/code&gt;模块&lt;/p&gt;

&lt;p&gt;心跳：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type NoArg struct {
}

type NoReply struct {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Job----&amp;gt;comet&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 单播
type PushMsgArg struct {
	Key string	//subKey
	P   Proto
}
type NoReply struct {
}

// 把某条消息推送给多个subKey
type MPushMsgArg struct {
	Keys []string
	P    Proto
}

type MPushMsgReply struct {
	Index int32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// 多播
type MPushMsgsArg struct {
    PMArgs []*PushMsgArg
}&lt;/p&gt;

&lt;p&gt;type MPushMsgsReply struct {
    Index int32
}&lt;/p&gt;

&lt;p&gt;// 广播
type BoardcastArg struct {
    P Proto
}&lt;/p&gt;

&lt;p&gt;// 吧某条消息推送给某个房间的所有channels
type BoardcastRoomArg struct {
    RoomId int32
    P      Proto
}&lt;/p&gt;

&lt;p&gt;type RoomsReply struct {
    RoomIds map[int32]struct{}
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##### router

增加用户：

​```go
type PutArg struct {
	UserId int64
	Server int32
	RoomId int32
}
type PutReply struct {
	Seq int32	// 序列号
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除用户：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type DelArg struct {
	UserId int64
	Seq    int32
	RoomId int32
}

type DelReply struct {
	Has bool	//	是否存在目标用户
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 剔除comet server
type DelServerArg struct {
	Server int32
}

// 获取用户信息
type GetArg struct {
	UserId int64
}

// 获取Router的所有信息
type GetReply struct {
	Seqs    []int32
	Servers []int32
}

type GetAllReply struct {
	UserIds  []int64
	Sessions []*GetReply
}

// 获取多个用户信息
type MGetArg struct {
	UserIds []int64
}

type MGetReply struct {
	UserIds  []int64
	Sessions []*GetReply
}

// 返回所有连接个数
type CountReply struct {
	Count int32
}

// 获取特定房间的所有连接
type RoomCountArg struct {
	RoomId int32
}

type RoomCountReply struct {
	Count int32
}

// 获取所有房间的连接个数
type AllRoomCountReply struct {
	Counter map[int32]int32
}

// 获取所有的comet server个数
type AllServerCountReply struct {
	Counter map[int32]int32
}

// 获取所有的用户个数
type UserCountArg struct {
	UserId int64
}

type UserCountReply struct {
	Count int32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;推送协议&#34;&gt;推送协议&lt;/h5&gt;

&lt;p&gt;参照官网&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Riak Core 原理分析-1</title>
      <link>https://laohanlinux.github.io/2016/06/13/riak-core-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-1/</link>
      <pubDate>Mon, 13 Jun 2016 23:38:23 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/06/13/riak-core-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>使用Golang语言实现一个简单的Bitcask引擎的文件存储系统</title>
      <link>https://laohanlinux.github.io/2016/04/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84bitcask%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 25 Apr 2016 23:45:22 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84bitcask%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid>
      <description>

&lt;p&gt;&lt;code&gt;bitcask&lt;/code&gt;是&lt;code&gt;bashro&lt;/code&gt;的设计的一个底层存储引擎，主要应用于&lt;code&gt;Riak&lt;/code&gt;产品中（&lt;code&gt;ps&lt;/code&gt;:国内的&lt;code&gt;beansdb&lt;/code&gt;的底层存储引擎也是使用&lt;code&gt;bitcask&lt;/code&gt;，分布式上也是使用&lt;code&gt;dynamo&lt;/code&gt;，并且他们也根据自己的实际应用做了相应的优化），其设计简单易懂，算法也是很简明的算法。其存储对象类型是&lt;code&gt;key/value&lt;/code&gt;类型。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/basho/bitcask&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;riak bitcask github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/laohanlinux/bitcask&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go bitcask github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://image.haha.mx/2013/04/03/middle/803545_68a109882550ec3556a2b19e277ddb10_1364992759.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;code&gt;talk is cheap, show me the code!&lt;/code&gt; &lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;设计模型以及特点&#34;&gt;设计模型以及特点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;所有的&lt;code&gt;key&lt;/code&gt;都存储于内存中；所有的&lt;code&gt;value&lt;/code&gt;都存储于磁盘中&lt;/li&gt;
&lt;li&gt;以追加的方式写磁盘，即写操作是有序的，这样可以减少磁磁盘的寻道时间，是一种高吞吐量的写入方案，在更新数据时，也是把新数据追加到文件的后面，然后更新一下数据的文件指针映射即可&lt;/li&gt;
&lt;li&gt;读取数据时，通过数据的指针以及偏移量即可，时间复杂度为&lt;code&gt;O(1)&lt;/code&gt;，因为所有&lt;code&gt;key&lt;/code&gt;都是存储于内存中，查找数据时，不用检索磁盘文件，这大大减少了检索时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bitcask&lt;/code&gt;有一个合并的时间窗口，当旧数据站到一定比例时，会触发合并操作，同时为了设计更简单，会把旧数据重新追加到可写文件中(&lt;code&gt;riak&lt;/code&gt;里面的合并策略跟多，具体的合并策略可以去看它的源码)(&lt;code&gt;ps&lt;/code&gt;:虽然自己实现了这个操作，但是还在测试阶段，应该有潜在的&lt;code&gt;Debug&lt;/code&gt;,如果哪位有对这个项目有兴起，可以修复一下)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;具体的组件设计图&#34;&gt;具体的组件设计图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bitcask&lt;/code&gt;的数据文件分为&lt;strong&gt;只读文件&lt;/strong&gt;和唯一&lt;strong&gt;一个读写文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/bitcask-1.png&#34; alt=&#34;图-1&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;为了加快索引的重建速度，每个数据文件对应一个&lt;code&gt;hint&lt;/code&gt;文件，如：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/bitcask-2.png&#34; alt=&#34;图-2&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;文件的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;crc32(4byte)|tStamp(4byte)|ksz(4byte)|valueSz(4byte)|key|value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样通过&lt;code&gt;key&lt;/code&gt;的大小和&lt;code&gt;value&lt;/code&gt;的大小就可以找到&lt;code&gt;key&lt;/code&gt;的位置和&lt;code&gt;value&lt;/code&gt;的文件，但是如果&lt;code&gt;bitcask&lt;/code&gt;重启后，直接扫描&lt;code&gt;data&lt;/code&gt;文件来建立索引是一件非常耗时的工作，这时候&lt;code&gt;hint&lt;/code&gt;文件就派上场了，&lt;code&gt;hint&lt;/code&gt;文件格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tstamp(4byte)|ksz(4byte)|valuesz(4byte)|valuePos(8byte)|key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在可以跳过&lt;code&gt;value&lt;/code&gt;的扫描，扫描速度自然就起来了，通过&lt;code&gt;valuePos&lt;/code&gt;就可以直接找到文件的内容。&lt;/p&gt;

&lt;h3 id=&#34;数据结构的设计&#34;&gt;数据结构的设计&lt;/h3&gt;

&lt;h4 id=&#34;文件映射的结构体&#34;&gt;文件映射的结构体&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type BFile struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BFile 可写文件信息 1: datafile and hint file
type BFile struct {
	// fp is the writeable file
	fp          *os.File
	fileID      uint32
	writeOffset uint64
	// hintFp is the hint file
	hintFp *os.File
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fp&lt;/code&gt;指向&lt;code&gt;Active data file&lt;/code&gt;， &lt;code&gt;fileID&lt;/code&gt;表示&lt;code&gt;Active data file&lt;/code&gt;的文件名，&lt;code&gt;hintFp&lt;/code&gt;表示&lt;code&gt;Active hint file&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type BFiles struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BFiles ...
type BFiles struct {
	bfs    map[uint32]*BFile
	rwLock *sync.RWMutex
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bfs&lt;/code&gt;每一项表示一个文件索引项，直接使用&lt;code&gt;map&lt;/code&gt;来存储不是一个高效的方法，以后再优化吧&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;key-value-结构体&#34;&gt;&lt;code&gt;key/value&lt;/code&gt;结构体&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type entry struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type entry struct {
	fileID      uint32 // file id
	valueSz     uint32 // value size in data block
	valueOffset uint64 // value offset in data block
	timeStamp   uint32 // file access time spot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该结是&lt;code&gt;hint&lt;/code&gt;文件的映射，&lt;code&gt;fileID&lt;/code&gt;为&lt;code&gt;data&lt;/code&gt;的文件名，&lt;code&gt;valueSz&lt;/code&gt;表示值的大小，&lt;code&gt;valueOffset&lt;/code&gt;表示&lt;code&gt;value&lt;/code&gt;在&lt;code&gt;data&lt;/code&gt;文件的索引位置，&lt;code&gt;timeStamp&lt;/code&gt;表示&lt;code&gt;value&lt;/code&gt;的存储时间（这个存储时间是会变的，因为在&lt;code&gt;merge&lt;/code&gt;的时候，旧的数据会重新追加到&lt;code&gt;Active&lt;/code&gt;文件中，这样这些旧的数据会重新洗牌，变成新的数据）.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type KeyDirs struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// KeyDirs ...
type KeyDirs struct {
	entrys map[string]*entry
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个结构是主要的占内存的地方，因为所有&lt;code&gt;key&lt;/code&gt;都存储于此，这个结构体由&lt;code&gt;hint&lt;/code&gt;文件构建的.&lt;/p&gt;

&lt;p&gt;这个结构体也是后续需要优化的地方，比如：&lt;code&gt;fileID&lt;/code&gt;很多是相同的，可以将他们存储在一个数组中，&lt;code&gt;entry&lt;/code&gt;只要存储数组的&lt;code&gt;fileID&lt;/code&gt;索引即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type BitCask struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BitCask ...
type BitCask struct {
	Opts      *Options      // opts for bitcask
	oldFile   *BFiles       // hint file, data file
	lockFile  *os.File      // lock file with process
	keyDirs   *KeyDirs      // key/value hashMap, building with hint file
	dirFile   string        // bitcask storage  root dir
	writeFile *BFile        // writeable file
	rwLock    *sync.RWMutex // rwlocker for bitcask Get and put Operation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bitcask&lt;/code&gt;是最重要的结构体，是程序的入口，&lt;code&gt;oldFile&lt;/code&gt;是只读文件的索引；&lt;code&gt;writeFile&lt;/code&gt;是&lt;code&gt;Active file&lt;/code&gt;的索引；&lt;code&gt;keyDirs&lt;/code&gt;是&lt;code&gt;key&lt;/code&gt;的索引。&lt;/p&gt;

&lt;h3 id=&#34;关于merge&#34;&gt;关于Merge&lt;/h3&gt;

&lt;p&gt;为了节省空间，&lt;code&gt;bitcask&lt;/code&gt;采用&lt;code&gt;merge&lt;/code&gt;的方式剔除脏数据，&lt;code&gt;merge&lt;/code&gt;期间会影响到服务的访问，&lt;code&gt;merge&lt;/code&gt;是一件消耗&lt;code&gt;disk io&lt;/code&gt;时间，用户应该错开&lt;code&gt;merge&lt;/code&gt;的&lt;code&gt;io&lt;/code&gt;高峰期.其中&lt;code&gt;merge&lt;/code&gt;的触发也有很多种（触发不一定就会执行），如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定时策略&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户自定义触发&lt;code&gt;merge&lt;/code&gt;的时间
- 间隔策略
每隔一定的时间触发&lt;code&gt;merge&lt;/code&gt;事件&lt;/p&gt;

&lt;p&gt;其他等等&amp;hellip;..&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;merge&lt;/code&gt;时间触发时，&lt;code&gt;bitcask&lt;/code&gt;就会根据用户自定的策略去决定是否执行&lt;code&gt;merge&lt;/code&gt;操作，&lt;code&gt;merge&lt;/code&gt;执行策略如：
- 定时策略
在用户定义的时间内执行&lt;code&gt;merge&lt;/code&gt;操作，该操作会损耗服务的能力，用户应该避免高峰期，在低峰期时才执行该操作
- 容量策略
当胀数据达到一定的比例或者大小时，执行&lt;code&gt;merge&lt;/code&gt;操作&lt;/p&gt;

&lt;p&gt;其他的等等&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;如何实现一个简单的-merge&#34;&gt;如何实现一个简单的&lt;code&gt;Merge&lt;/code&gt;:&lt;/h3&gt;

&lt;p&gt;为简化设计，便于实现，&lt;code&gt;merge&lt;/code&gt;操作把需要的&lt;code&gt;old file&lt;/code&gt;文件重新扫描，如果记录是老的或者被删除了得，就过滤掉；需要保留的就按正常的操作重新插入到&lt;code&gt;active file&lt;/code&gt;文件中。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/bitcask-3.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;ps:本人只实现了一个简单的merge操作，由于比较忙，优化和策略方面还没全面&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&#34;todo-list&#34;&gt;TODO LIST&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;优化hashmap&lt;/li&gt;
&lt;li&gt;增加多种合并策略&lt;/li&gt;
&lt;li&gt;减少锁的颗粒度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;简单的操作&#34;&gt;简单的操作&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
        &amp;quot;os&amp;quot;

        &amp;quot;github.com/laohanlinux/bitcask&amp;quot;
        &amp;quot;github.com/laohanlinux/go-logger/logger&amp;quot;
)

func main() {
        os.RemoveAll(&amp;quot;exampleBitcaskDir&amp;quot;)
        bc, err := bitcask.Open(&amp;quot;exampleBitcaskDir&amp;quot;, nil)
        if err != nil {
                logger.Fatal(err)
        }
        defer bc.Close()
        k1 := []byte(&amp;quot;xiaoMing&amp;quot;)
        v1 := []byte(&amp;quot;毕业于新东方推土机学院&amp;quot;)

        k2 := []byte(&amp;quot;zhanSan&amp;quot;)
        v2 := []byte(&amp;quot;毕业于新东方厨师学院&amp;quot;)

        bc.Put(k1, v1)
        bc.Put(k2, v2)

        v1, _ = bc.Get(k1)
        v2, _ = bc.Get(k2)
        logger.Info(string(k1), string(v1))
        logger.Info(string(k2), string(v2))
        // override
        v2 = []byte(&amp;quot;毕业于新东方美容美发学院&amp;quot;)
        bc.Put(k2, v2)
        v2, _ = bc.Get(k2)
        logger.Info(string(k2), string(v2))

        bc.Del(k1)
        bc.Del(k2)
        logger.Info(&amp;quot;毕业后的数据库：&amp;quot;)
        v1, e := bc.Get(k1)
        if e != bitcask.ErrNotFound {
                logger.Info(string(k1), &amp;quot;shoud be:&amp;quot;, bitcask.ErrNotFound)
        } else {
                logger.Info(string(k1), &amp;quot;已经毕业.&amp;quot;)
        }
        v2, e = bc.Get(k2)
        if e != bitcask.ErrNotFound {
                logger.Info(string(k1), &amp;quot;shoud be:&amp;quot;, bitcask.ErrNotFound)
        } else {
                logger.Info(string(k2), &amp;quot;已经毕业.&amp;quot;)
        }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;gt; go run example/bitcask_main.go
2016/05/01 16:22:28 bitcask_main.go:28 [info] xiaoMing毕业于新东方推土机学院
2016/05/01 16:22:28 bitcask_main.go:29 [info] zhanSan毕业于新东方厨师学院
2016/05/01 16:22:28 bitcask_main.go:34 [info] zhanSan毕业于新东方美容美发学院
2016/05/01 16:22:28 bitcask_main.go:38 [info] 毕业后的数据库：
2016/05/01 16:22:28 bitcask_main.go:43 [info] xiaoMing已经毕业.
2016/05/01 16:22:28 bitcask_main.go:49 [info] zhanSan已经毕业.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用raft算法快速构建一个分布式kv系统</title>
      <link>https://laohanlinux.github.io/2016/04/25/%E4%BD%BF%E7%94%A8raft%E7%AE%97%E6%B3%95%E5%BF%AB%E7%86%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84key-value%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 25 Apr 2016 23:44:25 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/25/%E4%BD%BF%E7%94%A8raft%E7%AE%97%E6%B3%95%E5%BF%AB%E7%86%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84key-value%E7%B3%BB%E7%BB%9F/</guid>
      <description>

&lt;p&gt;&lt;code&gt;raft&lt;/code&gt;是一种类似于&lt;code&gt;paoxs&lt;/code&gt;的分布式算法，相对于&lt;code&gt;paxos&lt;/code&gt;算法，&lt;code&gt;raft&lt;/code&gt;更容易于理解以及实现，这也是一种典型的&lt;code&gt;半数协议算法&lt;/code&gt;。这里不详细介绍&lt;code&gt;raft&lt;/code&gt;算法，有兴趣的同学可以参照一下下面的文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://laohanlinux.github.io/2016/03/13/raft%E7%AE%97%E6%B3%95/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;raft Algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本次教程实现的&lt;code&gt;key/value&lt;/code&gt;分布式存储系统的&lt;code&gt;github&lt;/code&gt;地址为：&lt;a href=&#34;https://github.com/laohanlinux/riot&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;riot github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;如何快速使用-hashicorp-raft-搭建一个简单的分布式系统&#34;&gt;如何快速使用&lt;code&gt;hashicorp raft&lt;/code&gt;搭建一个简单的分布式系统&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;raft&lt;/code&gt;算法种类的实现有很多，比较流行的是&lt;code&gt;etcd raft&lt;/code&gt;和&lt;code&gt;hashicorp raft&lt;/code&gt;，这两个都是&lt;code&gt;Go&lt;/code&gt;语言实现的&lt;code&gt;raft&lt;/code&gt;算法库，并且都大量应用到生产环境中，可靠性高。由于本人对&lt;code&gt;hashiro raft&lt;/code&gt;熟悉一点，刚好又对&lt;code&gt;Go&lt;/code&gt;语言有兴趣，所以选择了&lt;code&gt;hashicorp raft&lt;/code&gt;来实现一个简单的分布式&lt;code&gt;key/value&lt;/code&gt;系统.&lt;/p&gt;

&lt;p&gt;系统设计的基本目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;具有容错性&lt;/li&gt;
&lt;li&gt;可以在线自动线性扩展节点&lt;/li&gt;
&lt;li&gt;可以自动增删节点&lt;/li&gt;
&lt;li&gt;具体增删查改操作&lt;/li&gt;
&lt;li&gt;可以适配多种存储引擎&lt;/li&gt;
&lt;li&gt;支持日志/快照重建&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;raft&lt;/code&gt;的请求处理流程：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohan.qiniudn.com/raft/raft_1.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;除此之外还有一个状态机快照的模块。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;hashicorp raft&lt;/code&gt;构建一个分布式存储系统时，主要需要实现的模块有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FSM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;fsm&lt;/code&gt;为&lt;code&gt;raft&lt;/code&gt;的日志状态机&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Snapshot&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Snapshot&lt;/code&gt;为&lt;code&gt;raft&lt;/code&gt;的快照对象&lt;/p&gt;

&lt;p&gt;这两个对象是比较重要的，基本上所有的核心都基于这个两个对象进行构建。&lt;/p&gt;

&lt;h2 id=&#34;riot-的主要组件&#34;&gt;&lt;code&gt;Riot&lt;/code&gt;的主要组件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;模块图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohan.qiniudn.com/raft/riot_2.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;流程图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://7rflb0.com1.z0.glb.clouddn.com/raft/riot_4.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;backend-store&#34;&gt;Backend Store&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotStorage interface {
	Get([]byte) ([]byte, error)
	Set([]byte, []byte) error
	Del([]byte) error
	Rec() &amp;lt;-chan store.Iterm
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Rec()&lt;/code&gt;返回一个只读的信道，该信道用于&lt;code&gt;riot&lt;/code&gt;的快照系统。&lt;/p&gt;

&lt;p&gt;为了便于扩展更多的存储后端，该接口对外开放，有兴趣的朋友只要实现这个接口即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type leveldbStorage struct {
	*leveldb.DB
	c chan Iterm
	l *sync.Mutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Riot&lt;/code&gt;目前采用的存储后端为&lt;code&gt;leveldb&lt;/code&gt;，未了会增加&lt;code&gt;Bitcask&lt;/code&gt;&lt;a href=&#34;https://github.com/laohanlinux/bitcask&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;github-link&lt;/a&gt;存储后端,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Iterm struct {
	Err   error
	Key   []byte
	Value []byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中当&lt;code&gt;iterm.Err = ErrFinished&lt;/code&gt;是表示所有的&lt;code&gt;key&lt;/code&gt;已迭代完毕。&lt;/p&gt;

&lt;p&gt;为了确保一个节点中，同一时间只有一个快照操作，需要操作（&lt;code&gt;raft&lt;/code&gt;本身就也确保了，为了更加保险，建议还是加上锁，毕竟&lt;code&gt;IO&lt;/code&gt;才是这个系统的瓶颈，锁的损耗可以忽略）。&lt;/p&gt;

&lt;p&gt;实现起来还是比较明了的。&lt;/p&gt;

&lt;h3 id=&#34;fsm-snapshot&#34;&gt;FSM、SnapShot&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;raft fsm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type FSM interface {
    
    Apply(*Log) interface{}
  
    Snapshot() (FSMSnapshot, error)
    
    Restore(io.ReadCloser) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户自定义的&lt;code&gt;fsm&lt;/code&gt;只要实现这个接口即可。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;riot fsm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type StorageFSM struct {
	l  *sync.Mutex //互斥锁
	rs RiotStorage //存储后端
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的互斥锁是必须的，因为&lt;code&gt;fsm&lt;/code&gt;的&lt;code&gt;Apply&lt;/code&gt;和&lt;code&gt;Snapshot&lt;/code&gt;不是线程安全的。&lt;/p&gt;

&lt;p&gt;其中业务操作都会应用到&lt;code&gt;Apply&lt;/code&gt;方法中，所以把所有的业务请求都按一定的格式打包即可，然后再解包，根据包的&lt;code&gt;action&lt;/code&gt;类型，做相应的操作。其中操作主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SET&lt;/li&gt;
&lt;li&gt;DEL&lt;/li&gt;
&lt;li&gt;SHARE&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注:&lt;/p&gt;

&lt;p&gt;1、&lt;code&gt;SHARE&lt;/code&gt; 操作类型用于Riot节点通信有的，&lt;code&gt;Riot&lt;/code&gt;集群在启动的时候，他们之间的有些信息需要同步，目前用于同步Leader的RPC地址和端口&lt;/p&gt;

&lt;p&gt;2、为了性能，&lt;code&gt;GET&lt;/code&gt;操作并没有放在Apply方法中，所以GET请求会有404的情况出现，未来会把查询请求是否经过Leader的权限交给用户.&lt;/p&gt;

&lt;p&gt;3、&lt;code&gt;DEL&lt;/code&gt;和&lt;code&gt;SHARE&lt;/code&gt;操作全部交给Leader处理,再由Leader下发到Follower节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Shapshot&lt;/code&gt;方法会在快照时被执行,这时候,只要把所有的&lt;code&gt;key/value&lt;/code&gt;传递给&lt;code&gt;FSMSnapshot&lt;/code&gt;对象即可.在&lt;code&gt;Riot&lt;/code&gt;中.只要传递&lt;code&gt;RiotStorage&lt;/code&gt;对象给&lt;code&gt;StorageSnapshot&lt;/code&gt;即可;&lt;/p&gt;

&lt;p&gt;然后&lt;code&gt;StorageSnapshot.Persist&lt;/code&gt;方法将被调用,&lt;code&gt;StorageSnapshot&lt;/code&gt;只要遍历这些数据,按一定的格式快照到SnapshotSink中即可.&lt;/p&gt;

&lt;p&gt;&lt;center&gt; &lt;img src=&#34;http://7rflb0.com1.z0.glb.clouddn.com/raft/Riot_3.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
当服务重启时,&lt;code&gt;Riot&lt;/code&gt;会检测是否存在快照,如果存在快照,快照的数据就会被&lt;code&gt;StorageFSM.Restore&lt;/code&gt;进行重建;重建完后,&lt;code&gt;raft&lt;/code&gt;会根据日志的索引,重放那些没有被快照到日志条目,这样
所有的数据就恢复完成了.&lt;/p&gt;

&lt;h3 id=&#34;cluster&#34;&gt;Cluster&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Cluster struct {
	Dir         string
	R           *raft.Raft
	Stores      *raft.InmemStore
	FSM         *fsm.StorageFSM
	Snap        raft.SnapshotStore
	Tran        raft.Transport
	PeerStorage raft.PeerStore
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，偷个懒，&lt;code&gt;raft.Raft&lt;/code&gt;访问权限直接暴露出&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PeerStorge&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;节点地址列表的存储对象
- Tran&lt;/p&gt;

&lt;p&gt;节点网络通信对象
- Snap&lt;/p&gt;

&lt;p&gt;日志快照
- FSM&lt;/p&gt;

&lt;p&gt;状态机
- Stores&lt;/p&gt;

&lt;p&gt;日志存储对象&lt;/p&gt;

&lt;h3 id=&#34;rpc&#34;&gt;RPC&lt;/h3&gt;

&lt;p&gt;节点之间的业务通信主要采用&lt;code&gt;gRPC&lt;/code&gt;方式.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pb&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-probuffer&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;

package pb;

service RiotGossip {
    rpc OpRPC(OpRequest) returns (OpReply) {}
}

message OpRequest {
    string op = 1;
    string key= 2;
    bytes value = 3;
}

message OpReply {
    int32 status = 1;
    string msg = 2;
    int32 errCode = 3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OpRequest.op&lt;/code&gt;表示操作类型，其取值为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;CmdGet   = &amp;quot;GET&amp;quot;
CmdSet   = &amp;quot;SET&amp;quot;
CmdDel   = &amp;quot;DEL&amp;quot;
CmdShare = &amp;quot;SHARE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总共4做操作类型，其中&lt;code&gt;SHARE&lt;/code&gt;和&lt;code&gt;CmdGet&lt;/code&gt;这两类型不会影响到日志快照。&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;PS&lt;/code&gt;：&lt;code&gt;OpReply&lt;/code&gt;结构需要调整一下，如果&lt;code&gt;GET&lt;/code&gt;操作增加一致性，起码需要增加一项&lt;code&gt;value&lt;/code&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RiotRPCClient&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotRPCClient struct {
	l    *sync.RWMutex
	conn map[string]*grpc.ClientConn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个服务器到客户端的连接有且只有一个&lt;code&gt;conn&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RiotRPCService&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotRPCService struct{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RiotRPCService&lt;/code&gt;只要实现&lt;code&gt;OpRPC&lt;/code&gt;这个方法即可&lt;/p&gt;

&lt;h3 id=&#34;http-interface&#34;&gt;Http Interface&lt;/h3&gt;

&lt;p&gt;所有的业务入口都是&lt;code&gt;http&lt;/code&gt;请求，包括集群管理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RiotHandler&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotHandler struct{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RiotHandler&lt;/code&gt;更具请求类型来判定操作类型.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AdminHandlerFunc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;AdminHandlerFunc&lt;/code&gt;可以获取到集群的&lt;code&gt;Leader&lt;/code&gt;地址、集群节点地址信息、节点角色信息、节点的&lt;code&gt;rpc&lt;/code&gt;地址信息；还有删除集群中的某一个节点以及把新节点加入到集群中。&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;脚本位于&amp;rsquo;riot/tool&amp;rsquo;目录下：&lt;/p&gt;

&lt;h3 id=&#34;启动集群&#34;&gt;启动集群&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;bash-3.2$ ./cluster1.sh
raft: {127.0.0.1 12000 [127.0.0.1:12000] raft0/raft_peer_storage raft0/raft_snapshot_storage raft0/storage_backend_path raft0/raft_log_path raft0/apply_log_path true}
rpc: {127.0.0.1 32123}
leader rpc: { }
server:{localhost 8080}
raft: {127.0.0.1 12001 [127.0.0.1:12001] raft1/raft_peer_storage raft1/raft_snapshot_storage raft1/storage_backend_path raft1/raft_log_path raft1/apply_log_path false}
rpc: {127.0.0.1 32124}
leader rpc: { }
server:{localhost 8081}
2016/05/02 23:35:11 admin_handler.go:124 [info] The Leader Name is :127.0.0.1:12000
2016/05/02 23:35:11 admin_handler.go:130 [debug] 127.0.0.1:12001will join the cluster, leader is :127.0.0.1:12000
2016/05/02 23:35:11 [DEBUG] raft-net: 127.0.0.1:12001 accepted connection from: 127.0.0.1:61792
2016/05/02 23:35:11 riot.go:147 [error] 127.0.0.1:12000timed out enqueuing operation
2016/05/02 23:35:11 riot.go:124 [info] {&amp;lt;nil&amp;gt; 0 0.0030684640000000003 {0 0 &amp;lt;nil&amp;gt;}}
2016/05/02 23:35:11 [DEBUG] raft-net: 127.0.0.1:12001 accepted connection from: 127.0.0.1:61793
raft: {127.0.0.1 12002 [127.0.0.1:12002] raft2/raft_peer_storage raft2/raft_snapshot_storage raft2/storage_backend_path raft2/raft_log_path raft2/apply_log_path false}
rpc: {127.0.0.1 32125}
leader rpc: { }
server:{localhost 8082}
2016/05/02 23:35:13 admin_handler.go:124 [info] The Leader Name is :127.0.0.1:12000
2016/05/02 23:35:13 admin_handler.go:130 [debug] 127.0.0.1:12002will join the cluster, leader is :127.0.0.1:12000
2016/05/02 23:35:13 [DEBUG] raft-net: 127.0.0.1:12002 accepted connection from: 127.0.0.1:61797
2016/05/02 23:35:13 riot.go:124 [info] {&amp;lt;nil&amp;gt; 0 0.004264005 {0 0 &amp;lt;nil&amp;gt;}}
2016/05/02 23:35:13 [DEBUG] raft-net: 127.0.0.1:12002 accepted connection from: 127.0.0.1:61798
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看集群信息&#34;&gt;查看集群信息&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  &amp;quot;http://localhost:8080/admin/status&amp;quot;
{
  &amp;quot;results&amp;quot;: &amp;quot;Leader&amp;quot;,
  &amp;quot;error&amp;quot;: 0,
  &amp;quot;time&amp;quot;: 3.9520000000000004e-06
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  &amp;quot;http://localhost:8080/admin/peer&amp;quot;
{
  &amp;quot;results&amp;quot;: [
    &amp;quot;127.0.0.1:12002&amp;quot;,
    &amp;quot;127.0.0.1:12000&amp;quot;,
    &amp;quot;127.0.0.1:12001&amp;quot;
  ],
  &amp;quot;error&amp;quot;: 0,
  &amp;quot;time&amp;quot;: 0.017415839000000002
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  &amp;quot;http://localhost:8080/admin/status&amp;quot;
{
  &amp;quot;results&amp;quot;: &amp;quot;Leader&amp;quot;,
  &amp;quot;error&amp;quot;: 0,
  &amp;quot;time&amp;quot;: 2.7490000000000003e-06
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SET&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl http://localhost:8080/riot\?key\=a -d &#39;1024&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl http://localhost:8081/riot\?key\=a
1024%
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DEL&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl -XDELETE http://localhost:8082/riot\?key\=a
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  http://localhost:8082/riot\?key\=a
{&amp;quot;errCode&amp;quot;:40004,&amp;quot;msg&amp;quot;:&amp;quot;not found&amp;quot;}%
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;增加快照的压缩算法,提高压缩效率&lt;/li&gt;
&lt;li&gt;增加跟多的监控信息&lt;/li&gt;
&lt;li&gt;增加多种后端存储引擎的支持&lt;/li&gt;
&lt;li&gt;优化代码结构&lt;/li&gt;
&lt;li&gt;重新设计&lt;code&gt;http api&lt;/code&gt;，新的&lt;code&gt;api&lt;/code&gt;为&lt;code&gt;REST&lt;/code&gt;风格&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>erlang学习笔记</title>
      <link>https://laohanlinux.github.io/2016/04/25/erlang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 25 Apr 2016 00:15:14 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/25/erlang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h2 id=&#34;erlang-之简单的-diction-实现&#34;&gt;&lt;code&gt;erlang&lt;/code&gt; 之简单的&lt;code&gt;Diction&lt;/code&gt;实现&lt;/h2&gt;

&lt;p&gt;最近在看学erlang ，看到了字典这个demo ，把程序Copy出来和大家分享一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module (diction).  
    -export([new/0,lookup/2,add/3,delete/2]).  
    new()   -&amp;gt;  
        [].  
      
    lookup(Key , [{Key,Value}|Rest])    -&amp;gt;  
        {value,Value};  
    lookup(Key,[Pair|Rest])     -&amp;gt;  
        lookup(Key,Rest);  
    lookup(Key,[])  -&amp;gt;  
        undefined.  
    add(Key,Value,Diction)  -&amp;gt;  
        NewDict =   delete(Key,Diction) ,  
        [{Key,Value}|NewDict].  
      
    delete(Key,[{Key,Value}|Rest])  -&amp;gt;  
        Rest;  
    delete(Key,[Pair|Rest]) -&amp;gt;  
        [Pair|delete(Key,Rest)];  
    delete(Key,[])  -&amp;gt;  
        [].  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数编程习惯之后，写起来也是挺爽的意见事，基本上都是递归的思想。&lt;/p&gt;

&lt;h2 id=&#34;erlang-之简单密码加密&#34;&gt;&lt;code&gt;erlang&lt;/code&gt; 之简单密码加密&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;这些程序主要是来之 连城 翻译的一个书里面的代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(encode).  
    -export([encode/2]).  
    encode(Pin.Password)    -&amp;gt;  
        Code = {nil,nil,nil,nil,nil,nil,nil,nil,nil,  
            nil,nil,nil,nil,nil,nil,nil,nil,nil,  
            nil,nil,nil,nil,nil,nil,nil,nil},  
        encode(Pin,Password,Code).  
    encode([],_,Code)   -&amp;gt;  
        Code ;  
    encode(Pin,[],code) -&amp;gt;  
        io:format(&amp;quot;Out of Letters~n&amp;quot;,[]);  
      
    encode(H|T,[Letter|T1],Code)    -&amp;gt;  
        Arg = index(Letter) +1 ,  
        case element(Arg,Code) of   
            nil -&amp;gt;  
                encode (T,T1,setelement(Arg,Code,index(H)));  
        _-&amp;gt;  
            encode ([H|T],T1,Code)  
        end.  
      
    index(X)    when X &amp;gt;= $0 ,X =&amp;lt; $9 -&amp;gt;  
            X - $0;  
    index(X)    when X&amp;gt;=$A , X =&amp;lt; $Z  -&amp;gt;  
            X - $A.  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;erlang-简单的树操作&#34;&gt;erlang 简单的树操作&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-module(tree).  
-export([test1/0]).  
lookup(Key,nil) -&amp;gt;  
    not_found;  
lookup(Key,{Key,Value,_,_}) -&amp;gt;  
    {found,Value};  
lookup(Key,{Key1,_,Smaller,_}) when Key &amp;lt; Key1   -&amp;gt;  
    lookup(Key,Smaller);  
lookup(Key,{Key1,_,_,Bigger})   when Key &amp;gt; Key1 -&amp;gt;  
    lookup(Key,Bigger).  
  
insert(Key,Value ,nil)  -&amp;gt;  
    {Key,Value,nil,nil};  
insert(Key,Value,{Key,_,Smaller,Bigger})    -&amp;gt;  
    {Key,Value,Smaller,Bigger}  ;  
insert(Key,Value,{Key1,V,Smaller,Bigger})   when Key &amp;lt; Key1 -&amp;gt;  
    {Key1,V,insert(Key,Value,Smaller),Bigger};  
insert(Key,Value,{Key1,V,Smaller,Bigger})   when Key &amp;gt; Key1  -&amp;gt;  
    {Key1,V,Smaller,insert(Key,Value,Bigger)}.  
write_tree(T)   -&amp;gt;  
    write_tree(0,T).  
write_tree(D,nil)   -&amp;gt;  
    io:tab(D),  
    io:format(&#39;nil&#39;,[]);  
write_tree(D,{Key,Value,Smaller,Bigger})    -&amp;gt;  
    D1 = D +4 ,  
    write_tree(D1,Bigger),  
    io:format(&#39;~n&#39;,[]),  
    io:tab(D),  
    io:format(&#39;~w ==&amp;gt; ~w~n&#39;,[Key,Value]),  
    write_tree(D1,Smaller).  
  
test1() -&amp;gt;  
    S1=nil,  
    S2=insert(4,joe,S1),  
    S3=insert(12,fred,S2),  
    S4=insert(3,jane,S3),  
    S5=insert(7,kalle,S4),  
    S6=insert(6,thomes,S5),  
    S7=insert(5,rickard,S6),  
    S8=insert(9,susan,S7),  
    S9=insert(2,tobbe,S8),  
    S10=insert(8,dan,S9),  
    write_tree(S10).  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码不多，&lt;code&gt;erlang&lt;/code&gt;写算法&amp;hellip;&amp;hellip;呵呵呵呵呵呵&lt;/p&gt;

&lt;h2 id=&#34;erlang-并发编程&#34;&gt;erlang 并发编程&lt;/h2&gt;

&lt;p&gt;最近上班比较忙，没时间学习erlang ，实在对不起自己啊，以前一直在找erlang相关的教程，终于找到一个了，这个网站是前几天才开始运行的，以后的文章可能都是来自于那里，网站是&lt;code&gt;http://www.erlang-cn.com&lt;/code&gt; ，大家忙没事多学习！大笑&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并发编程一&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-module(tut15).  
-export([start/0,ping/2,pong/0]).  
ping(0,Pong_PID)    -&amp;gt;  
    %%想对方发送退出信号  
    Pong_PID ! finished,  
    io:format(&amp;quot;ping finished~n&amp;quot;,Pong_PID);  
ping(N,Pong_PID)    -&amp;gt;  
    Pong_PID ! {ping,self()},  
    receive   
        pong    -&amp;gt;  
            io:format(&amp;quot;Ping receive pong ~n&amp;quot;,[])  
    end,  
    %%继续接受信息，直到 N == 0  
    ping(N-1,Pong_PID).  
  
pong()  -&amp;gt;  
    receive  
        finished    -&amp;gt;  
            io:format(&amp;quot;Pong finished~n&amp;quot;,[]);  
        {ping,Ping_PID} -&amp;gt;  
            io:format(&amp;quot;Pong received ping ~n&amp;quot;,[]),  
            Ping_PID!pong,  
            %%再次等待对方的信息，直到信息为ffinished  
            pong()  
        end.  
start() -&amp;gt;  
    %% 开启一个进程，用来等待其他进程的信息  
    Pong_PID = spawn(tut15,pong,[]),  
    %%开启一个进程，用来发送信息  
    spawn(tut15,ping,[3,Pong_PID]),  
    io:format(&amp;quot;Main Process Exit~n&amp;quot;,[]). 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进程的标识 ，我们还有一种更加灵活的方法来标记她那就是使用&lt;code&gt;register&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-module(tut16).  
-export([start/0,ping/1,pong/0]).  
  
ping(0) -&amp;gt;  
    pong ! finished,  
    io:format(&amp;quot;ping finished ~n&amp;quot;,[]);  
ping(N) -&amp;gt;  
    %% send the message to pong proccess  
    pong ! {ping,self()},  
  
    receive   
        pong -&amp;gt;  
            io:format(&amp;quot;Ping received pong ~n&amp;quot;,[])  
    end ,  
    ping(N-1).  
  
pong()  -&amp;gt;  
    receive   
        finished    -&amp;gt;  
            io:format(&amp;quot;Pong finished~n&amp;quot;,[]);  
        {ping,Ping_PID} -&amp;gt;  
            io:format(&amp;quot;Pong received ping~n&amp;quot;,[]),  
            Ping_PID ! pong,  
            pong()  
    end.  
  
start() -&amp;gt;  
    register(pong,spawn(tut16,pong,[])),  
    spawn(tut16,ping,[3]).  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;register&lt;/code&gt;中的&lt;code&gt;pong&lt;/code&gt;就标识了&lt;code&gt;spawn(tut16,pong,[])&lt;/code&gt;这个进程，这个&lt;code&gt;ping（）&lt;/code&gt;函数只要一个&lt;code&gt;N&lt;/code&gt;就行了，&lt;code&gt;pong&lt;/code&gt;可以看作是进程之间共享的变量.&lt;/p&gt;

&lt;h2 id=&#34;erlang-之-echo-服务器&#34;&gt;erlang 之 echo 服务器&lt;/h2&gt;

&lt;p&gt;简单实现了一个echo 服务器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;echo_server1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(echo).  
    -export([start/0,loop/0]).  
      
    start() -&amp;gt;  
        Pid = spawn(echo,loop,[]),  
        Pid ! {self(),&#39;Hello Word&#39;},  
        receive   
            {Pid,Msg}   -&amp;gt;  
                io:format(&#39;~w~n&#39;,[Msg])  
        end,  
        Pid ! stop.  
      
    loop()  -&amp;gt;  
        receive   
            {FromOther,Msg} -&amp;gt;  
                io:format(&amp;quot;~w~n&amp;quot;,[Msg]),  
                FromOther!{self(),&#39;Loop Proccess Send to You !&#39;},  
                loop();  
            {stop}  -&amp;gt;  
                %%io:format(&#39;~w~n&#39;,[loop_stop]),  
                true  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;29&amp;gt; echo:start().  
&#39;Hello Word&#39;  
&#39;Loop Proccess Send to You !&#39;  
stop  
30&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 stop 是主进程的返回值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;echo_server2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个简单用于等待外部信息的echo server&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(echo_server).  
    -export([start/0,print/1,stop/0,loop/0]).  
      
    start() -&amp;gt;  
        Pid = spawn(echo_server , loop , []),  
        register(sub1,Pid),   
        {ok,Pid}.  
      
    loop()  -&amp;gt;  
        receive   
            {print,A}   -&amp;gt;  
                io:format(&amp;quot;~p.~n&amp;quot;,[A]),  
                loop();  
            stop    -&amp;gt;  
                true;  
            Other -&amp;gt;  
                io:format(&amp;quot;~p~n&amp;quot;,[Other]),  
                loop()   
        end.  
      
    print(A)    -&amp;gt;  
        sub1 ! {print,A},  
        true .  
    stop()  -&amp;gt;  
        sub1 ! stop ,  
        %%   
        true .  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;timeout-的简单使用&#34;&gt;timeout 的简单使用&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;今天晚上有点晚了，不过还是坚持每一天写一个程序！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面的时超时器 ：&lt;/p&gt;

&lt;p&gt;建设&lt;code&gt;A&lt;/code&gt;要想&lt;code&gt;db&lt;/code&gt;进程发送一个信息，然后在规定的时间内等待消息的返回，那么&lt;code&gt;A&lt;/code&gt;可以设置一个超时器，注意的是在发送消息之前，得先清空消息队列，要不然等译接到的消息可能&lt;code&gt;db&lt;/code&gt;还没发送之前的了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    read(Key)   -&amp;gt;  
        flush(),  
        db | {self(),{read,Key}},  
        receive   
            {read,R}    -&amp;gt; {ok,R};  
            {error,Reason}  -&amp;gt; {error,Reason}  
        after 1000  -&amp;gt;   {error,timeout}  
        end.  
      
    flush() -&amp;gt;  
        receive   
            {read,_}    -&amp;gt; flush();  
            {error,_}   -&amp;gt;flush()  
        after 0 -&amp;gt;ok   
    end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;erlang进程生成测试&#34;&gt;Erlang进程生成测试&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(myring).  
    -export([start/1,start_proc/2]).  
    start(Num)  -&amp;gt;  
        start_proc(Num,self()).  
    start_proc(0,Pid)   -&amp;gt;  
        receive   
            ok -&amp;gt; ok   
        end,  
        Pid ! ok ;  
    start_proc(Num,Pid) -&amp;gt;  
        NPid = spawn(?MODULE,start_proc ,[Num-1,Pid]),  
        NPid ! ok ,  
        receive   
            ok -&amp;gt; ok ,  
            io:format(&amp;quot;~w~n&amp;quot;,[Num])  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进程退出时会返回ok。&lt;/p&gt;

&lt;h2 id=&#34;erlang-之时钟&#34;&gt;&lt;code&gt;erlang&lt;/code&gt;之时钟&lt;/h2&gt;

&lt;p&gt;今天来看一下&lt;code&gt;erlang&lt;/code&gt;中的时钟如何实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(timeout).  
    -export([sleep/1,flush_buffer/0]).  
      
      
      
    %%%睡眠函数  
    sleep(Time) -&amp;gt;  
        receive   
            after Time -&amp;gt;  
            true  
        end.  
      
    %%%清空邮箱  
      
    flush_buffer()  -&amp;gt;  
        receive   
            AnyMessage  -&amp;gt;  
                flush_buffer()  
            after   0   -&amp;gt;  
                true  
        end.  
      
    %%% 消息优先级的实现  
    %% 函数priority_receive会返回邮箱中第一个消息，除非有消息interrupt发送到了邮箱中，此时将返  
    %%回interrupt。通过首先使用超时时长0来调用receive去匹配interrupt，我们可以检查邮箱中是否已经有了  
    %%%这个消息。如果是，我们就返回它，否则，我们再通过模式AnyMessage去调用receive，这将选中邮箱中的  
    %%第一条消息。  
    priority_receive()  -&amp;gt;  
        receive  
            interrupt   -&amp;gt;  
                interrupt  
            after   0   -&amp;gt;  
                receive  
                    AnyMessage  -&amp;gt;  
                        AnyMessage  
                end  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面主要是睡眠 和清空“邮箱” ，还有就是优先级的简单实现.&lt;/p&gt;

&lt;p&gt;下面再来一段吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(timer).  
    -export([timeout/2,cancel/1,timer/3]).  
      
    timeout(Time,Alarm) -&amp;gt;  
        spawn(timer,timer,[self(),Time,Alarm]).  
      
      
    cancel(Timer)   -&amp;gt;  
        Timer ! {self(),cancel}.  
    timer(Pid,Time,Alarm)   -&amp;gt;  
        receive       
            {Pid,cancel}    -&amp;gt;  
                true  
        after   Time    -&amp;gt;  
            Pid ! Alarm  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;中演示一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    13&amp;gt; Pid=self(),  
    13&amp;gt; timer:timer(Pid,1000,hellword).  
    hellword  
    14&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-simple-erlang-process-pool-analysis&#34;&gt;a simple erlang process pool analysis&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/blog/erlang/pool/ppoll.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这是一个简单的&lt;code&gt;erlang&lt;/code&gt;进程池分析，是&lt;code&gt;learn you some erlang for Great Good&lt;/code&gt;里面的一个&lt;code&gt;example&lt;/code&gt;，详细的内容可到官网查看！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现原理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个的例子的实现原理官网都有比较详细的说明，主要模块在&lt;code&gt;ppool_serv&lt;/code&gt;中，&lt;code&gt;ppool_serv&lt;/code&gt;是一个&lt;code&gt;gen_server behaviour&lt;/code&gt;, 而&lt;code&gt;ppool_sup&lt;/code&gt;是一个&lt;code&gt;one_for_all&lt;/code&gt;的策略,如果&lt;code&gt;ppool_serv&lt;/code&gt;或者&lt;code&gt;worker_sup&lt;/code&gt;出现问题，彼此也没有存在的必要了。&lt;/p&gt;

&lt;p&gt;这里&lt;code&gt;ppool_serv&lt;/code&gt;和&lt;code&gt;worker_sup&lt;/code&gt;的实现，使用了一个简单的技巧，因为&lt;code&gt;worker_sup&lt;/code&gt;不是&lt;code&gt;ppool_sup&lt;/code&gt;直接调用生成的，它是由&lt;code&gt;ppool_serv&lt;/code&gt;控制生成的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;
%% Gen server
init({Limit, MFA, Sup}) -&amp;gt;
    %% We need to find the Pid of the worker supervisor from here,
    %% but alas, this would be calling the supervisor while it waits for us!
    self() ! {start_worker_supervisor, Sup, MFA},
    {ok, #state{limit=Limit, refs=gb_sets:empty()}}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;woker_sup&lt;/code&gt;由&lt;code&gt;ppool_serv&lt;/code&gt;自己在&lt;code&gt;init&lt;/code&gt;函数中，发给自己一个&lt;code&gt;Message&lt;/code&gt;，然后在回调函数中才生成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;handle_info({start_worker_supervisor, Sup, MFA}, S = #state{}) -&amp;gt;
    {ok, Pid} = supervisor:start_child(Sup, ?SPEC(MFA)),
    link(Pid),
    {noreply, S#state{sup=Pid}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果他们一起直接生产，那么会产生死锁，
&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/blog/erlang/pool/ppool_1.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;当然，他这里的生成顺序，可以自己修改一下，也不会出现死锁。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gen_serv&lt;/code&gt;的主要数据结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-define(SPEC(MFA),
        {worker_sup,
         {ppool_worker_sup, start_link, [MFA]},
          temporary,
          10000,
          supervisor,
          [ppool_worker_sup]}).

-record(state, {limit=0,
                sup,
                refs,
                queue=queue:new()}).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;?SPEC(MFA)&lt;/code&gt;, 这里的&lt;code&gt;MFA&lt;/code&gt;指明一类&lt;code&gt;Task&lt;/code&gt;，所以同一个&lt;code&gt;ppool_worker_sup&lt;/code&gt;,不会有不同类型的&lt;code&gt;Task&lt;/code&gt;，它的策略也是&lt;code&gt;simple_one_for_one&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在这个例子中，使用了一个&lt;code&gt;gen_server -- nnager module&lt;/code&gt;作为&lt;code&gt;Task&lt;/code&gt;，这个&lt;code&gt;Task&lt;/code&gt;的参数为：&lt;code&gt;{Task, Delay, Max, SendTo}&lt;/code&gt;， &lt;code&gt;Task&lt;/code&gt;标示任务名字，&lt;code&gt;Delay&lt;/code&gt;作为超时时间，只是标示这个任务是有超时限制的，也是一个调试技巧，&lt;code&gt;Max&lt;/code&gt;为最大超时次数，&lt;code&gt;SendTo&lt;/code&gt;用来发送信息给回调进程，这个进程可以是&lt;code&gt;shell&lt;/code&gt;， 如果是&lt;code&gt;shell&lt;/code&gt;，&lt;code&gt;flush()&lt;/code&gt;就会收到信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;record&lt;/code&gt;用来标识一些主要的信息，&lt;code&gt;Limit&lt;/code&gt;为进程池的大小限制，&lt;code&gt;sup&lt;/code&gt;开始为&lt;code&gt;ppool_sup&lt;/code&gt;的&lt;code&gt;pid（）&lt;/code&gt;，在生成&lt;code&gt;woker_sup&lt;/code&gt;进程后，就变成&lt;code&gt;worker_sup&lt;/code&gt;的进程&lt;code&gt;pid（）&lt;/code&gt;，因为&lt;code&gt;ppool_serv&lt;/code&gt;的主要交流对象还是&lt;code&gt;worker_sup&lt;/code&gt;和&lt;code&gt;worker(Task)&lt;/code&gt;； &lt;code&gt;refs（gb_set）&lt;/code&gt;为&lt;code&gt;woker&lt;/code&gt;的进程链接，这样可以在&lt;code&gt;worker&lt;/code&gt;进程&lt;code&gt;down&lt;/code&gt;掉或者&lt;code&gt;done&lt;/code&gt;时，从线程池中剔除掉；&lt;code&gt;queue&lt;/code&gt;为任务队列，当任务大于&lt;code&gt;limit&lt;/code&gt;时，就把多余的任务放到&lt;code&gt;queque&lt;/code&gt;中，等到进程池有空闲时，就从中&lt;code&gt;pop&lt;/code&gt;出任务，接着处理。&lt;/p&gt;

&lt;p&gt;这里有些局限的地方：
- 每次的任务都是新建的进程去处理，就是说进程的生命周期跟任务的生命周期是一样的，可以把进程跟任务分离出来，让进程不随任务的结束而结束（当然这的任务就不要是&lt;code&gt;gen_server&lt;/code&gt;,&lt;code&gt;gen_fsm&lt;/code&gt;这些，因为这些也是&lt;code&gt;spawn&lt;/code&gt;出来的进程），这样进程开销理论上一次初始化就行了，虽然进程在&lt;code&gt;erlang&lt;/code&gt;中开销比较少；
- 队列没有大小限制&lt;/p&gt;

&lt;h2 id=&#34;poolboy&#34;&gt;PoolBoy&lt;/h2&gt;

&lt;p&gt;source code ：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/devinus/poolboy&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/devinus/poolboy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/blog/erlang/pool/poolboy.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Checkout&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;
ready({checkout, Block, Timeout}, {FromPid, _}=From, State) -&amp;gt;
    #state{supervisor = Sup,
           workers = Workers,
           monitors = Monitors,
           max_overflow = MaxOverflow} = State,
    case queue:out(Workers) of
        {{value, Pid}, Left} -&amp;gt;
            Ref = erlang:monitor(process, FromPid),
            true = ets:insert(Monitors, {Pid, Ref}),
            NextState = case queue:is_empty(Left) of
                true when MaxOverflow &amp;lt; 1 -&amp;gt; full;
                true -&amp;gt; overflow;
                false -&amp;gt; ready
            end,
            {reply, Pid, NextState, State#state{workers=Left}};
        {empty, Empty} when MaxOverflow &amp;gt; 0 -&amp;gt;
            {Pid, Ref} = new_worker(Sup, FromPid),
            true = ets:insert(Monitors, {Pid, Ref}),
            {reply, Pid, overflow, State#state{workers=Empty, overflow=1}};
        {empty, Empty} when Block =:= false -&amp;gt;
            {reply, full, full, State#state{workers=Empty}};
        {empty, Empty} -&amp;gt;
            Waiting = add_waiting(From, Timeout, State#state.waiting),
            {next_state, full, State#state{workers=Empty, waiting=Waiting}}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Checkout&lt;/code&gt;出一个&lt;code&gt;worker&lt;/code&gt;从&lt;code&gt;worker Queue&lt;/code&gt;中，如果有,则&lt;code&gt;monitor（ets）&lt;/code&gt;这个&lt;code&gt;worker&lt;/code&gt;，然后根据队列的容量和&lt;code&gt;MaxOverflow&lt;/code&gt;的值来确定下一状态为&lt;code&gt;full&lt;/code&gt;，&lt;code&gt;overflow&lt;/code&gt;，&lt;code&gt;ready&lt;/code&gt; （&lt;code&gt;ready + overflow &amp;lt;= full&lt;/code&gt;）;如果没有，而&lt;code&gt;MaxOverFlow&lt;/code&gt;的值大于&lt;code&gt;0&lt;/code&gt;，则新建一个&lt;code&gt;worker&lt;/code&gt;，并将其加入&lt;code&gt;monitor&lt;/code&gt;，最后重置状态项&lt;code&gt;worker = empty, overflow = 1&lt;/code&gt;；如果没有，并且&lt;code&gt;MaxOverflow&lt;/code&gt; 小于&lt;code&gt;1&lt;/code&gt;， &lt;code&gt;Block == false&lt;/code&gt;，则&lt;code&gt;{reply, full, full, State#state{workers=Empty}}&lt;/code&gt;;如过没有，&lt;code&gt;MaxOverflow &amp;lt; 1&lt;/code&gt;, &lt;code&gt;Block == true&lt;/code&gt;,则 &lt;code&gt;{next_state, full, State#state{workers=Empty, waiting=Waiting}}&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Checkin&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;ready({checkin, Pid}, State) -&amp;gt;
    Monitors = State#state.monitors,
    case ets:lookup(Monitors, Pid) of
        [{Pid, Ref}] -&amp;gt;
            true = erlang:demonitor(Ref),
            true = ets:delete(Monitors, Pid),
            Workers = queue:in(Pid, State#state.workers),
            {next_state, ready, State#state{workers=Workers}};
        [] -&amp;gt;
            {next_state, ready, State}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;code&gt;Monitor&lt;/code&gt;中剔除对应的&lt;code&gt;worker&lt;/code&gt;，然后回收到&lt;code&gt;worker queue&lt;/code&gt;中去。
状态转变&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;状态转变的计算：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;worker_queue_size&lt;/code&gt;(当前&lt;code&gt;size&lt;/code&gt;) + &lt;code&gt;maxoverflow&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ready&lt;/code&gt;只与当前&lt;code&gt;worker_queque_size&lt;/code&gt;有关，&lt;code&gt;overflow&lt;/code&gt; 和&lt;code&gt;worker_queue_size(0)&lt;/code&gt;和&lt;code&gt;maxoverflow&amp;gt;0&lt;/code&gt;有关，&lt;code&gt;full&lt;/code&gt;和&lt;code&gt;work_queue_size(0)&lt;/code&gt;, &lt;code&gt;overfllow = maxoverflow&lt;/code&gt;有关。
- &lt;code&gt;worker&lt;/code&gt;的来源&lt;/p&gt;

&lt;p&gt;所有的&lt;code&gt;worker&lt;/code&gt;要么在初始化时创建平；要么调用&lt;code&gt;checkout&lt;/code&gt;时，经过&lt;code&gt;poolboy&lt;/code&gt;创建，但此时创建的&lt;code&gt;worker&lt;/code&gt;没有进到&lt;code&gt;worker queue&lt;/code&gt;，要想进到&lt;code&gt;worker queue&lt;/code&gt;，只能调用&lt;code&gt;checkin&lt;/code&gt;。
&lt;code&gt;work pid&lt;/code&gt; 回收到&lt;code&gt;worker_queue&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;checkin_while_full --》{empty, Empty} when MaxOverflow &amp;lt; 1 -&amp;gt;；
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Goim源码剖析</title>
      <link>https://laohanlinux.github.io/2016/04/04/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 04 Apr 2016 14:53:49 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/04/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>