<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to Rg Home on Welcome to Rg Home</title>
    <link>https://laohanlinux.github.io/</link>
    <description>Recent content in Welcome to Rg Home on Welcome to Rg Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Apr 2019 17:20:45 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Embark on a New Journey</title>
      <link>https://laohanlinux.github.io/2019/04/04/embark-on-a-new-journey/</link>
      <pubDate>Thu, 04 Apr 2019 17:20:45 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/04/04/embark-on-a-new-journey/</guid>
      <description>

&lt;p&gt;å¥½ä¹…æ²¡å†™åšå®¢äº†ï¼Œæ•´ä¸ªäººå¿«è¦åºŸäº†ï¼Œæ˜¯æ—¶å€™æ”¹å†™ä¸œè¥¿äº†ã€‚&lt;code&gt;Flag&lt;/code&gt;ç«‹å¾—æœ‰ç‚¹æ™šï¼Œå¸Œæœ›èƒ½æ¥å¾—æ€¥.&lt;/p&gt;

&lt;h3 id=&#34;golang&#34;&gt;Golang&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[] Memory Manage&lt;/li&gt;
&lt;li&gt;[] GC&lt;/li&gt;
&lt;li&gt;[] Schedule&lt;/li&gt;
&lt;li&gt;[] Lock/RWLock&lt;/li&gt;
&lt;li&gt;[] Channel&lt;/li&gt;
&lt;li&gt;[] Select&lt;/li&gt;
&lt;li&gt;[] Map/SyncMap&lt;/li&gt;
&lt;li&gt;[] Slice&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;distribute-system&#34;&gt;Distribute System&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[] Tikv&lt;/li&gt;
&lt;li&gt;[] Use Tikv to design a Distribute KV support MVCCã€sharding System&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;k8s&#34;&gt;k8s&lt;/h3&gt;

&lt;p&gt;å¦‚æœæœ‰æœºä¼šï¼Œä¹Ÿå®è·µä¸€ä¸‹&lt;code&gt;k8s&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Memory Manager</title>
      <link>https://laohanlinux.github.io/2019/04/04/go-memory-manager/</link>
      <pubDate>Thu, 04 Apr 2019 17:12:18 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/04/04/go-memory-manager/</guid>
      <description>

&lt;h2 id=&#34;å‰è¨€&#34;&gt;å‰è¨€&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;å†…å­˜ç®¡ç†æ˜¯&lt;code&gt;runtime&lt;/code&gt;æ¯”è¾ƒé‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œ&lt;code&gt;Go&lt;/code&gt;å†…å­˜ç®¡ç†ç®—æ³•æ¥è‡³äº&lt;code&gt;TCMalloc&lt;/code&gt;ï¼Œéå¸¸ç±»ä¼¼ã€‚&lt;code&gt;tcmalloc&lt;/code&gt;å·²ç»å‘å±•å¥½é•¿ä¸€æ®µæ—¶é—´äº†ï¼Œæ˜¯éå¸¸é«˜æ•ˆçš„ä¸€ç§å†…å­˜ç®¡ç†ç®—æ³•ï¼Œä¸‹é¢ç®€å•èŠä¸€ä¸‹&lt;code&gt;tcmalloc&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;h2 id=&#34;tcmalloc&#34;&gt;TCMalloc&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tcmalloc&lt;/code&gt;é‡‡ç”¨åˆ†å±‚çš„è®¾è®¡ï¼Œå…¶å†…å­˜å¯¹è±¡è¢«åˆ’åˆ†ä¸º&lt;code&gt;Small&lt;/code&gt;ã€&lt;code&gt;Medium&lt;/code&gt;ã€&lt;code&gt;Large&lt;/code&gt;ä¸‰ä¸ªç­‰çº§ï¼Œæ¯ä¸ªç­‰çº§çš„å¯¹è±¡å ç”¨å†…å­˜å„ä¸ç›¸åŒã€‚&lt;/p&gt;

&lt;h3 id=&#34;memory-level&#34;&gt;Memory Level&lt;/h3&gt;

&lt;h4 id=&#34;small&#34;&gt;Small&lt;/h4&gt;

&lt;h4 id=&#34;medium&#34;&gt;Medium&lt;/h4&gt;

&lt;h4 id=&#34;large&#34;&gt;Large&lt;/h4&gt;

&lt;h3 id=&#34;å±‚æ¬¡&#34;&gt;å±‚æ¬¡&lt;/h3&gt;

&lt;h4 id=&#34;thread-cache&#34;&gt;Thread Cache&lt;/h4&gt;

&lt;h4 id=&#34;centralcache&#34;&gt;CentralCache&lt;/h4&gt;

&lt;h4 id=&#34;pageheap&#34;&gt;PageHeap&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Nothing</title>
      <link>https://laohanlinux.github.io/about/</link>
      <pubDate>Thu, 04 Apr 2019 13:07:28 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/about/</guid>
      <description>&lt;p&gt;Talk is cheap, Show me the code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rocket Girls</title>
      <link>https://laohanlinux.github.io/2019/04/04/rocket-girls/</link>
      <pubDate>Thu, 04 Apr 2019 00:45:37 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/04/04/rocket-girls/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcgy1g1pyawo1wjj30zk0j142h.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2019/03/30&lt;/code&gt;çœ‹äº†äººç”Ÿä¸­çš„ç¬¬ä¸€åœºæ¼”å”±ä¼šï¼Œæ€»ä½“æ¥è¯´ï¼Œæ¯”è¾ƒæ»¡è¶³ï¼Œå”¯ä¸€ä¸çˆ½çš„æ˜¯åå¾—å¤ªè¿œäº†ï¼Œçœ‹ä¸æ¸…ï¼ğŸ˜‚åº”è¯¥ä¹°å‰æ’çš„ï¼Œæ¶¨æ¶¨ç»éªŒä¹Ÿå¥½ï¼Œèµ·ç å¾—æºå¸¦ä¸ªæœ›çœ¼é•œï¼Œå¦åˆ™æ€»èƒ½çœ‹çœ‹æŠ•å½±äº†ã€‚&lt;/p&gt;

&lt;p&gt;å†™å†™ç»è¿‡å§!&lt;/p&gt;

&lt;h2 id=&#34;ä¹°ç¥¨&#34;&gt;ä¹°ç¥¨&lt;/h2&gt;

&lt;p&gt;å…¶å®åœ¨å»å¹´çš„æ—¶å€™ï¼Œä¸»åŠæ–¹å°±å®‰æ’ç«å°‘çš„ç¬¬ä¸€åœº&lt;code&gt;Flower&lt;/code&gt;ä¸»é¢˜æ¼”å‡ºåœ¨å¹¿å·å¼€ï¼Œå“¥ä¸€å¤§æ—©å°±åœ¨å¤§éº¦ç½‘é¢„è®¢äº†&lt;code&gt;960&lt;/code&gt;çš„ç¥¨ï¼Œå¯æƒœåˆ°å¿«è¦å¼€çš„æ—¶å€™ï¼Œæ—¢ç„¶è¯´æ˜¯æ˜¥è¿å®‰å…¨é—®é¢˜ç»™åœæ‰äº†ã€‚ç­‰åˆ°3æœˆä»½çš„æ—¶å€™ï¼Œä¸çŸ¥é“å•¥æ—¶å€™ï¼Œä¸»åŠæ–¹æŠŠç¥¨éƒ½å‡ºå”®å®Œäº†ï¼Œæ²¡åŠæ³•å•Šï¼Œé‚£å°±åˆ°é—²é±¼ç½‘ç¢°ç¢°è¿æ°”å‘—ï¼Œæœ€åä¹°äº†ä¸€å¼ &lt;code&gt;480&lt;/code&gt;çš„ç¥¨ï¼Œé»„ç‰›ç«Ÿç„¶å¼€å£ä»·ä¹°åˆ°&lt;code&gt;800&lt;/code&gt;ï¼Œè¿™è¿˜ä¸å¦‚å»æŠ¢ç®—äº†ã€‚æ€ä»·åˆ°&lt;code&gt;500&lt;/code&gt;æˆäº¤ï¼ŒçœŸå¿ƒå¤šä¸€æ¯›é’±éƒ½ä¸æƒ³ç»™é»„ç‰›ã€‚&lt;/p&gt;

&lt;p&gt;æœ¬æ¥æ˜¯æƒ³ä¹°æ¨è¶…è¶Šçš„å›¢ç¥¨ï¼Œå¯æƒœæ‰¾äº†å¥½ä¹…éƒ½æ²¡æœ‰ï¼Œå¯èƒ½æ˜¯è¶…è¶Šäººæ°”å¤ªé«˜äº†ï¼ä¸­é—´ä¹Ÿæœ‰&lt;code&gt;sunnee&lt;/code&gt;çš„ç¥¨ï¼Œå¯æ˜¯å¯¹æ–¹ä¸€å¬è¯´æ˜¯è¶…è¶Šçš„ç²‰ä¸ï¼Œå°±ä¸å–äº†ï¼ğŸ˜‚ğŸ˜‚ğŸ˜‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tKfTcgy1g1q050gxc9j311i0u0b2e.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;åº”æ´&#34;&gt;åº”æ´&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tKfTcgy1g1qhtpb3wqj30sg0lcjyg.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tKfTcgy1g1qhupt3p3j30lc0sgadl.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/006tKfTcgy1g1qhuwmlwwj30lc0sggql.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcgy1g1qhvacm0zj30lc0sg7gk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcgy1g1qhvfln7ij30lc0sgqbg.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tKfTcgy1g1qhvs57m8j30sg0lc7bd.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ç°åœº&#34;&gt;ç°åœº&lt;/h2&gt;

&lt;h3 id=&#34;å¼€åœºç™½&#34;&gt;å¼€åœºç™½&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34;  src=&#34;https://v.qq.com/txp/iframe/player.html?vid=a0857e6d2gs&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=v08573uc8ib&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
ä»ç°åœºçœ‹ï¼Œå­Ÿç¾å²ã€å´å®£ä»ªã€sunneeã€æ¨è¶…è¶Šçš„ç²‰ä¸äººæ•°ç›¸å·®ä¸å¤§ï¼Œæ¥ä¸‹æ¥å°±æ˜¯å¼ ç´«å®ã€å°ä¸ƒã€Yamiã€å‚…èã€æ®µå¥¥å¨Ÿã€å°å½©è™¹ã€æç´«å©·ã€‚&lt;/p&gt;

&lt;h3 id=&#34;rocket-girl&#34;&gt;Rocket Girl&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=t0857f59bq1&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
æ˜¯æˆ‘å•Šï¼Œæ˜¯æˆ‘å•Šï¼ğŸ˜ƒ&lt;/p&gt;

&lt;h3 id=&#34;åœŸå‘³æƒ…è¯&#34;&gt;åœŸå‘³æƒ…è¯&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=j0857bf160r&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;å¤§å¨Ÿfaded&#34;&gt;å¤§å¨ŸFaded&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=g0857r6x4h3&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ç¦åˆ©&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://youtu.be/y9HaphHtzCg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://youtu.be/y9HaphHtzCg&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;solo&#34;&gt;Solo&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=g0857r6x4h3&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;ç”Ÿè€Œä¸ºèµ¢&#34;&gt;ç”Ÿè€Œä¸ºèµ¢&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;  width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=v0857fkutxr&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;æœè£…ä¸é”™ï¼Œèˆè¹ˆä¹Ÿokï¼&lt;/p&gt;

&lt;h3 id=&#34;æ¨ªå†²ç›´æ’ä¸‹ä¸€ç«™&#34;&gt;æ¨ªå†²ç›´æ’ä¸‹ä¸€ç«™&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;   width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=p0857lq0stu&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
è¿åŠ¨é£ï¼&lt;/p&gt;

&lt;h3 id=&#34;æ··å¥&#34;&gt;æ··å¥&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34;   width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=l08571x0v6t&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;å¡è·¯é‡Œ&#34;&gt;å¡è·¯é‡Œ&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=q08572xwdv6&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
å¥½å¥¶çš„å¡è·¯é‡Œ&lt;/p&gt;

&lt;h3 id=&#34;light&#34;&gt;Light&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe frameborder=&#34;0&#34; width=&#34;800&#34; height=&#34;600&#34; src=&#34;https://v.qq.com/txp/iframe/player.html?vid=r0857k1zdhv&#34; allowFullScreen=&#34;true&#34;&gt;&lt;/iframe&gt;
&lt;/center&gt;
æœ‰äº›ä¼¤æ„Ÿçš„&lt;code&gt;Light&lt;/code&gt;ï¼Œ2å¹´é™å›¢ä¸å®¹æ˜“ï¼Œæœ›å¤§å®¶éƒ½å·¥ä½œé¡ºåˆ©ï¼Œèº«ä½“å¥åº·ï¼&lt;/p&gt;

&lt;h2 id=&#34;ç¦»åœº&#34;&gt;ç¦»åœº&lt;/h2&gt;

&lt;p&gt;å¸Œæœ›æ˜å¹´è¿˜æœ‰ç«å°‘çš„æ¼”å”±ä¼šå§ï¼&lt;/p&gt;

&lt;h3 id=&#34;æœ‰æ„Ÿ&#34;&gt;æœ‰æ„Ÿ&lt;/h3&gt;

&lt;p&gt;åœ¨çŸ¥ä¹ä¸Šçœ‹åˆ°é—¨ç¥¨çš„é—®é¢˜ï¼Œæ„Ÿåˆ°æœ‰äº›ç—›å¿ƒï¼Œè¯•æƒ³ä¸€ä¸‹ï¼Œä»å¤§è€è¿œè·‘è¿‡æ¥ï¼Œä¸€å¥è¯-&lt;strong&gt;æ²¡ç¥¨&lt;/strong&gt;å°±æŠŠäººç»™æ‰“å‘äº†ï¼Œè¿™æ˜¯ä»€ä¹ˆå¿ƒæƒ…ã€‚æœç„¶å•†äººé‡åˆ©ç›Šï¼Œç™¾å¹´ä¸å˜ã€‚&lt;/p&gt;

&lt;p&gt;å¦‚ä½•è¯„ä»·2019å¹´3æœˆ30æ—¥ç«ç®­å°‘å¥³101å¹¿å·æ¼”å”±ä¼šï¼Ÿ - çŸ¥ä¹
&lt;a href=&#34;https://www.zhihu.com/question/317403907&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.zhihu.com/question/317403907&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>goå†…å­˜ç®¡ç†</title>
      <link>https://laohanlinux.github.io/2019/03/03/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 03 Mar 2019 17:12:18 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2019/03/03/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;å‰è¨€&#34;&gt;å‰è¨€&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;å†…å­˜ç®¡ç†æ˜¯&lt;code&gt;runtime&lt;/code&gt;æ¯”è¾ƒé‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œ&lt;code&gt;Go&lt;/code&gt;å†…å­˜ç®¡ç†ç®—æ³•æ¥è‡³äº&lt;code&gt;TCMalloc&lt;/code&gt;ï¼Œéå¸¸ç±»ä¼¼ã€‚&lt;code&gt;tcmalloc&lt;/code&gt;å·²ç»å‘å±•å¥½é•¿ä¸€æ®µæ—¶é—´äº†ï¼Œæ˜¯éå¸¸é«˜æ•ˆçš„ä¸€ç§å†…å­˜ç®¡ç†ç®—æ³•ï¼Œä¸‹é¢ç®€å•èŠä¸€ä¸‹&lt;code&gt;tcmalloc&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;h2 id=&#34;tcmalloc&#34;&gt;TCMalloc&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tcmalloc&lt;/code&gt;é‡‡ç”¨åˆ†å±‚çš„è®¾è®¡ï¼Œå…¶å†…å­˜å¯¹è±¡è¢«åˆ’åˆ†ä¸º&lt;code&gt;Small&lt;/code&gt;ã€&lt;code&gt;Medium&lt;/code&gt;ã€&lt;code&gt;Large&lt;/code&gt;ä¸‰ä¸ªç­‰çº§ï¼Œæ¯ä¸ªç­‰çº§çš„å¯¹è±¡å ç”¨å†…å­˜å„ä¸ç›¸åŒã€‚&lt;/p&gt;

&lt;h3 id=&#34;memory-level&#34;&gt;Memory Level&lt;/h3&gt;

&lt;h4 id=&#34;small&#34;&gt;Small&lt;/h4&gt;

&lt;h4 id=&#34;medium&#34;&gt;Medium&lt;/h4&gt;

&lt;h4 id=&#34;large&#34;&gt;Large&lt;/h4&gt;

&lt;h3 id=&#34;å±‚æ¬¡&#34;&gt;å±‚æ¬¡&lt;/h3&gt;

&lt;h4 id=&#34;thread-cache&#34;&gt;Thread Cache&lt;/h4&gt;

&lt;h4 id=&#34;centralcache&#34;&gt;CentralCache&lt;/h4&gt;

&lt;h4 id=&#34;pageheap&#34;&gt;PageHeap&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>raftæºç åˆ†æ</title>
      <link>https://laohanlinux.github.io/2017/09/11/raft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 11 Sep 2017 12:08:30 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2017/09/11/raft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;p&gt;è¿™ç¯‡æ–‡ç« ä¸»è¦æ˜¯ä»æºç çš„çº§åˆ«æ¥çœ‹&lt;code&gt;Raft&lt;/code&gt;ç®—æ³•çš„å®ç°ã€‚åœ¨ç½‘ä¸Šæ‰¾åˆ°äº†ä¸€ä¸ªç®€åŒ–ç‰ˆï¼š&lt;a href=&#34;https://github.com/peterbourgon/raft&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;æºç &lt;/a&gt;.
ä¸€ä¸ª&lt;code&gt;Server&lt;/code&gt;ç»“æ„ä»£è¡¨&lt;code&gt;Raft&lt;/code&gt;ç½‘ç»œä¸­çš„ä¸€ä¸ª&lt;code&gt;èŠ‚ç‚¹&lt;/code&gt;ã€‚èŠ‚ç‚¹ä¼šåˆ›å»ºä¸€ä¸ª&lt;code&gt;Server&lt;/code&gt;ï¼Œå¹¶ä¸”é€šè¿‡&lt;code&gt;ç«¯(peers)&lt;/code&gt;æ¥å£çš„æ–¹å¼æš´éœ²ç»™å…¶ä»–èŠ‚ç‚¹ã€‚
ä¼ è¾“å±‚é‡‡ç”¨&lt;code&gt;http&lt;/code&gt;åŒ…è£…ï¼Œ&lt;code&gt;ç«¯å¯¹ç«¯&lt;/code&gt;é€šä¿¡é€šè¿‡&lt;code&gt;rest http&lt;/code&gt;æ–¹å¼ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;|http transport| ---&amp;gt; |peers| ---&amp;gt; |server|
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;é¡¹ç›®ç®€ä»‹&#34;&gt;é¡¹ç›®ç®€ä»‹&lt;/h1&gt;

&lt;h2 id=&#34;èŠ‚ç‚¹çš„å¢åŠ å’Œåˆ é™¤&#34;&gt;èŠ‚ç‚¹çš„å¢åŠ å’Œåˆ é™¤&lt;/h2&gt;

&lt;p&gt;æ”¯æŒåŠ¨æ€å¢åˆ èŠ‚ç‚¹ï¼Œé‡‡ç”¨ä¸€ä¸ªç®€å•çš„&lt;code&gt;å…±è¯†&lt;/code&gt;ç®—æ³•(èŠ‚ç‚¹æ›´æ–°æ—¶ï¼Œæ¥å—é…ç½®æ›´æ–°çš„èŠ‚ç‚¹éœ€è¦è¶…è¿‡1/2ï¼Œå³æ–°é›†ç¾¤è¦å¤§äºæ—§é›†ç¾¤)ã€‚&lt;/p&gt;

&lt;h2 id=&#34;roadmap&#34;&gt;roadmap&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;leaderé€‰ä¸¾&lt;/li&gt;
&lt;li&gt;æ—¥å¿—å¤åˆ¶&lt;/li&gt;
&lt;li&gt;å•å…ƒæµ‹è¯•&lt;/li&gt;
&lt;li&gt;http ä¼ è¾“å±‚&lt;/li&gt;
&lt;li&gt;é…ç½®å˜æ›´&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›æ˜¯æœªå®Œæˆçš„
- net/rpc ä¼ è¾“å±‚æˆ–è€…å…¶ä»–ç±»å‹çš„ä¼ è¾“å±‚
- æ—¥å¿—å‹ç¼©
- å¿«ç…§å®‰è£…ä»¥åŠæ¢å¤
- å®Œæ•´çš„&lt;code&gt;demo&lt;/code&gt;åº”ç”¨
- ä¸€äº›æ¯”è¾ƒå¤æ‚çš„æµ‹è¯•ç”¨ä¾‹
  å…·ä½“ç»†èŠ‚ï¼Œçœ‹ä¸‹é¢çš„ä»£ç åˆ†æã€‚&lt;/p&gt;

&lt;h1 id=&#34;æºç åˆ†æ&#34;&gt;æºç åˆ†æ&lt;/h1&gt;

&lt;h2 id=&#34;æºç ç›®å½•ç»“æ„&#34;&gt;æºç ç›®å½•ç»“æ„&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;â”œâ”€â”€ JOINT-CONSENSUS.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ configuration.go // é…ç½®
â”œâ”€â”€ example_test.go // demo
â”œâ”€â”€ log.go // æ—¥å¿—
â”œâ”€â”€ log_test.go // æ—¥å¿—æµ‹è¯•æ¨¡å—
â”œâ”€â”€ peers.go // ç«¯
â”œâ”€â”€ peers_test.go // ç«¯æ¨¡å—
â”œâ”€â”€ rpc.go // rpc å¯¹è±¡æ¨¡å—
â”œâ”€â”€ server.go //  serveræ¨¡å—
â”œâ”€â”€ server_internals_test.go // serverå†…éƒ¨æµ‹è¯•æ¨¡å—
â”œâ”€â”€ server_test.go //  serveræµ‹è¯•æ¨¡å—
â”œâ”€â”€ transport.go // ä¼ è¾“å±‚
â””â”€â”€ transport_test.go // ä¼ è¾“å±‚æ¨¡å—
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ä¸»è¦çš„æ•°æ®ç»“æ„&#34;&gt;ä¸»è¦çš„æ•°æ®ç»“æ„&lt;/h2&gt;

&lt;h3 id=&#34;rpc-go&#34;&gt;rpc.go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// æ—¥å¿—è¿½åŠ 
type appendEntriesTuple struct {
        // æ—¥å¿—è¿½åŠ è¯·æ±‚
       	Request  appendEntries 
       	// åº”ç­”é€šé“
       	Response chan appendEntriesResponse 
}
// æŠ•ç¥¨é€‰ä¸¾
type requestVoteTuple struct {
        // é€‰ä¸¾å†…å®¹
       	Request  requestVote 
       	// é€‰ä¸¾ç»“æ„åº”ç­”
       	Response chan requestVoteResponse
}

// appendEntries represents an appendEntries RPC.
// æ—¥å¿—è¿½åŠ -å®ä½“
type appendEntries struct {
        // ä»»æœŸå·
       	Term         uint64     `json:&amp;quot;term&amp;quot;` 
   	    // leader æ ‡è¯†
       	LeaderID     uint64     `json:&amp;quot;leader_id&amp;quot;` 
   	    // å‰ä¸€ä¸ªæ—¥å¿—ç´¢å¼•
       	PrevLogIndex uint64     `json:&amp;quot;prev_log_index&amp;quot;` 
       	// å‰ä¸€ä¸ªæ—¥å¿—ä»»æœŸå·
       	PrevLogTerm  uint64     `json:&amp;quot;prev_log_term&amp;quot;` 
       	// è¦è¿½åŠ çš„å®ä½“æ•°ç»„-æ”¯æŒæ‰¹é‡è¿½åŠ 
       	Entries      []logEntry `json:&amp;quot;entries&amp;quot;` 
       	// å·²ç»committedçš„ç¼©å½±
       	CommitIndex  uint64     `json:&amp;quot;commit_index&amp;quot;` 
}

// appendEntriesResponse represents the response to an appendEntries RPC.
// æ—¥å¿—è¿½åŠ åº”ç­”
type appendEntriesResponse struct {
        // åº”ç­”èŠ‚ç‚¹çš„ä»»æœŸå·
       	Term    uint64 `json:&amp;quot;term&amp;quot;` 
       	// æ˜¯å¦è¿½åŠ æˆåŠŸ
       	Success bool   `json:&amp;quot;success&amp;quot;` 
       	// å¤±è´¥çš„åŸå› 
       	reason  string 
}

// requestVote represents a requestVote RPC.
// æŠ•ç¥¨è¯·æ±‚å®ä½“
type requestVote struct {
         // å‘èµ·è€…çš„ä»»æœŸå· 
       	Term         uint64 `json:&amp;quot;term&amp;quot;`
   	    // å‘èµ·è€…çš„id
       	CandidateID  uint64 `json:&amp;quot;candidate_id&amp;quot;`
   	    // å‘èµ·è€…çš„æœ€æ–°æ¡ç›®
       	LastLogIndex uint64 `json:&amp;quot;last_log_index&amp;quot;`
   	    // å‘èµ·è€…çš„æœ€æ–°ä»»æœŸå·
       	LastLogTerm  uint64 `json:&amp;quot;last_log_term&amp;quot;`
}

// requestVoteResponse represents the response to a requestVote RPC.
// æŠ•ç¥¨åº”ç­”
type requestVoteResponse struct {
        // åº”ç­”è€…ä»»æœŸå·
       	Term        uint64 `json:&amp;quot;term&amp;quot;`
   	    // åº”ç­”ç»“æœï¼ŒtrueèµåŒï¼Œfalseåå¯¹
       	VoteGranted bool   `json:&amp;quot;vote_granted&amp;quot;`
        // åå¯¹åŸå› 
       	reason      string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;log-go&#34;&gt;log.go&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/raft-rs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
        // ä»»æœŸå·å¤ªå°
       	errTermTooSmall    = errors.New(&amp;quot;term too small&amp;quot;)
       	// æ—¥å¿—ç´¢å¼•å¤ªå°
       	errIndexTooSmall   = errors.New(&amp;quot;index too small&amp;quot;)
       	// æ—¥å¿—ç¼©å½±å¤ªå¤§
       	errIndexTooBig     = errors.New(&amp;quot;commit index too big&amp;quot;)
       	// æ—¥å¿—æ¡ç›®å†…å®¹å·²æŸå
       	errInvalidChecksum = errors.New(&amp;quot;invalid checksum&amp;quot;)
	   // æ— æ•ˆçš„å‘½ä»¤
       	errNoCommand       = errors.New(&amp;quot;no command&amp;quot;)
       	// é”™è¯¯çš„æ—¥å¿—ç´¢å¼•
       	errBadIndex        = errors.New(&amp;quot;bad index&amp;quot;)
       	// é”™è¯¯ä»»æœŸå·
       	errBadTerm         = errors.New(&amp;quot;bad term&amp;quot;)
)
// æ—¥å¿—ç»“æ„
type raftLog struct {
        // æ—¥å¿—è¯»å†™é”
       	sync.RWMutex
       	// æ—¥å¿—å­˜å‚¨æ¥å£
       	store     io.Writer
   	    // æ—¥å¿—é•œåƒï¼Œç°åœ¨å­˜å‚¨äºå†…å­˜
       	entries   []logEntry
       	// ä¸‹ä¸€æ¡æ—¥å¿—commitç´¢å¼•
       	commitPos int
       	// &amp;quot;æ“ä½œ&amp;quot;çš„å›è°ƒå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¯”è¾ƒé‡è¦ï¼Œå¯ä»¥&amp;quot;æ“ä½œé›†åˆ&amp;quot;é•œåƒï¼Œ
       	// åœ¨å¿«ç…§æ—¶ï¼Œåªéœ€è¦å°†&amp;quot;ç»“æœ&amp;quot;å¿«åˆ°å­˜å‚¨å±‚å³å¯
       	apply     func(uint64, []byte) []byte
}

func newRaftLog(store io.ReadWriter, apply func(uint64, []byte) []byte) *raftLog {
       	l := &amp;amp;raftLog{
       		store:     store,
       		entries:   []logEntry{},
       		commitPos: -1, // no commits to begin with
       		apply:     apply,
       	}
       	l.recover(store)
       	return l
}

// recover reads from the log&#39;s store, to populate the log with log entries
// from persistent storage. It should be called once, at log instantiation.
// æ—¥å¿—æ¢å¤ï¼Œå½“æœåŠ¡é‡å¯æ—¶ï¼Œé‡å»ºæ—¥å¿—æ¡ç›®(ä¸€èˆ¬é‡å»ºéƒ½æ˜¯å±…äºäºå¿«ç…§å’Œæ—¥å¿—çš„ï¼Œå¯æ˜¯è¿™é‡Œæ²¡æœ‰å®ç°å¿«ç…§ï¼Œæ‰€ä»¥ä»æ—¥å¿—ä¸­é‡å»ºå³å¯)
// 1ã€è¿™é‡Œçš„æ—¥å¿—æ—¶commitedä¹‹åçš„æ—¥å¿—ï¼Œæ‰€ä»¥é‡å»ºæ—¶ï¼ŒcommitPosä¹Ÿä¼šæ›´æ–°
// 2ã€é‡å»ºæ—¥å¿—æ¡ç›®ï¼Œä¼šè°ƒç”¨applyå‡½æ•°ï¼Œå¯¹æ—¥å¿—è¿›è¡Œå¤„ç†ï¼Œè¿™ä¸ªå‡½æ•°ç›¸å½“äº&amp;quot;çŠ¶æ€æœº&amp;quot;åŠŸèƒ½ï¼›å¦‚æœæœ‰å¿«ç…§(ç›¸å½“äºRedis çš„RDB)ï¼Œå…ˆå°†å®‰è£…å¿«ç…§ï¼Œå†æ¢å¤æ—¥å¿—(ç›¸å½“äºRedis çš„aof)
func (l *raftLog) recover(r io.Reader) error {
       	for {
       		var entry logEntry
       		switch err := entry.decode(r); err {
       		case io.EOF:
       			return nil // successful completion
       		case nil:
       			if err := l.appendEntry(entry); err != nil {
       				return err
       			}
       			l.commitPos++
       			l.apply(entry.Index, entry.Command)
       		default:
       			return err // unsuccessful completion
       		}
       	}
}

// entriesAfter returns a slice of log entries after (i.e. not including) the
// passed index, and the term of the log entry specified by index, as a
// convenience to the caller. (This function is only used by a leader attempting
// to flush log entries to its followers.)
//
// This function is called to populate an AppendEntries RPC. That implies they
// are destined for a follower, which implies the application of the commands
// should have the response thrown away, which implies we shouldn&#39;t pass a
// commandResponse channel (see: commitTo implementation). In the normal case,
// the raftLogEntries we return here will get serialized as they pass thru their
// transport, and lose their commandResponse channel anyway. But in the case of
// a LocalPeer (or equivalent) this doesn&#39;t happen. So, we must make sure to
// proactively strip commandResponse channels.
// æ£€ç´¢indexä¹‹åçš„æ—¥å¿—æ¡ç›®
func (l *raftLog) entriesAfter(index uint64) ([]logEntry, uint64) {
       	l.RLock()
       	defer l.RUnlock()

  		// 1.æ£€ç´¢å‡ºindexå¯¹åº”termä»¥åŠåœ¨å®ä½“é›†åˆentriesä¸­çš„ä½ç½®Pos
       	pos := 0
       	lastTerm := uint64(0)
       	for ; pos &amp;lt; len(l.entries); pos++ {
       		if l.entries[pos].Index &amp;gt; index {
       			break
       		}
       		lastTerm = l.entries[pos].Term
       	}

       	a := l.entries[pos:]
       	if len(a) == 0 {
       		return []logEntry{}, lastTerm
       	}
		// é™¤å»command Response channel
       	return stripResponseChannels(a), lastTerm
}

func stripResponseChannels(a []logEntry) []logEntry {
       	stripped := make([]logEntry, len(a))
       	for i, entry := range a {
       		stripped[i] = logEntry{
       			Index:           entry.Index,
       			Term:            entry.Term,
       			Command:         entry.Command,
       			commandResponse: nil,
       		}
       	}
       	return stripped
}

// contains returns true if a log entry with the given index and term exists in
// the log.
// åˆ¤æ–­æ˜¯å¤ŸåŒ…å«{term, index}æ¡ç›®
func (l *raftLog) contains(index, term uint64) bool {
       	l.RLock()
       	defer l.RUnlock()

       	// It&#39;s not necessarily true that l.entries[i] has index == i.
       	for _, entry := range l.entries {
       		if entry.Index == index &amp;amp;&amp;amp; entry.Term == term {
       			return true
       		}
       		if entry.Index &amp;gt; index || entry.Term &amp;gt; term {
       			break
       		}
       	}
       	return false
}

// åˆ¤æ–­{term, index}æ˜¯å¦ä¸ºæœ€æ–°çš„æ—¥å¿—æ¡ç›®ï¼Œå¦‚æœæ˜¯,åˆ™å°†åˆ™å°†åœ¨å…¶ä¹‹åçš„æ—¥å¿—æ¸…ç†æ‰,
// è¿™ä¸ªæ¡ç›®åº”è¯¥åœ¨[commit_index, last_index]èŒƒå›´å†…
func (l *raftLog) ensureLastIs(index, term uint64) error {
       	l.Lock()
       	defer l.Unlock()

       	// Taken loosely from benbjohnson&#39;s impl

       	if index &amp;lt; l.getCommitIndexWithLock() {
       		return errIndexTooSmall
       	}

       	if index &amp;gt; l.lastIndexWithLock() {
       		return errIndexTooBig
       	}

       	// It&#39;s possible that the passed index is 0. It means the leader has come to
       	// decide we need a complete log rebuild. Of course, that&#39;s only valid if we
       	// haven&#39;t committed anything, so this check comes after that one.
  		// å…¨éƒ¨é‡å»ºï¼Œå‰ææ˜¯æ²¡æœ‰commitedè¿‡ä»»ä½•çš„æ¡ç›®
       	if index == 0 {
       		for pos := 0; pos &amp;lt; len(l.entries); pos++ {
       			if l.entries[pos].commandResponse != nil {
       				close(l.entries[pos].commandResponse)
       				l.entries[pos].commandResponse = nil
       			}
       			if l.entries[pos].committed != nil {
       				l.entries[pos].committed &amp;lt;- false
       				close(l.entries[pos].committed)
       				l.entries[pos].committed = nil
       			}
       		}
       		l.entries = []logEntry{}
       		return nil
       	}

       	// Normal case: find the position of the matching log entry.
       	pos := 0
       	for ; pos &amp;lt; len(l.entries); pos++ {
       		if l.entries[pos].Index &amp;lt; index {
       			continue // didn&#39;t find it yet
       		}
       		if l.entries[pos].Index &amp;gt; index {
       			return errBadIndex // somehow went past it
       		}
       		if l.entries[pos].Index != index {
       			panic(&amp;quot;not &amp;lt;, not &amp;gt;, but somehow !=&amp;quot;)
       		}
       		if l.entries[pos].Term != term {
       			return errBadTerm
       		}
       		break // good
       	}

       	// Sanity check.
        // ? æ€ä¹ˆå¯èƒ½å‡ºç°è¿™ç§æƒ…å†µï¼Ÿ
       	if pos &amp;lt; l.commitPos {
       		panic(&amp;quot;index &amp;gt;= commitIndex, but pos &amp;lt; commitPos&amp;quot;)
       	}

       	// `pos` is the position of log entry matching index and term.
       	// We want to truncate everything after that.
  		// åº”ä¸º{term, index}æ˜¯æœ€æ–°çš„äº†ï¼Œæ‰€ä»¥å°†åœ¨å…¶ä¹‹åçš„æ‰€æœ‰æ¡ç›®ç»™cutæ‰
       	truncateFrom := pos + 1
       	if truncateFrom &amp;gt;= len(l.entries) {
       		return nil // nothing to truncate
       	}

       	// If we blow away log entries that haven&#39;t yet sent responses to clients,
       	// signal the clients to stop waiting, by closing the channel without a
       	// response value.
       	for pos = truncateFrom; pos &amp;lt; len(l.entries); pos++ {
       		if l.entries[pos].commandResponse != nil {
       			close(l.entries[pos].commandResponse)
       			l.entries[pos].commandResponse = nil
       		}
       		if l.entries[pos].committed != nil {
       			l.entries[pos].committed &amp;lt;- false
       			close(l.entries[pos].committed)
       			l.entries[pos].committed = nil
       		}
       	}

       	// Truncate the log.
       	l.entries = l.entries[:truncateFrom]

       	// Done.
       	return nil
}

// getCommitIndex returns the commit index of the log. That is, the index of the
// last log entry which can be considered committed.
// è·å–æœ€æ–°çš„commitedæ—¥å¿—æ¡ç›®
func (l *raftLog) getCommitIndex() uint64 {
       	l.RLock()
       	defer l.RUnlock()
       	return l.getCommitIndexWithLock()
}

// è·å–æœ€æ–°çš„æ—¥å¿—æ¡ç›®
func (l *raftLog) getCommitIndexWithLock() uint64 {
       	if l.commitPos &amp;lt; 0 {
       		return 0
       	}
       	if l.commitPos &amp;gt;= len(l.entries) {
       		panic(fmt.Sprintf(&amp;quot;commitPos %d &amp;gt; len(l.entries) %d; bad bookkeeping in raftLog&amp;quot;, l.commitPos, len(l.entries)))
       	}
       	return l.entries[l.commitPos].Index
}

// lastIndex returns the index of the most recent log entry.
func (l *raftLog) lastIndex() uint64 {
       	l.RLock()
       	defer l.RUnlock()
       	return l.lastIndexWithLock()
}

func (l *raftLog) lastIndexWithLock() uint64 {
       	if len(l.entries) &amp;lt;= 0 {
       		return 0
       	}
       	return l.entries[len(l.entries)-1].Index
}

// lastTerm returns the term of the most recent log entry.
func (l *raftLog) lastTerm() uint64 {
       	l.RLock()
       	defer l.RUnlock()
       	return l.lastTermWithLock()
}

func (l *raftLog) lastTermWithLock() uint64 {
       	if len(l.entries) &amp;lt;= 0 {
       		return 0
       	}
       	return l.entries[len(l.entries)-1].Term
}

// appendEntry appends the passed log entry to the log. It will return an error
// if the entry&#39;s term is smaller than the log&#39;s most recent term, or if the
// entry&#39;s index is too small relative to the log&#39;s most recent entry.
// è¿½åŠ æ—¥å¿—ï¼Œæ³¨æ„æ­¤æ—¶è¿˜æ²¡æœ‰commitè¯¥æ¡ç›®
func (l *raftLog) appendEntry(entry logEntry) error {
       	l.Lock()
       	defer l.Unlock()
  		// åˆ¤å®š{entry.term, entry.index} &amp;gt; {last_term, last_index}
       	if len(l.entries) &amp;gt; 0 {
       		lastTerm := l.lastTermWithLock()
       		if entry.Term &amp;lt; lastTerm {
       			return errTermTooSmall
       		}
       		lastIndex := l.lastIndexWithLock()
       		if entry.Term == lastTerm &amp;amp;&amp;amp; entry.Index &amp;lt;= lastIndex {
       			return errIndexTooSmall
       		}
       	}

       	l.entries = append(l.entries, entry)
       	return nil
}

// commitTo commits all log entries up to and including the passed commitIndex.
// Commit means: synchronize the log entry to persistent storage, and call the
// state machine apply function for the log entry&#39;s command.
// æ³¨æ„:
// 1ã€commitæ˜¯ä¸€ä¸ªåç«¯ä»»åŠ¡ï¼Œå†æ­¤å¹¶æ²¡æœ‰&amp;quot;1/2&amp;quot;ç¡®è®¤çš„æ¦‚å¿µ(å®é™…ä¸Šæ˜¯ä¸æ˜¯è¿™æ ·å‘¢ï¼Œè¿™å¾—å»å‚è€ƒraftçš„è®ºæ–‡äº†)
// 2ã€applyå‡½æ•°æ˜¯åœ¨commitè¿‡ç¨‹ä¸­è°ƒç”¨ï¼Œè€Œä¸æ˜¯åœ¨appendçš„æ—¶å€™è°ƒç”¨
// 3ã€applyç›¸å½“äºçŠ¶æ€æœºå‡½æ•°ï¼Œä¸€èˆ¬ç”¨æˆ·ä¼šå°†è¿™äº›æ“ä½œç»“æœä¿å­˜èµ·æ¥ï¼Œç”¨äºå¿«ç…§

// æ¯”å¦‚ï¼Œæƒ³å®ç°ä¸€ä¸ªkvå­˜å‚¨ï¼Œé‚£ä¹ˆç”¨æˆ·åªè¦å°†kvç›¸å…³çš„é€»è¾‘æ¤å…¥è¿™ä¸ªå‡½æ•°å³å¯

// committed &amp;lt;= commitIndex &amp;lt;= last_index
func (l *raftLog) commitTo(commitIndex uint64) error {
       	if commitIndex == 0 {
       		panic(&amp;quot;commitTo(0)&amp;quot;)
       	}

       	l.Lock()
       	defer l.Unlock()

       	// Reject old commit indexes
       	if commitIndex &amp;lt; l.getCommitIndexWithLock() {
       		return errIndexTooSmall
       	}

       	// Reject new commit indexes
       	if commitIndex &amp;gt; l.lastIndexWithLock() {
       		return errIndexTooBig
       	}

       	// If we&#39;ve already committed to the commitIndex, great!
       	if commitIndex == l.getCommitIndexWithLock() {
       		return nil
       	}

       	// We should start committing at precisely the last commitPos + 1
       	pos := l.commitPos + 1
       	if pos &amp;lt; 0 {
       		panic(&amp;quot;pending commit pos &amp;lt; 0&amp;quot;)
       	}

       	// Commit entries between our existing commit index and the passed index.
       	// Remember to include the passed index.
       	for {
       		// Sanity checks. TODO replace with plain `for` when this is stable.
       		if pos &amp;gt;= len(l.entries) {
       			panic(fmt.Sprintf(&amp;quot;commitTo pos=%d advanced past all log entries (%d)&amp;quot;, pos, len(l.entries)))
       		}
       		if l.entries[pos].Index &amp;gt; commitIndex {
       			panic(&amp;quot;commitTo advanced past the desired commitIndex&amp;quot;)
       		}

       		// Encode the entry to persistent storage.
       		if err := l.entries[pos].encode(l.store); err != nil {
       			return err
       		}

       		// Forward non-configuration commands to the state machine.
       		// Send the responses to the waiting client, if applicable.
       		// å¦‚æœä¸æ˜¯é…ç½®ç±»å‹çš„Logï¼Œåˆ™è°ƒç”¨apply function
       		// é…ç½®ç±»å‹çš„Logï¼Œåœ¨å…¶ä»–åœ°æ–¹å¤„ç†
       		if !l.entries[pos].isConfiguration {
       			resp := l.apply(l.entries[pos].Index, l.entries[pos].Command)
       			if l.entries[pos].commandResponse != nil {
       				select {
       				case l.entries[pos].commandResponse &amp;lt;- resp:
       					break
				    // é—®ä»€ä¹ˆé€‰å–è¿™ä¸ªæ—¶é—´ï¼Ÿï¼Ÿï¼Ÿ
       				case &amp;lt;-time.After(maximumElectionTimeout()): // &amp;lt;&amp;lt; ElectionInterval
       					panic(&amp;quot;uncoÃ¶perative command response receiver&amp;quot;)
       				}
       				close(l.entries[pos].commandResponse)
       				l.entries[pos].commandResponse = nil
       			}
       		}

       		// Signal the entry has been committed, if applicable.
       		if l.entries[pos].committed != nil {
       			l.entries[pos].committed &amp;lt;- true
       			close(l.entries[pos].committed)
       			l.entries[pos].committed = nil
       		}

       		// Mark our commit position cursor.
       		l.commitPos = pos

       		// If that was the last one, we&#39;re done.
       		if l.entries[pos].Index == commitIndex {
       			break
       		}
       		if l.entries[pos].Index &amp;gt; commitIndex {
       			panic(fmt.Sprintf(
       				&amp;quot;current entry Index %d is beyond our desired commitIndex %d&amp;quot;,
       				l.entries[pos].Index,
       				commitIndex,
       			))
       		}

       		// Otherwise, advance!
       		pos++
       	}

       	// Done.
       	return nil
}

// logEntry is the atomic unit being managed by the distributed log. A log entry
// always has an index (monotonically increasing), a term in which the Raft
// network leader first sees the entry, and a command. The command is what gets
// executed against the node state machine when the log entry is successfully
// replicated.
type logEntry struct {
  		// æ—¥å¿—ç´¢å¼•å·
       	Index           uint64        `json:&amp;quot;index&amp;quot;`
       	// ä»»æœŸå·
  		Term            uint64        `json:&amp;quot;term&amp;quot;` // when received by leader
  		// æ—¥å¿—å†…å®¹
       	Command         []byte        `json:&amp;quot;command,omitempty&amp;quot;`
  		// commited é€šé“
       	committed       chan bool     `json:&amp;quot;-&amp;quot;`
  		// å‘½ä»¤åº”ç­” é€šé“
       	commandResponse chan&amp;lt;- []byte `json:&amp;quot;-&amp;quot;` // only non-nil on receiver&#39;s log
  		// æ—¥å¿—ç±»å‹æ ‡ç¤º
       	isConfiguration bool          `json:&amp;quot;-&amp;quot;` // for configuration change entries
}

// encode serializes the log entry to the passed io.Writer.
//
// Entries are serialized in a simple binary format:
//
//     		 ---------------------------------------------
//     		| uint32 | uint64 | uint64 | uint32 | []byte  |
//     		 ---------------------------------------------
//     		| CRC    | TERM   | INDEX  | SIZE   | COMMAND |
//     		 ---------------------------------------------
//

// åºåˆ—åŒ–ï¼Œå¤§ç«¯
func (e *logEntry) encode(w io.Writer) error {
       	if len(e.Command) &amp;lt;= 0 {
       		return errNoCommand
       	}
       	if e.Index &amp;lt;= 0 {
       		return errBadIndex
       	}
       	if e.Term &amp;lt;= 0 {
       		return errBadTerm
       	}

       	commandSize := len(e.Command)
       	buf := make([]byte, 24+commandSize)

       	binary.LittleEndian.PutUint64(buf[4:12], e.Term)
       	binary.LittleEndian.PutUint64(buf[12:20], e.Index)
       	binary.LittleEndian.PutUint32(buf[20:24], uint32(commandSize))

       	copy(buf[24:], e.Command)

       	binary.LittleEndian.PutUint32(
       		buf[0:4],
       		crc32.ChecksumIEEE(buf[4:]),
       	)

       	_, err := w.Write(buf)
       	return err
}

// ååºåˆ—åŒ–
// decode deserializes one log entry from the passed io.Reader.
func (e *logEntry) decode(r io.Reader) error {
       	header := make([]byte, 24)

       	if _, err := r.Read(header); err != nil {
       		return err
       	}

       	command := make([]byte, binary.LittleEndian.Uint32(header[20:24]))

       	if _, err := r.Read(command); err != nil {
       		return err
       	}

       	crc := binary.LittleEndian.Uint32(header[:4])

       	check := crc32.NewIEEE()
       	check.Write(header[4:])
       	check.Write(command)

       	if crc != check.Sum32() {
       		return errInvalidChecksum
       	}

       	e.Term = binary.LittleEndian.Uint64(header[4:12])
       	e.Index = binary.LittleEndian.Uint64(header[12:20])
       	e.Command = command

       	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;peers-go&#34;&gt;Peers.go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	errTimeout = errors.New(&amp;quot;timeout&amp;quot;)
)
// peersä¸ºèŠ‚ç‚¹çš„ä¸€ä¸ªæŠ½è±¡ï¼Œå¯¹å¤–æä¾›äº†ä¸€äº›è®¿é—®æ¥å£ï¼Œ
// éœ€è¦æ³¨æ„çš„åœ°æ–¹æ˜¯peersçš„åºåˆ—åŒ–
type Peer interface {
  	// è¿”å›serveræ ‡ç¤º
	id() uint64
  	// æ—¥å¿—è¿½åŠ æ¥å£
	callAppendEntries(appendEntries) appendEntriesResponse
  	// æŠ•ç¥¨é€‰ä¸¾æ¥å£
	callRequestVote(requestVote) requestVoteResponse
  	// å‘½ä»¤è°ƒç”¨
	callCommand([]byte, chan&amp;lt;- []byte) error
  	// é›†ç¾¤é…ç½®å˜åŒ–æ¥å£
	callSetConfiguration(...Peer) error
}

// localPeer is the simplest kind of peer, mapped to a server in the
// same process-space. Useful for testing and demonstration; not so
// useful for networks of independent processes.
// æœ¬åœ°local peersï¼Œç”¨äºæµ‹è¯•ï¼Œä¸ç”¨ç»è¿‡ç½‘ç»œ
type localPeer struct {
	server *Server
}

func newLocalPeer(server *Server) *localPeer { return &amp;amp;localPeer{server} }

func (p *localPeer) id() uint64 { return p.server.id }

// è¿½åŠ æ—¥å¿—
func (p *localPeer) callAppendEntries(ae appendEntries) appendEntriesResponse {
	return p.server.appendEntries(ae)
}

// æŠ•ç¥¨é€‰ä¸¾
func (p *localPeer) callRequestVote(rv requestVote) requestVoteResponse {
	return p.server.requestVote(rv)
}

// å‘½ä»¤
// å®é™…è°ƒç”¨ä¸ºLeader
func (p *localPeer) callCommand(cmd []byte, response chan&amp;lt;- []byte) error {
	return p.server.Command(cmd, response)
}

// è®¾ç½®é…ç½®
func (p *localPeer) callSetConfiguration(peers ...Peer) error {
	return p.server.SetConfiguration(peers...)
}

// requestVoteTimeout issues the requestVote to the given peer.
// If no response is received before timeout, an error is returned.
// æŠ•ç¥¨
func requestVoteTimeout(p Peer, rv requestVote, timeout time.Duration) (requestVoteResponse, error) {
	c := make(chan requestVoteResponse, 1)
	go func() { c &amp;lt;- p.callRequestVote(rv) }()

	select {
	case resp := &amp;lt;-c:
		return resp, nil
	case &amp;lt;-time.After(timeout):
		return requestVoteResponse{}, errTimeout
	}
}

// peerMap is a collection of Peer interfaces. It provides some convenience
// functions for actions that should apply to multiple Peers.
type peerMap map[uint64]Peer

// makePeerMap constructs a peerMap from a list of peers.
func makePeerMap(peers ...Peer) peerMap {
	pm := peerMap{}
	for _, peer := range peers {
		pm[peer.id()] = peer
	}
	return pm
}

// explodePeerMap converts a peerMap into a slice of peers.
func explodePeerMap(pm peerMap) []Peer {
	a := []Peer{}
	for _, peer := range pm {
		a = append(a, peer)
	}
	return a
}

func (pm peerMap) except(id uint64) peerMap {
	except := peerMap{}
	for id0, peer := range pm {
		if id0 == id {
			continue
		}
		except[id0] = peer
	}
	return except
}

func (pm peerMap) count() int { return len(pm) }

// æ³•å®šäººæ•°
func (pm peerMap) quorum() int {
	switch n := len(pm); n {
	case 0, 1:
		return 1
	default:
		return (n / 2) + 1
	}
}

// requestVotes sends the passed requestVote RPC to every peer in Peers. It
// forwards responses along the returned requestVoteResponse channel. It makes
// the RPCs with a timeout of BroadcastInterval * 2 (chosen arbitrarily). Peers
// that don&#39;t respond within the timeout are retried forever. The retry loop
// stops only when all peers have responded, or a Cancel signal is sent via the
// returned canceler.
func (pm peerMap) requestVotes(r requestVote) (chan voteResponseTuple, canceler) {
	// &amp;quot;[A server entering the candidate stage] issues requestVote RPCs in
	// parallel to each of the other servers in the cluster. If the candidate
	// receives no response for an RPC, it reissues the RPC repeatedly until a
	// response arrives or the election concludes.&amp;quot;

	// construct the channels we&#39;ll return
	abortChan := make(chan struct{})
	tupleChan := make(chan voteResponseTuple)

	go func() {
		// We loop until all Peers have given us a response.
		// Track which Peers have responded.
		respondedAlready := peerMap{} // none yet

		for {
			notYetResponded := disjoint(pm, respondedAlready)
			if len(notYetResponded) &amp;lt;= 0 {
				return // done
			}

			// scatter
			tupleChan0 := make(chan voteResponseTuple, len(notYetResponded))
			for id, peer := range notYetResponded {
				go func(id uint64, peer Peer) {
					resp, err := requestVoteTimeout(peer, r, 2*maximumElectionTimeout())
					tupleChan0 &amp;lt;- voteResponseTuple{id, resp, err}
				}(id, peer)
			}

			// gather
			for i := 0; i &amp;lt; cap(tupleChan0); i++ {
				select {
				case t := &amp;lt;-tupleChan0:
					if t.err != nil {
						continue // will need to retry
					}
					respondedAlready[t.id] = nil // set membership semantics
					tupleChan &amp;lt;- t

				case &amp;lt;-abortChan:
					return // give up
				}
			}
		}
	}()

	return tupleChan, cancel(abortChan)
}

// é€‰ä¸¾åº”ç­”
type voteResponseTuple struct {
	id       uint64
	response requestVoteResponse
	err      error
}

type canceler interface {
	Cancel()
}

type cancel chan struct{}

func (c cancel) Cancel() { close(c) }

// è¿‡æ»¤peers
func disjoint(all, except peerMap) peerMap {
	d := peerMap{}
	for id, peer := range all {
		if _, ok := except[id]; ok {
			continue
		}
		d[id] = peer
	}
	return d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;server-go&#34;&gt;server.go&lt;/h3&gt;

&lt;p&gt;è¿™æ˜¯æœ€é‡è¦çš„ä¸€ä¸ªé€»è¾‘&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/raft-consensus-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;èŠ‚ç‚¹é…ç½®å˜æ›´&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/raft-state.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// è§’è‰²åˆ†ç±»  
const (
	follower  = &amp;quot;Follower&amp;quot;
	candidate = &amp;quot;Candidate&amp;quot;
	leader    = &amp;quot;Leader&amp;quot;
)

const (
	unknownLeader = 0
	noVote        = 0
)

// é€‰ä¸¾æ—¶é—´éšæœºèŒƒå›´[MinimumElectionTimeoutMS, maximumElectionTimeoutMS]
var (
	MinimumElectionTimeoutMS int32 = 250

	maximumElectionTimeoutMS = 2 * MinimumElectionTimeoutMS
)

var (
	errNotLeader             = errors.New(&amp;quot;not the leader&amp;quot;)
	errUnknownLeader         = errors.New(&amp;quot;unknown leader&amp;quot;)
	errDeposed               = errors.New(&amp;quot;deposed during replication&amp;quot;)
	errAppendE#008000ntriesRejected = errors.New(&amp;quot;appendEntries RPC rejected&amp;quot;)
	errReplicationFailed     = errors.New(&amp;quot;command replication failed (but will keep retrying)&amp;quot;)
	errOutOfSync             = errors.New(&amp;quot;out of sync&amp;quot;)
	errAlreadyRunning        = errors.New(&amp;quot;already running&amp;quot;)
)

// é‡ç½®é€‰ä¸¾æ—¶é—´
func resetElectionTimeoutMS(newMin, newMax int) (int, int) {
	oldMin := atomic.LoadInt32(&amp;amp;MinimumElectionTimeoutMS)
	oldMax := atomic.LoadInt32(&amp;amp;maximumElectionTimeoutMS)
	atomic.StoreInt32(&amp;amp;MinimumElectionTimeoutMS, int32(newMin))
	atomic.StoreInt32(&amp;amp;maximumElectionTimeoutMS, int32(newMax))
	return int(oldMin), int(oldMax)
}

// minimumElectionTimeout returns the current minimum election timeout.
func minimumElectionTimeout() time.Duration {
	return time.Duration(MinimumElectionTimeoutMS) * time.Millisecond
}

// maximumElectionTimeout returns the current maximum election time.
func maximumElectionTimeout() time.Duration {
	return time.Duration(maximumElectionTimeoutMS) * time.Millisecond
}

// é€‰ä¸¾æ—¶é—´éšæœºå‡½æ•°
func electionTimeout() time.Duration {
	n := rand.Intn(int(maximumElectionTimeoutMS - MinimumElectionTimeoutMS))
	d := int(MinimumElectionTimeoutMS) + n
	return time.Duration(d) * time.Millisecond
}

// broadcastInterval returns the interval between heartbeats (AppendEntry RPCs)
// broadcast from the leader. It is the minimum election timeout / 10, as
// dictated by the spec: BroadcastInterval &amp;lt;&amp;lt; ElectionTimeout &amp;lt;&amp;lt; MTBF.
// å¹¿æ’­æ—¶é—´ï¼Œç”¨äºLeaderå‘é€å¿ƒè·³å¹¿æ’­ï¼Œè¿™ä¸ªæ—¶é—´åº”å°äºé€‰ä¸¾æ—¶é—´ï¼›å¦åˆ™ï¼ŒéLeaderèŠ‚ç‚¹ä¼šäº§ç”Ÿé€‰ä¸¾æ“ä½œ
func broadcastInterval() time.Duration {
	d := MinimumElectionTimeoutMS / 10
	return time.Duration(d) * time.Millisecond
}

// protectedString is just a string protected by a mutex.
type protectedString struct {
	sync.RWMutex
	value string
}

func (s *protectedString) Get() string {
	s.RLock()
	defer s.RUnlock()
	return s.value
}

func (s *protectedString) Set(value string) {
	s.Lock()
	defer s.Unlock()
	s.value = value
}

// protectedBool is just a bool protected by a mutex.
type protectedBool struct {
	sync.RWMutex
	value bool
}

func (s *protectedBool) Get() bool {
	s.RLock()
	defer s.RUnlock()
	return s.value
}

func (s *protectedBool) Set(value bool) {
	s.Lock()
	defer s.Unlock()
	s.value = value
}

// Server is the agent that performs all of the Raft protocol logic.
// In a typical application, each running process that wants to be part of
// the distributed state machine will contain a server component.
type Server struct {
	id      uint64 // id of this server
    // èŠ‚ç‚¹çŠ¶æ€
	state   *protectedString
    // èŠ‚ç‚¹è¿è¡ŒçŠ¶æ€
	running *protectedBool
    // LeaderèŠ‚ç‚¹æ ‡ç¤º
	leader  uint64 
    // å½“å‰èŠ‚ç‚¹ä»»æœŸå·
	term    uint64 // &amp;quot;current term number, which increases monotonically&amp;quot;
    // 0è¡¨ç¤ºï¼Œå½“å‰èŠ‚ç‚¹è¿˜æœ‰æŠ•å‡ºè‡ªå·±çš„ç¥¨;
    // éé›¶è¡¨ç¤ºèŠ‚ç‚¹å·²ç»æŠ•ç¥¨äº†ï¼Œå€¼æ˜¯è·ç¥¨è€…çš„æ ‡ç¤ºID
	vote    uint64 // who we voted for this term, if applicable
	log     *raftLog
	config  *configuration

    // è¿½åŠ æ—¥å¿—ä¿¡é“
	appendEntriesChan chan appendEntriesTuple
  	// æŠ•ç¥¨ä¿¡é“
	requestVoteChan   chan requestVoteTuple
  	// å‘½ä»¤ä¿¡é“
	commandChan       chan commandTuple
  	// é…ç½®ä¿®æ”¹ä¿¡é“
	configurationChan chan configurationTuple

  	// é€‰ä¸¾ä¿¡é“
	electionTick &amp;lt;-chan time.Time
  	// é€€å‡ºä¿¡é“
	quit         chan chan struct{}
}

// çŠ¶æ€æœºå‡½æ•°
// è¯¥å‡½æ•°ä¸å¯å¹¶å‘æ‰§è¡Œï¼Œå¦åˆ™å°±è¾¾ä¸åˆ°ä¸€è‡´æ€§çŠ¶æ€æœºçš„æ•ˆæœ(æ‰§è¡Œæ—¶é—´ä¸è¦è¶…è¿‡é€‰ä¸¾æ—¶é—´)

// æ­£å¸¸æ¥è¯´ï¼Œåªæœ‰&amp;quot;å…±è¯†&amp;quot;è¾¾æˆçš„æ—¶å€™ï¼Œæ‰ä¼šè°ƒç”¨è¯¥å‡½æ•°ï¼Œç„¶åè¿”å›ç»™å®¢æˆ·ç«¯
// ä½†æ˜¯ï¼Œåœ¨è¿™é‡Œä¸ºäº†ç®€åŒ–å®ç°ï¼Œ&amp;quot;å…±è¯†â€œç®—æ³•æ˜¯æ”¾åœ¨åå°ä»»åŠ¡æ“ä½œçš„ï¼Œå®¢æˆ·ç«¯å‘é€å‘½ä»¤å•Leaderæ—¶ï¼ŒLeaderé©¬ä¸Š
// åº”ç­”å®¢æˆ·ç«¯ï¼Œå¹¶æ²¡æœ‰ç­‰â€å…±è¯†ç®—æ³•â€œçš„å…±è¯†ç»“æœ
type ApplyFunc func(commitIndex uint64, cmd []byte) []byte

// åˆå§‹åŒ–èŠ‚ç‚¹
// 1. æ„å»ºæ—¥å¿— 2.åˆå§‹åŒ–ä¸º&amp;quot;follower&amp;quot;è§’è‰² 3.leaderä¸º&amp;quot;unknown&amp;quot;
func NewServer(id uint64, store io.ReadWriter, a ApplyFunc) *Server {
	if id &amp;lt;= 0 {
		panic(&amp;quot;server id must be &amp;gt; 0&amp;quot;)
	}

	// 5.2 Leader election: &amp;quot;the latest term this server has seen is persisted,
	// and is initialized to 0 on first boot.&amp;quot;
	log := newRaftLog(store, a)
	latestTerm := log.lastTerm()

	s := &amp;amp;Server{
		id:      id,
		state:   &amp;amp;protectedString{value: follower}, // &amp;quot;when servers start up they begin as followers&amp;quot;
		running: &amp;amp;protectedBool{value: false},
		leader:  unknownLeader, // unknown at startup
		log:     log,
		term:    latestTerm,
		config:  newConfiguration(peerMap{}),

		appendEntriesChan: make(chan appendEntriesTuple),
		requestVoteChan:   make(chan requestVoteTuple),
		commandChan:       make(chan commandTuple),
		configurationChan: make(chan configurationTuple),

		electionTick: nil,
		quit:         make(chan chan struct{}),
	}
	s.resetElectionTimeout()
	return s
}

type configurationTuple struct {
	Peers []Peer
	Err   chan error
}

// è®¾ç½®é…ç½®
// 1. æœåŠ¡å¯åŠ¨æ—¶ï¼Œå…ˆè®¾ç½®é…ç½®
// 2. é›†ç¾¤å˜æ›´æ—¶ï¼Œè®¾ç½®é…ç½®
func (s *Server) SetConfiguration(peers ...Peer) error {
    // èŠ‚ç‚¹åˆšå¯åŠ¨
	if !s.running.Get() {
		s.config.directSet(makePeerMap(peers...))
		return nil
	}

	err := make(chan error)
    // èŠ‚ç‚¹å·²ç»å¯åŠ¨äº†
	s.configurationChan &amp;lt;- configurationTuple{peers, err}
	return &amp;lt;-err
}

// Start triggers the server to begin communicating with its peers.
func (s *Server) Start() {
	go s.loop()
}

// Stop terminates the server. Stopped servers should not be restarted.
func (s *Server) Stop() {
	q := make(chan struct{})
	s.quit &amp;lt;- q
	&amp;lt;-q
	s.logGeneric(&amp;quot;server stopped&amp;quot;)
}

// å‘½ä»¤å…ƒç»„
type commandTuple struct {
  	// å‘½ä»¤å†…å®¹
	Command         []byte
  	// å‘½ä»¤ä¿¡é“
	CommandResponse chan&amp;lt;- []byte
	Err             chan error
}

// å‘½ä»¤æ¥å£
func (s *Server) Command(cmd []byte, response chan&amp;lt;- []byte) error {
	err := make(chan error)
	s.commandChan &amp;lt;- commandTuple{cmd, response, err}
	return &amp;lt;-err
}

// æ—¥å¿—è¿½åŠ 
func (s *Server) appendEntries(ae appendEntries) appendEntriesResponse {
	t := appendEntriesTuple{
		Request:  ae,
		Response: make(chan appendEntriesResponse),
	}
	s.appendEntriesChan &amp;lt;- t
	return &amp;lt;-t.Response
}

// æŠ•ç¥¨
func (s *Server) requestVote(rv requestVote) requestVoteResponse {
	t := requestVoteTuple{
		Request:  rv,
		Response: make(chan requestVoteResponse),
	}
	s.requestVoteChan &amp;lt;- t
	return &amp;lt;-t.Response
}

//                                  times out,
//                                 new election
//     |                             .-----.
//     |                             |     |
//     v         times out,          |     v     receives votes from
// +----------+  starts election  +-----------+  majority of servers  +--------+
// | Follower |------------------&amp;gt;| Candidate |----------------------&amp;gt;| Leader |
// +----------+                   +-----------+                       +--------+
//     ^ ^                              |                                 |
//     | |    discovers current leader  |                                 |
//     | |                 or new term  |                                 |
//     | &#39;------------------------------&#39;                                 |
//     |                                                                  |
//     |                               discovers server with higher term  |
//     &#39;------------------------------------------------------------------&#39;
//
//

func (s *Server) loop() {
	s.running.Set(true)
	for s.running.Get() {
		switch state := s.state.Get(); state {
		case follower:
			s.followerSelect()
		case candidate:
			s.candidateSelect()
		case leader:
			s.leaderSelect()
		default:
			panic(fmt.Sprintf(&amp;quot;unknown Server State &#39;%s&#39;&amp;quot;, state))
		}
	}
}

func (s *Server) resetElectionTimeout() {
	s.electionTick = time.NewTimer(electionTimeout()).C
}

func (s *Server) logGeneric(format string, args ...interface{}) {
	prefix := fmt.Sprintf(&amp;quot;id=%d term=%d state=%s: &amp;quot;, s.id, s.term, s.state.Get())
	log.Printf(prefix+format, args...)
}

func (s *Server) logAppendEntriesResponse(req appendEntries, resp appendEntriesResponse, stepDown bool) {
	s.logGeneric(
		&amp;quot;got appendEntries, sz=%d leader=%d prevIndex/Term=%d/%d commitIndex=%d: responded with success=%v (reason=&#39;%s&#39;) stepDown=%v&amp;quot;,
		len(req.Entries),
		req.LeaderID,
		req.PrevLogIndex,
		req.PrevLogTerm,
		req.CommitIndex,
		resp.Success,
		resp.reason,
		stepDown,
	)
}

func (s *Server) logRequestVoteResponse(req requestVote, resp requestVoteResponse, stepDown bool) {
	s.logGeneric(
		&amp;quot;got RequestVote, candidate=%d: responded with granted=%v (reason=&#39;%s&#39;) stepDown=%v&amp;quot;,
		req.CandidateID,
		resp.VoteGranted,
		resp.reason,
		stepDown,
	)
}

func (s *Server) handleQuit(q chan struct{}) {
	s.logGeneric(&amp;quot;got quit signal&amp;quot;)
	s.running.Set(false)
	close(q)
}

// å‘½ä»¤è½¬å‘
// å¦‚æœå½“å‰èŠ‚ç‚¹ä¸æ˜¯LeaderèŠ‚ç‚¹ï¼Œå¹¶ä¸”å·²å­˜åœ¨LeaderèŠ‚ç‚¹ï¼Œåˆ™å…¶ä¼šä»¥&amp;quot;ä»£ç†â€œçš„è§’è‰²ï¼Œå°†å‘½ä»¤è½¬å‘è‡³LeaderèŠ‚ç‚¹
func (s *Server) forwardCommand(t commandTuple) {
	switch s.leader {
	case unknownLeader:
		s.logGeneric(&amp;quot;got command, but don&#39;t know leader&amp;quot;)
		t.Err &amp;lt;- errUnknownLeader

	case s.id: // I am the leader
		panic(&amp;quot;impossible state in forwardCommand&amp;quot;)

	default:
		leader, ok := s.config.get(s.leader)
		if !ok {
			panic(&amp;quot;invalid state in peers&amp;quot;)
		}
		s.logGeneric(&amp;quot;got command, forwarding to leader (%d)&amp;quot;, s.leader)
		// We&#39;re blocking our {follower,candidate}Select function in the
		// receive-command branch. If we continue to block while forwarding
		// the command, the leader won&#39;t be able to get a response from us!
		go func() { t.Err &amp;lt;- leader.callCommand(t.Command, t.CommandResponse) }()
	}
}

// é…ç½®å˜æ›´
// è½¬å‘è§„åˆ™å’Œå‘½ä»¤è½¬å‘ä¸€æ ·
func (s *Server) forwardConfiguration(t configurationTuple) {
	switch s.leader {
	case unknownLeader:
		s.logGeneric(&amp;quot;got configuration, but don&#39;t know leader&amp;quot;)
		t.Err &amp;lt;- errUnknownLeader

	case s.id: // I am the leader
		panic(&amp;quot;impossible state in forwardConfiguration&amp;quot;)

	default:
		leader, ok := s.config.get(s.leader)
		if !ok {
			panic(&amp;quot;invalid state in peers&amp;quot;)
		}
		s.logGeneric(&amp;quot;got configuration, forwarding to leader (%d)&amp;quot;, s.leader)
		go func() { t.Err &amp;lt;- leader.callSetConfiguration(t.Peers...) }()
	}
}

// follower èŠ‚ç‚¹é€»è¾‘
func (s *Server) followerSelect() {
	for {
		select {
		case q := &amp;lt;-s.quit:
			s.handleQuit(q)
			return
		// å‘½ä»¤è½¬å‘
		case t := &amp;lt;-s.commandChan:
			s.forwardCommand(t)
		// é›†ç¾¤å˜æ›´è½¬å‘
		case t := &amp;lt;-s.configurationChan:
			s.forwardConfiguration(t)
		// Leaderé€‰ä¸¾
		case &amp;lt;-s.electionTick:
			// 5.2 Leader election: &amp;quot;A follower increments its current term and
			// transitions to candidate state.&amp;quot;
			if s.config == nil {
				s.logGeneric(&amp;quot;election timeout, but no configuration: ignoring&amp;quot;)
				s.resetElectionTimeout()
				continue
			}
			s.logGeneric(&amp;quot;election timeout, becoming candidate&amp;quot;)
          	// æé«˜è‡ªå·±çš„ä»»æœŸå·
			s.term++
          	// æŠ•ç¥¨ç½®ä¸ºç©º
			s.vote = noVote
          	// Leader 
			s.leader = unknownLeader
          	// è®¾ç½®èŠ‚ç‚¹è§’è‰²ä¸º&amp;quot;å€™é€‰äºº&amp;quot;
			s.state.Set(candidate)
          	// é‡ç½®é€‰ä¸¾æ—¶é—´ï¼Œé˜²æ­¢é©¬ä¸Šå†æ¬¡å‡ºå‘é€‰ä¸¾
			s.resetElectionTimeout()
			return
        // æ—¥å¿—è¿½åŠ (é™¤äº†å®¢æˆ·ç«¯è¯·æ±‚ï¼Œleaderçš„å¿ƒè·³ä¹Ÿä¼šå‡ºå‘è¿™ä¸ªè¡Œä¸º)
		case t := &amp;lt;-s.appendEntriesChan:
			if s.leader == unknownLeader {
				s.leader = t.Request.LeaderID
				s.logGeneric(&amp;quot;discovered Leader %d&amp;quot;, s.leader)
			}
          	// å¤„ç†æ—¥å¿—æœ€ä½³æ“ä½œ
			resp, stepDown := s.handleAppendEntries(t.Request)
			s.logAppendEntriesResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
          	// å¦‚æœèŠ‚ç‚¹å·²ç»è„±ç¦»äº†å½“å‰çš„é›†ç¾¤ï¼Œéœ€è¦è·Ÿæ–°Leaderåœ°å€
			if stepDown {
				// stepDown as a Follower means just to reset the leader
				if s.leader != unknownLeader {
					s.logGeneric(&amp;quot;abandoning old leader=%d&amp;quot;, s.leader)
				}
				s.logGeneric(&amp;quot;following new leader=%d&amp;quot;, t.Request.LeaderID)
				s.leader = t.Request.LeaderID
			}
		// é€‰ä¸¾
		case t := &amp;lt;-s.requestVoteChan:
          	// é€‰ä¸¾å¤„ç†
			resp, stepDown := s.handleRequestVote(t.Request)
			s.logRequestVoteResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
          	// å¦‚æœè½åäºå½“å‰èŠ‚ç‚¹äº†ï¼ŒæŠŠå½“å‰çš„Leaderä¿®æ”¹ä¸º&amp;quot;unkownleader&amp;quot;ï¼Œç­‰å¾…è®¯æ®æˆåŠŸåï¼Œè¿›è¡Œåˆ‡æ¢
			if stepDown {
				// stepDown as a Follower means just to reset the leader
				if s.leader != unknownLeader {
					s.logGeneric(&amp;quot;abandoning old leader=%d&amp;quot;, s.leader)
				}
				s.logGeneric(&amp;quot;new leader unknown&amp;quot;)
				s.leader = unknownLeader
			}
		}
	}
}

// å€™é€‰çŠ¶æ€
func (s *Server) candidateSelect() {
	if s.leader != unknownLeader {
		panic(&amp;quot;known leader when entering candidateSelect&amp;quot;)
	}
	if s.vote != 0 {
		panic(&amp;quot;existing vote when entering candidateSelect&amp;quot;)
	}

	// &amp;quot;[A server entering the candidate stage] issues requestVote RPCs in
	// parallel to each of the other servers in the cluster. If the candidate
	// receives no response for an RPC, it reissues the RPC repeatedly until a
	// response arrives or the election concludes.&amp;quot;
	// å‘èµ·é€‰ä¸¾RPC
	requestVoteResponses, canceler := s.config.allPeers().except(s.id).requestVotes(requestVote{
		Term:         s.term,
		CandidateID:  s.id,
		LastLogIndex: s.log.lastIndex(),
		LastLogTerm:  s.log.lastTerm(),
	})
	defer canceler.Cancel()

	// Set up vote tallies (plus, vote for myself)
	votes := map[uint64]bool{s.id: true}
	s.vote = s.id
	s.logGeneric(&amp;quot;term=%d election started (configuration state %s)&amp;quot;, s.term, s.config.state)

	// å¦‚æœå·²ç»è¾¾åˆ°äº†é€‰ä¸¾â€œå…±è¯†â€ï¼Œåˆ™æˆåŠŸé€‰ä¸¾
	if s.config.pass(votes) {
		s.logGeneric(&amp;quot;I immediately won the election&amp;quot;)
		s.leader = s.id
		s.state.Set(leader)
		s.vote = noVote
		return
	}

	// &amp;quot;A candidate continues in this state until one of three things happens:
	// (a) it wins the election, (b) another server establishes itself as
	// leader, or (c) a period of time goes by with no winner.&amp;quot;
	for {
		select {
		case q := &amp;lt;-s.quit:
			s.handleQuit(q)
			return
		// å‘½ä»¤è½¬å‘
		case t := &amp;lt;-s.commandChan:
			s.forwardCommand(t)
		// é…ç½®æ›´æ–°è½¬å‘ï¼Œæ³¨æ„å’ŒLeaderçš„ä¸åŒ
		case t := &amp;lt;-s.configurationChan:
			s.forwardConfiguration(t)
		// æ”¶åˆ°é€‰ä¸¾çš„åº”ç­”
		case t := &amp;lt;-requestVoteResponses:
			s.logGeneric(&amp;quot;got vote: id=%d term=%d granted=%v&amp;quot;, t.id, t.response.Term, t.response.VoteGranted)
			// &amp;quot;A candidate wins the election if it receives votes from a
			// majority of servers in the full cluster for the same term.&amp;quot;
          	// æœ¬èŠ‚ç‚¹è½åäºå…¶ä»–å‡ ç‚¹
			if t.response.Term &amp;gt; s.term {
				s.logGeneric(&amp;quot;got vote from future term (%d&amp;gt;%d); abandoning election&amp;quot;, t.response.Term, s.term)
				s.leader = unknownLeader
				s.state.Set(follower)
				s.vote = noVote
				return // lose
			}
          	// æ”¶åˆ°äº†&amp;quot;è½å&amp;quot;å½“å‰èŠ‚ç‚¹çš„åº”ç­”ï¼Œå¿½ç•¥æ‰å®ƒ
			if t.response.Term &amp;lt; s.term {
				s.logGeneric(&amp;quot;got vote from past term (%d&amp;lt;%d); ignoring&amp;quot;, t.response.Term, s.term)
				break
			}
          	
          	// æ”¶åˆ°èµåŒç¥¨
			if t.response.VoteGranted {
				s.logGeneric(&amp;quot;%d voted for me&amp;quot;, t.id)
				votes[t.id] = true
			}
			// &amp;quot;Once a candidate wins an election, it becomes leader.&amp;quot;
          	// â€œå…±è¯†â€è¾¾æˆ
			if s.config.pass(votes) {
				s.logGeneric(&amp;quot;I won the election&amp;quot;)
				s.leader = s.id
				s.state.Set(leader)
				s.vote = noVote
				return // win
			}
          // æ”¶åˆ°æ—¥å¿—è¿½åŠ (åœ¨è¿™é‡Œï¼Œå¿ƒè·³ä¹Ÿå½“åšæ—¥å¿—è¿½åŠ çš„æ–¹å¼å‘é€)
		case t := &amp;lt;-s.appendEntriesChan:
			// &amp;quot;While waiting for votes, a candidate may receive an
			// appendEntries RPC from another server claiming to be leader.
			// If the leader&#39;s term (included in its RPC) is at least as
			// large as the candidate&#39;s current term, then the candidate
			// recognizes the leader as legitimate and steps down, meaning
			// that it returns to follower state.&amp;quot;
            // å¤„ç†æ—¥å¿—
			resp, stepDown := s.handleAppendEntries(t.Request)
			s.logAppendEntriesResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
          	// candidateèŠ‚ç‚¹è½åäºLeaderèŠ‚ç‚¹
			if stepDown {
				s.logGeneric(&amp;quot;after an appendEntries, stepping down to Follower (leader=%d)&amp;quot;, t.Request.LeaderID)
				s.leader = t.Request.LeaderID
				s.state.Set(follower)
				return // lose
			}

        // è™½ç„¶å½“å‰èŠ‚ç‚¹æ˜¯candidateèŠ‚ç‚¹ï¼Œä½†é›†ç¾¤ä¸­æ­¤æ—¶å¯èƒ½å­˜åœ¨å¤šä¸ªcandidateèŠ‚ç‚¹
		case t := &amp;lt;-s.requestVoteChan:
			// We can also be defeated by a more recent candidate
			resp, stepDown := s.handleRequestVote(t.Request)
			s.logRequestVoteResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
			if stepDown {
              	// å½“å‰candidateèŠ‚ç‚¹è½åäºé›†ç¾¤ä¸­å·²å­˜åœ¨çš„candidateèŠ‚ç‚¹ï¼Œå°†è‡ªå·±çš„è§’è‰²å˜ä¸ºfollowerï¼Œ
              	// å¹¶ä¸”ä¹Ÿä¼šæŠ•èµåŒç¥¨
				s.logGeneric(&amp;quot;after a requestVote, stepping down to Follower (leader unknown)&amp;quot;)
				s.leader = unknownLeader
				s.state.Set(follower)
				return // lose
			}
		
        // é€‰ä¸¾
		case &amp;lt;-s.electionTick:
			// &amp;quot;The third possible outcome is that a candidate neither wins nor
			// loses the election: if many followers become candidates at the
			// same time, votes could be split so that no candidate obtains a
			// majority. When this happens, each candidate will start a new
			// election by incrementing its term and initiating another round of
			// requestVote RPCs.&amp;quot;
			s.logGeneric(&amp;quot;election ended with no winner; incrementing term and trying again&amp;quot;)
			s.resetElectionTimeout()
			s.term++
			s.vote = noVote
			return // draw
		}
	}
}

// Leader ä¿å­˜çš„FollowerèŠ‚ç‚¹çš„æ‰€æœ‰æœ€æ–°åŒæ­¥æ¡ç›®
type nextIndex struct {
	sync.RWMutex
	m map[uint64]uint64 // followerId: nextIndex
}

func newNextIndex(pm peerMap, defaultNextIndex uint64) *nextIndex {
	ni := &amp;amp;nextIndex{
		m: map[uint64]uint64{},
	}
	for id := range pm {
		ni.m[id] = defaultNextIndex
	}
	return ni
}

// æ‰¾å‡ºå·²ç»åŒæ­¥Followerçš„æœ€å°æ—¥å¿—
func (ni *nextIndex) bestIndex() uint64 {
	ni.RLock()
	defer ni.RUnlock()

	if len(ni.m) &amp;lt;= 0 {
		return 0
	}

	i := uint64(math.MaxUint64)
	for _, nextIndex := range ni.m {
		if nextIndex &amp;lt; i {
			i = nextIndex
		}
	}
	return i
}

// è¿”å›èŠ‚ç‚¹(id)æœ€æ–°çš„åŒæ­¥æ—¥å¿—
func (ni *nextIndex) prevLogIndex(id uint64) uint64 {
	ni.RLock()
	defer ni.RUnlock()
	if _, ok := ni.m[id]; !ok {
		panic(fmt.Sprintf(&amp;quot;peer %d not found&amp;quot;, id))
	}
	return ni.m[id]
}

// è‡ªå‡èŠ‚ç‚¹(id)çš„æœ€æ–°åŒæ­¥æ—¥å¿—ï¼Œç”¨äºåŒæ­¥å¤±è´¥æ—¶çš„å›æ»š
func (ni *nextIndex) decrement(id uint64, prev uint64) (uint64, error) {
	ni.Lock()
	defer ni.Unlock()

	i, ok := ni.m[id]
	if !ok {
		panic(fmt.Sprintf(&amp;quot;peer %d not found&amp;quot;, id))
	}

	if i != prev {
		return i, errOutOfSync
	}

	if i &amp;gt; 0 {
		ni.m[id]--
	}
	return ni.m[id], nil
}

// æ›´æ–°èŠ‚ç‚¹(id)çš„åŒæ­¥æ—¥å¿—
func (ni *nextIndex) set(id, index, prev uint64) (uint64, error) {
	ni.Lock()
	defer ni.Unlock()

	i, ok := ni.m[id]
	if !ok {
		panic(fmt.Sprintf(&amp;quot;peer %d not found&amp;quot;, id))
	}
	if i != prev {
		return i, errOutOfSync
	}

	ni.m[id] = index
	return index, nil
}

// å¿ƒè·³ã€å¤åˆ¶å‘½ä»¤éƒ½ä¼šç”¨åˆ°è¯¥å‡½æ•°ï¼Œflushæ˜¯åŒæ­¥çš„ï¼Œå¦‚æœå¯¹ç«¯èŠ‚ç‚¹ä¸å¯è¾¾ï¼Œåˆ™é˜»å¡
func (s *Server) flush(peer Peer, ni *nextIndex) error {
	peerID := peer.id()
	// Leaderçš„ä»»æœŸå·
	currentTerm := s.term
	// èŠ‚ç‚¹(peer)çš„æœ€æ–°åŒæ­¥ç´¢å¼•
	prevLogIndex := ni.prevLogIndex(peerID)
	// æ£€ç´¢å‡ºpeersèŠ‚ç‚¹è½åäºLeaderå‡ ç‚¹çš„æ—¥å¿—æ¡ç›®ï¼Œç„¶åè¿›è¡ŒåŒæ­¥
	entries, prevLogTerm := s.log.entriesAfter(prevLogIndex)
	// è·å–Leader committedçš„æœ€æ–°ç´¢å¼•
	commitIndex := s.log.getCommitIndex()
	s.logGeneric(&amp;quot;flush to %d: term=%d leaderId=%d prevLogIndex/Term=%d/%d sz=%d commitIndex=%d&amp;quot;, peerID, currentTerm, s.id, prevLogIndex, prevLogTerm, len(entries), commitIndex)
	
	// æ—¥å¿—è¿½åŠ RPC
	resp := peer.callAppendEntries(appendEntries{
		Term:         currentTerm,
		LeaderID:     s.id,
		PrevLogIndex: prevLogIndex,
		PrevLogTerm:  prevLogTerm,
		Entries:      entries,
		CommitIndex:  commitIndex,
	})

	if resp.Term &amp;gt; currentTerm {
		// åº”ç­”çš„èŠ‚ç‚¹æ¯”å½“å‰èŠ‚ç‚¹çš„ä»»æœŸå·å¤§ï¼Œå½“å‰çš„Leaderè¢«ç½¢å…
		s.logGeneric(&amp;quot;flush to %d: responseTerm=%d &amp;gt; currentTerm=%d: deposed&amp;quot;, peerID, resp.Term, currentTerm)
		return errDeposed
	}

	
	if !resp.Success {
		// åº”ç­”å¤±è´¥ï¼Œå¯èƒ½æ˜¯leader RPCç­‰å¾…è¶…æ—¶ï¼Œæˆ–è€…å‡ºç°äº†ç½‘ç»œé”™è¯¯(åŒ…æ‹¬è„‘è£‚)ï¼Œå›æ»š
		newPrevLogIndex, err := ni.decrement(peerID, prevLogIndex)
		if err != nil {
			s.logGeneric(&amp;quot;flush to %d: while decrementing prevLogIndex: %s&amp;quot;, peerID, err)
			return err
		}
		s.logGeneric(&amp;quot;flush to %d: rejected; prevLogIndex(%d) becomes %d&amp;quot;, peerID, peerID, newPrevLogIndex)
		return errAppendEntriesRejected
	}

	if len(entries) &amp;gt; 0 {
		// å¤åˆ¶æˆåŠŸï¼Œæ›´æ–°åŒæ­¥çŠ¶æ€
		newPrevLogIndex, err := ni.set(peer.id(), entries[len(entries)-1].Index, prevLogIndex)
		if err != nil {
			s.logGeneric(&amp;quot;flush to %d: while moving prevLogIndex forward: %s&amp;quot;, peerID, err)
			return err
		}
		s.logGeneric(&amp;quot;flush to %d: accepted; prevLogIndex(%d) becomes %d&amp;quot;, peerID, peerID, newPrevLogIndex)
		return nil
	}

	s.logGeneric(&amp;quot;flush to %d: accepted; prevLogIndex(%d) remains %d&amp;quot;, peerID, peerID, ni.prevLogIndex(peerID))
	return nil
}

// Leaderå¹¶å‘åŒæ­¥æ—¥å¿—
func (s *Server) concurrentFlush(pm peerMap, ni *nextIndex, timeout time.Duration) (int, bool) {
	type tuple struct {
		id  uint64
		err error
	}
	responses := make(chan tuple, len(pm))
	for _, peer := range pm {
		go func(peer Peer) {
			errChan := make(chan error, 1)
			go func() { errChan &amp;lt;- s.flush(peer, ni) }()
			go func() { time.Sleep(timeout); errChan &amp;lt;- errTimeout }()
			responses &amp;lt;- tuple{peer.id(), &amp;lt;-errChan} // first responder wins
		}(peer)
	}

	successes, stepDown := 0, false
	for i := 0; i &amp;lt; cap(responses); i++ {
		switch t := &amp;lt;-responses; t.err {
		case nil:
			s.logGeneric(&amp;quot;concurrentFlush: peer %d: OK (prevLogIndex(%d)=%d)&amp;quot;, t.id, t.id, ni.prevLogIndex(t.id))
			successes++
		case errDeposed:
			// å½“å‰çš„LederèŠ‚ç‚¹è½åäºå…¶ä»–èŠ‚ç‚¹
			s.logGeneric(&amp;quot;concurrentFlush: peer %d: deposed!&amp;quot;, t.id)
			stepDown = true
		default:
			s.logGeneric(&amp;quot;concurrentFlush: peer %d: %s (prevLogIndex(%d)=%d)&amp;quot;, t.id, t.err, t.id, ni.prevLogIndex(t.id))
			// nothing to do but log and continue
		}
	}
	return successes, stepDown
}

// ä½œä¸ºLeaderè§’è‰²è¿è¡Œ
func (s *Server) leaderSelect() {
	if s.leader != s.id {
		panic(fmt.Sprintf(&amp;quot;leader (%d) not me (%d) when entering leaderSelect&amp;quot;, s.leader, s.id))
	}
	if s.vote != 0 {
		panic(fmt.Sprintf(&amp;quot;vote (%d) not zero when entering leaderSelect&amp;quot;, s.leader))
	}

	// 5.3 Log replication: &amp;quot;The leader maintains a nextIndex for each follower,
	// which is the index of the next log entry the leader will send to that
	// follower. When a leader first comes to power it initializes all nextIndex
	// values to the index just after the last one in its log.&amp;quot;
	//
	// I changed this from lastIndex+1 to simply lastIndex. Every initial
	// communication from leader to follower was being rejected and we were
	// doing the decrement. This was just annoying, except if you manage to
	// sneak in a command before the first heartbeat. Then, it will never get
	// properly replicated (it seemed).
	
	// Leaderä¸ºæ¯ä¸ªFollowerä¿å­˜äº†æœ€æ–°çš„åŒæ­¥æ—¥å¿—ç´¢å¼•
	ni := newNextIndex(s.config.allPeers().except(s.id), s.log.lastIndex()) // +1)

	flush := make(chan struct{})
	heartbeat := time.NewTicker(broadcastInterval())
	defer heartbeat.Stop()
	go func() {
      	// å‘é€å¿ƒè·³ï¼Œé™¤äº†æ£€æµ‹å¿ƒè·³å¤–ï¼Œè¿˜æœ‰é˜²æ­¢Followerå‘é€é€‰ä¸¾
		for _ = range heartbeat.C {
			flush &amp;lt;- struct{}{}
		}
	}()

	for {
		select {
		case q := &amp;lt;-s.quit:
			s.handleQuit(q)
			return
		// æ”¶åˆ°å‘½ä»¤
		case t := &amp;lt;-s.commandChan:
			// Append the command to our (leader) log
			s.logGeneric(&amp;quot;got command, appending&amp;quot;)
			currentTerm := s.term
			entry := logEntry{
				Index:           s.log.lastIndex() + 1,
				Term:            currentTerm,
				Command:         t.Command,
				commandResponse: t.CommandResponse,
			}
          	// è¿½åŠ æ—¥å¿—
			if err := s.log.appendEntry(entry); err != nil {
				t.Err &amp;lt;- err
				continue
			}
			s.logGeneric(
				&amp;quot;after append, commitIndex=%d lastIndex=%d lastTerm=%d&amp;quot;,
				s.log.getCommitIndex(),
				s.log.lastIndex(),
				s.log.lastTerm(),
			)

			// Now that the entry is in the log, we can fall back to the
			// normal flushing mechanism to attempt to replicate the entry
			// and advance the commit index. We trigger a manual flush as a
			// convenience, so our caller might get a response a bit sooner.
          	// è¿™é‡Œå°†æ—¥å¿—åŒæ­¥æ”¾åˆ°äº†åŒæ­¥é˜Ÿåˆ—å°±è¿”å›ç»™å®¢æˆ·ç«¯äº†ï¼Œæ­£å¸¸æ¥è¯´ï¼Œéœ€è¦&amp;quot;å…±è¯†&amp;quot;è¾¾æˆæ‰è¿”å›ç»™å®¢æˆ·ç«¯
			go func() { flush &amp;lt;- struct{}{} }()
			t.Err &amp;lt;- nil
        // æ”¶åˆ°é…ç½®å˜æ›´
		case t := &amp;lt;-s.configurationChan:
			// Attempt to change our local configuration
			if err := s.config.changeTo(makePeerMap(t.Peers...)); err != nil {
				t.Err &amp;lt;- err
				continue
			}

			// Serialize the local (C_old,new) configuration
			encodedConfiguration, err := s.config.encode()
			if err != nil {
				t.Err &amp;lt;- err
				continue
			}

			// We&#39;re gonna write+replicate that config via log mechanisms.
			// Prepare the on-commit callback.
			entry := logEntry{
				Index:           s.log.lastIndex() + 1,
				Term:            s.term,
				Command:         encodedConfiguration,
				isConfiguration: true,
				committed:       make(chan bool),
			}
			go func() {
              	// å½“æ—¥å¿—è¢«commitedæ—¶ï¼Œcommittedå°†è¢«å›è°ƒ
				committed := &amp;lt;-entry.committed
				if !committed {
					s.config.changeAborted()
					return
				}
             	// æ—¥å¿—è¢«committedäº†ï¼Œè¯´æ˜å…¶ä»–èŠ‚ç‚¹éƒ½åº”ç”¨äº†æœ€æ–°çš„é…ç½®ï¼Œæ‰€ä»¥å½“å‰çš„èŠ‚ç‚¹é…ç½®ä¹Ÿéœ€è¦æ›´æ–°
				s.config.changeCommitted()
				if _, ok := s.config.allPeers()[s.id]; !ok {
                  	// å½“å‰èŠ‚ç‚¹å·²è¢«æ–°é›†ç¾¤å‰”é™¤
					s.logGeneric(&amp;quot;leader expelled; shutting down&amp;quot;)
					q := make(chan struct{})
					s.quit &amp;lt;- q
                  	// èŠ‚ç‚¹å·²é€€å‡º
					&amp;lt;-q
				}
			}()
          	// æ—¥å¿—è¿½åŠ 
			if err := s.log.appendEntry(entry); err != nil {
				t.Err &amp;lt;- err
				continue
			}

		case &amp;lt;-flush:
          	// è·å–éœ€è¦åŒæ­¥çš„èŠ‚ç‚¹
			recipients := s.config.allPeers().except(s.id)

			// Special case: network of 1
			if len(recipients) &amp;lt;= 0 {
				ourLastIndex := s.log.lastIndex()
				if ourLastIndex &amp;gt; 0 {
					if err := s.log.commitTo(ourLastIndex); err != nil {
						s.logGeneric(&amp;quot;commitTo(%d): %s&amp;quot;, ourLastIndex, err)
						continue
					}
					s.logGeneric(&amp;quot;after commitTo(%d), commitIndex=%d&amp;quot;, ourLastIndex, s.log.getCommitIndex())
				}
				continue
			}

			// Normal case: network of at-least-2
          	// å¹¶å‘åŒæ­¥æ—¥å¿—
			successes, stepDown := s.concurrentFlush(recipients, ni, 2*broadcastInterval())
			if stepDown {
              	// èŠ‚ç‚¹å·²è¢«å¸ä»»
				s.logGeneric(&amp;quot;deposed during flush&amp;quot;)
				s.state.Set(follower)
				s.leader = unknownLeader
				return
			}

			// Only when we know all followers accepted the flush can we
			// consider incrementing commitIndex and pushing out another
			// round of flushes.
			if successes == len(recipients) {
              	// æœ€å°è¢«åŒæ­¥çš„Index
				peersBestIndex := ni.bestIndex()
				ourLastIndex := s.log.lastIndex()
				ourCommitIndex := s.log.getCommitIndex()
				if peersBestIndex &amp;gt; ourLastIndex {
					// safety check: we&#39;ve probably been deposed
					s.logGeneric(&amp;quot;peers&#39; best index %d &amp;gt; our lastIndex %d&amp;quot;, peersBestIndex, ourLastIndex)
					s.logGeneric(&amp;quot;this is crazy, I&#39;m gonna become a follower&amp;quot;)
					s.leader = unknownLeader
					s.vote = noVote
					s.state.Set(follower)
					return
				}
				if peersBestIndex &amp;gt; ourCommitIndex {
					// committed Leader Index
                  	if err := s.log.commitTo(peersBestIndex); err != nil {
						s.logGeneric(&amp;quot;commitTo(%d): %s&amp;quot;, peersBestIndex, err)
                      	// æ¯”å¦‚æŸä¸ªFolloweråœ¨åŒæ­¥Indexæ—¶å¤±è´¥äº†ï¼Œ
						continue // oh well, next time?
					}
					
					if s.log.getCommitIndex() &amp;gt; ourCommitIndex {
						// ç»§ç»­åŒæ­¥æ—¥å¿—
						s.logGeneric(&amp;quot;after commitTo(%d), commitIndex=%d -- queueing another flush&amp;quot;, peersBestIndex, s.log.getCommitIndex())
						go func() { flush &amp;lt;- struct{}{} }()
					}
				}
			}
		// è¿½åŠ æ—¥å¿—ï¼Œ æ­£å¸¸æ¥è¯´ï¼ŒLeaderèŠ‚ç‚¹æ˜¯ä¸ä¼šå—åˆ°è¯¥å‘½ä»¤çš„ï¼Œå‡ºç°è¿™ç§çš„å¯èƒ½æ˜¯é›†ç¾¤å­˜åœ¨ä¸€ä¸ªæ–°çš„LeaderèŠ‚ç‚¹ï¼Œè¿™å‘½ä»¤å°±æ˜¯è¯¥Leaderå‘é€è¿‡æ¥çš„
		case t := &amp;lt;-s.appendEntriesChan:
			resp, stepDown := s.handleAppendEntries(t.Request)
			s.logAppendEntriesResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
			if stepDown {
				s.logGeneric(&amp;quot;after an appendEntries, deposed to Follower (leader=%d)&amp;quot;, t.Request.LeaderID)
				s.leader = t.Request.LeaderID
				s.state.Set(follower)
				return // deposed
			}
		// å—åˆ°æŠ•ç¥¨è¯·æ±‚
		case t := &amp;lt;-s.requestVoteChan:
			resp, stepDown := s.handleRequestVote(t.Request)
			s.logRequestVoteResponse(t.Request, resp, stepDown)
			t.Response &amp;lt;- resp
			if stepDown {
				s.logGeneric(&amp;quot;after a requestVote, deposed to Follower (leader unknown)&amp;quot;)
				s.leader = unknownLeader
				s.state.Set(follower)
				return // deposed
			}
		}
	}
}

// handleRequestVote will modify s.term and s.vote, but nothing else.
// stepDown means you need to: s.leader=unknownLeader, s.state.Set(Follower).
// å¤„ç†æŠ•ç¥¨
// å¯èƒ½ä¼šä¿®æ”¹s.termå’Œs.vote çš„å€¼; stepDownæ„å‘³ç€éœ€è¦è®¾ç½®s.leader = unkownLeader, s.state.Set(Follower)
func (s *Server) handleRequestVote(rv requestVote) (requestVoteResponse, bool) {
	// Spec is ambiguous here; basing this (loosely!) on benbjohnson&#39;s impl

	// If the request is from an old term, reject
	if rv.Term &amp;lt; s.term {
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason:      fmt.Sprintf(&amp;quot;Term %d &amp;lt; %d&amp;quot;, rv.Term, s.term),
		}, false
	}

	// If the request is from a newer term, reset our state
	stepDown := false
	if rv.Term &amp;gt; s.term {
		// æœ¬åœ°èŠ‚ç‚¹è½åäºé›†ç¾¤çš„å…¶ä»–èŠ‚ç‚¹ï¼Œéœ€è¦æ›´æ–°ä¸€ä¸‹è‡ªå·±çš„ä»»æœŸå·
		s.logGeneric(&amp;quot;requestVote from newer term (%d): we defer&amp;quot;, rv.Term)
		s.term = rv.Term
		s.vote = noVote
		s.leader = unknownLeader
		stepDown = true
	}

	// Special case: if we&#39;re the leader, and we haven&#39;t been deposed by a more
	// recent term, then we should always deny the vote
	if s.state.Get() == leader &amp;amp;&amp;amp; !stepDown {
		// å¦‚æœæœ¬åœ°èŠ‚ç‚¹æ˜¯Leaderï¼Œå¹¶ä¸”åˆä¸è½åäºreq èŠ‚ç‚¹ï¼Œåˆ™æŠ•åå¯¹ç¥¨
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason:      &amp;quot;already the leader&amp;quot;,
		}, stepDown
	}

	// If we&#39;ve already voted for someone else this term, reject
	// å¦‚æœå·²ç»æŠ•è¿‡ç¥¨ï¼Œåˆ™æŠ•å¤±è´¥ç¥¨
	if s.vote != 0 &amp;amp;&amp;amp; s.vote != rv.CandidateID {
		if stepDown {
			panic(&amp;quot;impossible state in handleRequestVote&amp;quot;)
		}
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason:      fmt.Sprintf(&amp;quot;already cast vote for %d&amp;quot;, s.vote),
		}, stepDown
	}

	// If the candidate log isn&#39;t at least as recent as ours, reject
	if s.log.lastIndex() &amp;gt; rv.LastLogIndex || s.log.lastTerm() &amp;gt; rv.LastLogTerm {
		return requestVoteResponse{
			Term:        s.term,
			VoteGranted: false,
			reason: fmt.Sprintf(
				&amp;quot;our index/term %d/%d &amp;gt; %d/%d&amp;quot;,
				s.log.lastIndex(),
				s.log.lastTerm(),
				rv.LastLogIndex,
				rv.LastLogTerm,
			),
		}, stepDown
	}

	// We passed all the tests: cast vote in favor
	s.vote = rv.CandidateID
	s.resetElectionTimeout()
	return requestVoteResponse{
		Term:        s.term,
		VoteGranted: true,
	}, stepDown
}

// handleAppendEntries will modify s.term and s.vote, but nothing else.
// stepDown means you need to: s.leader=r.LeaderID, s.state.Set(Follower).
// è¿½åŠ æ—¥å¿—ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒhandleAppendEntriesä¹Ÿä¼šä¿®æ”¹s.termå’Œs.vote
// stepDownä¹Ÿä¼šä¿®æ”¹s.Leader, s,state
// éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæœ¬åœ°èŠ‚ç‚¹çš„stateä¸åŒæ—¶ï¼Œå…¶è¡Œä¸ºä¹Ÿæ˜¯ä¸ç”¨çš„
func (s *Server) handleAppendEntries(r appendEntries) (appendEntriesResponse, bool) {
	// Spec is ambiguous here; basing this on benbjohnson&#39;s impl

	// Maybe a nicer way to handle this is to define explicit handler functions
	// for each Server state. Then, we won&#39;t try to hide too much logic (i.e.
	// too many protocol rules) in one code path.

	// If the request is from an old term, reject
	if r.Term &amp;lt; s.term {
		return appendEntriesResponse{
			Term:    s.term,
			Success: false,
			reason:  fmt.Sprintf(&amp;quot;Term %d &amp;lt; %d&amp;quot;, r.Term, s.term),
		}, false
	}

	// If the request is from a newer term, reset our state
	stepDown := false
	if r.Term &amp;gt; s.term {
		s.term = r.Term
		s.vote = noVote
		stepDown = true
	}

	// Special case for candidates: &amp;quot;While waiting for votes, a candidate may
	// receive an appendEntries RPC from another server claiming to be leader.
	// If the leaderâ€™s term (included in its RPC) is at least as large as the
	// candidateâ€™s current term, then the candidate recognizes the leader as
	// legitimate and steps down, meaning that it returns to follower state.&amp;quot;
	if s.state.Get() == candidate &amp;amp;&amp;amp; r.LeaderID != s.leader &amp;amp;&amp;amp; r.Term &amp;gt;= s.term {
		s.term = r.Term
		s.vote = noVote
		stepDown = true
	}

	// In any case, reset our election timeout
	s.resetElectionTimeout()

	// Reject if log doesn&#39;t contain a matching previous entry
	// å¦‚æœ{PreLogIndex, PreLogTerm} ä¸æ˜¯æœ€æ–°çš„æ¡ç›®ï¼Œåˆ™å¤±è´¥
	// [{1, 2},{1, 3},		{1,4},{1,5},{1,6}] =&amp;gt; {1,5} =&amp;gt; [{1, 2},{1, 3},		{1,4},{1,5}]
	if err := s.log.ensureLastIs(r.PrevLogIndex, r.PrevLogTerm); err != nil {
		return appendEntriesResponse{
			Term:    s.term,
			Success: false,
			reason: fmt.Sprintf(
				&amp;quot;while ensuring last log entry had index=%d term=%d: error: %s&amp;quot;,
				r.PrevLogIndex,
				r.PrevLogTerm,
				err,
			),
		}, stepDown
	}

	// Process the entries
	for i, entry := range r.Entries {
		// Configuration changes requre special preprocessing
		var pm peerMap
		// å¤„ç†é…ç½®
		if entry.isConfiguration {
			commandBuf := bytes.NewBuffer(entry.Command)
			if err := gob.NewDecoder(commandBuf).Decode(&amp;amp;pm); err != nil {
				panic(&amp;quot;gob decode of peers failed&amp;quot;)
			}

			if s.state.Get() == leader {
				// TODO should we instead just ignore this entry?
				return appendEntriesResponse{
					Term:    s.term,
					Success: false,
					reason: fmt.Sprintf(
						&amp;quot;AppendEntry %d/%d failed (configuration): %s&amp;quot;,
						i+1,
						len(r.Entries),
						&amp;quot;Leader shouldn&#39;t receive configurations via appendEntries&amp;quot;,
					),
				}, stepDown
			}

			// Expulsion recognition
			if _, ok := pm[s.id]; !ok {
				entry.committed = make(chan bool)
				go func() {
					if &amp;lt;-entry.committed {
						s.logGeneric(&amp;quot;non-leader expelled; shutting down&amp;quot;)
						q := make(chan struct{})
						s.quit &amp;lt;- q
						&amp;lt;-q
					}
				}()
			}
		}

		// Append entry to the log
		if err := s.log.appendEntry(entry); err != nil {
			return appendEntriesResponse{
				Term:    s.term,
				Success: false,
				reason: fmt.Sprintf(
					&amp;quot;AppendEntry %d/%d failed: %s&amp;quot;,
					i+1,
					len(r.Entries),
					err,
				),
			}, stepDown
		}

		// &amp;quot;Once a given server adds the new configuration entry to its log, it
		// uses that configuration for all future decisions (it does not wait
		// for the entry to become committed).&amp;quot;
		if entry.isConfiguration {
			if err := s.config.directSet(pm); err != nil {
				return appendEntriesResponse{
					Term:    s.term,
					Success: false,
					reason: fmt.Sprintf(
						&amp;quot;AppendEntry %d/%d failed (configuration): %s&amp;quot;,
						i+1,
						len(r.Entries),
						err,
					),
				}, stepDown
			}
		}
	}

	// Commit up to the commit index.
	//
	// &amp;lt; ptrb&amp;gt; ongardie: if the new leader sends a 0-entry appendEntries
	//  with lastIndex=5 commitIndex=4, to a follower that has lastIndex=5
	//  commitIndex=5 -- in my impl, this fails, because commitIndex is too
	//  small. shouldn&#39;t be?
	// &amp;lt;@ongardie&amp;gt; ptrb: i don&#39;t think that should fail
	// &amp;lt;@ongardie&amp;gt; there are 4 ways an appendEntries request can fail: (1)
	//  network drops packet (2) caller has stale term (3) would leave gap in
	//  the recipient&#39;s log (4) term of entry preceding the new entries doesn&#39;t
	//  match the term at the same index on the recipient
	// 
	// å‡ºç°è¿™ç§æƒ…å†µçš„åŸå› å¯èƒ½æ˜¯æœ¬åœ°èŠ‚ç‚¹è¿è¡Œåˆ°committedé€»è¾‘çš„æ—¶å€™å‡ºç°äº†é—®é¢˜ï¼Œæˆ–è€…è¯´åº”ç­”ç»™Leaderæ—¶ï¼Œç½‘ç»œå‡ºç°äº†é—®é¢˜ç­‰ç­‰ã€‚
	// è¿™äº›æƒ…å†µéƒ½ä¼šé€ æˆæ•°æ®ä¸åŒæ­¥çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯æœ¬åœ°èŠ‚ç‚¹çš„commiittedæƒ…å†µå’ŒLeaderèŠ‚ç‚¹ä¿å­˜çš„Follower(æœ¬åœ°èŠ‚ç‚¹)ä¸ä¸€è‡´
	if r.CommitIndex &amp;gt; 0 &amp;amp;&amp;amp; r.CommitIndex &amp;gt; s.log.getCommitIndex() {
		if err := s.log.commitTo(r.CommitIndex); err != nil {
			return appendEntriesResponse{
				Term:    s.term,
				Success: false,
				reason:  fmt.Sprintf(&amp;quot;CommitTo(%d) failed: %s&amp;quot;, r.CommitIndex, err),
			}, stepDown
		}
	}

	// all good
	return appendEntriesResponse{
		Term:    s.term,
		Success: true,
	}, stepDown
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configuration-go&#34;&gt;configuration.go&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
       	errConfigurationAlreadyChanging = errors.New(&amp;quot;configuration already changing&amp;quot;)
)

const (
       	cOld    = &amp;quot;C_old&amp;quot;
       	cOldNew = &amp;quot;C_old,new&amp;quot;
)

// configuration represents the sets of peers and behaviors required to
// implement joint-consensus.
type configuration struct {
       	sync.RWMutex
       	state     string
       	// è€é…ç½®
       	cOldPeers peerMap
       	// æ–°é…ç½®-ã€‹ç”¨äºè¿‡åº¦
       	cNewPeers peerMap
}

// newConfiguration returns a new configuration in stable (C_old) state based
// on the passed peers.
func newConfiguration(pm peerMap) *configuration {
       	return &amp;amp;configuration{
       		state:     cOld, // start in a stable state,
       		cOldPeers: pm,   // with only C_old
       	}
}

// directSet is used when bootstrapping, and when receiving a replicated
// configuration from a leader. It directly sets the configuration to the
// passed peers. It&#39;s assumed this is called on a non-leader, and therefore
// requires no consistency dance.
// é…ç½®å˜æ›´
func (c *configuration) directSet(pm peerMap) error {
       	c.Lock()
       	defer c.Unlock()

       	c.cOldPeers = pm
       	c.cNewPeers = peerMap{}
       	c.state = cOld
       	return nil
}

func (c *configuration) get(id uint64) (Peer, bool) {
       	c.RLock()
       	defer c.RUnlock()

       	if peer, ok := c.cOldPeers[id]; ok {
       		return peer, true
       	}
       	if peer, ok := c.cNewPeers[id]; ok {
       		return peer, true
       	}
       	return nil, false
}

func (c *configuration) encode() ([]byte, error) {
       	buf := &amp;amp;bytes.Buffer{}
       	if err := gob.NewEncoder(buf).Encode(c.allPeers()); err != nil {
       		return []byte{}, err
       	}
       	return buf.Bytes(), nil
}

// allPeers returns the union set of all peers in the configuration.
func (c *configuration) allPeers() peerMap {
       	c.RLock()
       	defer c.RUnlock()

       	union := peerMap{}
       	for id, peer := range c.cOldPeers {
       		union[id] = peer
       	}
       	for id, peer := range c.cNewPeers {
       		union[id] = peer
       	}
       	return union
}

// pass returns true if the votes represented by the votes map are sufficient
// to constitute a quorum. pass respects C_old,new requirements, which dictate
// that any request must receive a majority from both C_old and C_new to pass.
// å…±è¯†åˆ¤æ–­
func (c *configuration) pass(votes map[uint64]bool) bool {
       	c.RLock()
       	defer c.RUnlock()

       	// Count the votes
       	cOldHave, cOldRequired := 0, c.cOldPeers.quorum()
       	for id := range c.cOldPeers {
       		if votes[id] {
       			cOldHave++
       		}
       		if cOldHave &amp;gt;= cOldRequired {
       			break
       		}
       	}

       	// If we&#39;ve already failed, we can stop here
       	if cOldHave &amp;lt; cOldRequired {
       		return false
       	}

       	// C_old passes: if we&#39;re in C_old, we pass
       	if c.state == cOld {
       		return true
       	}

       	// Not in C_old, so make sure we have some peers in C_new
       	if len(c.cNewPeers) &amp;lt;= 0 {
       		panic(fmt.Sprintf(&amp;quot;configuration state &#39;%s&#39;, but no C_new peers&amp;quot;, c.state))
       	}

       	// Since we&#39;re in C_old,new, we need to also pass C_new to pass overall.
       	// It&#39;s important that we range through C_new and check our votes map, and
       	// not the other way around: if a server casts a vote but doesn&#39;t exist in
       	// a particular configuration, that vote should not be counted.
       	cNewHave, cNewRequired := 0, c.cNewPeers.quorum()
       	for id := range c.cNewPeers {
       		if votes[id] {
       			cNewHave++
       		}
       		if cNewHave &amp;gt;= cNewRequired {
       			break
       		}
       	}

       	return cNewHave &amp;gt;= cNewRequired
}

// é…ç½®å˜æ›´å‡†å¤‡, prepare-change
func (c *configuration) changeTo(pm peerMap) error {
       	c.Lock()
       	defer c.Unlock()

       	if c.state != cOld {
       		return errConfigurationAlreadyChanging
       	}

       	if len(c.cNewPeers) &amp;gt; 0 {
       		panic(fmt.Sprintf(&amp;quot;configuration ChangeTo in state &#39;%s&#39;, but have C_new peers already&amp;quot;, c.state))
       	}

       	c.cNewPeers = pm
       	c.state = cOldNew
       	return nil
}

// æäº¤å˜æ›´é€»è¾‘
func (c *configuration) changeCommitted() {
       	c.Lock()
       	defer c.Unlock()

       	if c.state != cOldNew {
       		panic(&amp;quot;configuration ChangeCommitted, but not in C_old,new&amp;quot;)
       	}

       	if len(c.cNewPeers) &amp;lt;= 0 {
       		panic(&amp;quot;configuration ChangeCommitted, but C_new peers are empty&amp;quot;)
       	}

       	c.cOldPeers = c.cNewPeers
       	c.cNewPeers = peerMap{}
       	c.state = cOld
}

// ä¸­æ–­å˜æ›´
func (c *configuration) changeAborted() {
       	c.Lock()
       	defer c.Unlock()

       	if c.state != cOldNew {
       		panic(&amp;quot;configuration ChangeAborted, but not in C_old,new&amp;quot;)
       	}

       	c.cNewPeers = peerMap{}
       	c.state = cOld
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;demo&#34;&gt;Demo&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
       	&amp;quot;bytes&amp;quot;
       	&amp;quot;fmt&amp;quot;
       	&amp;quot;hash/fnv&amp;quot;
       	&amp;quot;net/http&amp;quot;
       	&amp;quot;net/url&amp;quot;
       	&amp;quot;time&amp;quot;

       	&amp;quot;github.com/peterbourgon/raft&amp;quot;
)

func main() {
       	a := func(idx uint64, cmd []byte) []byte {
       		fmt.Printf(&amp;quot;%d, apply function: %s\n&amp;quot;, idx, cmd)
       		return cmd
       	}

       	mustParseURL := func(rawURL string) *url.URL {
       		u, _ := url.Parse(rawURL)
       		u.Path = &amp;quot;&amp;quot;
       		return u
       	}
       	mustNewHTTPPeer := func(u *url.URL) raft.Peer {
       		p, err := raft.NewHTTPPeer(u)
       		if err != nil {
       			panic(err)
       		}
       		return p
       	}
       	peersAddr := []string{
       		&amp;quot;127.0.0.1:7090&amp;quot;,
       		&amp;quot;127.0.0.1:7091&amp;quot;,
       		&amp;quot;127.0.0.1:7092&amp;quot;,
       		&amp;quot;127.0.0.1:7093&amp;quot;,
       		&amp;quot;127.0.0.1:7094&amp;quot;}
       	var ss []*raft.Server
       	for _, addr := range peersAddr {
       		hash := fnv.New64()
       		hash.Write([]byte(addr))
       		id := hash.Sum64()
       		hash.Reset()
       		s := raft.NewServer(id, &amp;amp;bytes.Buffer{}, a)
       		mux := http.NewServeMux()
       		raft.HTTPTransport(mux, s)
       		go func(addr string) {
       			if err := http.ListenAndServe(addr, mux); err != nil {
       				panic(err)
       			}
       		}(addr)
       		ss = append(ss, s)
       	}
       	time.Sleep(time.Second)
       	for _, s := range ss {
       		s.SetConfiguration(
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7090&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7091&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7092&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7093&amp;quot;)),
       			mustNewHTTPPeer(mustParseURL(&amp;quot;http://127.0.0.1:7094&amp;quot;)),
       		)
       		s.Start()
       	}

       	for {
       		cmd := []byte(time.Now().String())
       		cmdChan := make(chan []byte)
       		go ss[0].Command(cmd, cmdChan)
       		&amp;lt;-cmdChan
       		time.Sleep(time.Millisecond * 500)
       	}

       	time.Sleep(time.Hour)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Run&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Â» go run raft-server.go 2&amp;gt;/dev/null     
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
1, apply function: 2017-09-11 11:41:13.668460404 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
2, apply function: 2017-09-11 11:41:14.169165702 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
3, apply function: 2017-09-11 11:41:14.670873193 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
4, apply function: 2017-09-11 11:41:15.171741805 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
5, apply function: 2017-09-11 11:41:15.673498401 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
6, apply function: 2017-09-11 11:41:16.175658603 +0800 CST
7, apply function: 2017-09-11 11:41:16.677758823 +0800 CST
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>200è¡ŒåŒºå—é“¾</title>
      <link>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97/</link>
      <pubDate>Sun, 12 Mar 2017 23:46:57 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97/</guid>
      <description>&lt;pre&gt;&lt;code&gt;talk is cheap, show me the code!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;crypto/sha256&amp;quot;
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	log &amp;quot;github.com/laohanlinux/utils/gokitlog&amp;quot;
	&amp;quot;github.com/laohanlinux/utils/netrpc&amp;quot;
	pool &amp;quot;github.com/laohanlinux/utils/pool/rpc&amp;quot;
)

var (
	blockChain       = []Block{GetGenesiseBlock()}
	initialPeers     = flag.String(&amp;quot;peers&amp;quot;, &amp;quot;localhost:6660,localhost:6661,localhost:6662&amp;quot;, &amp;quot;&amp;quot;)
	httpPort         = flag.String(&amp;quot;http_port&amp;quot;, &amp;quot;localhost:7000&amp;quot;, &amp;quot;&amp;quot;)
	p2pPort          = flag.String(&amp;quot;p2p_port&amp;quot;, &amp;quot;localhost:6660&amp;quot;, &amp;quot;&amp;quot;)
	peersConnections = make(map[string]*pool.NetRPCRing)
	s                Service
)

func main() {
	flag.Parse()
	l, err := initP2PServer()
	if err != nil {
		log.Crit(&amp;quot;err&amp;quot;, err)
	}
	log.Debug(&amp;quot;p2pServer listener address&amp;quot;, *p2pPort)
	defer l.Close()
	peers := strings.Split(*initialPeers, &amp;quot;,&amp;quot;)
	conncetToPeers(peers)
	initHttpServer()
	time.Sleep(time.Hour * 10000)
}

type Block struct {
	Index        int64
	PreviousHash string
	TimeStamp    int64
	Data         []byte
	Hash         string
}

func NewBlock(index int64, previousHash string, timeStamp int64, Data []byte, Hash string) Block {
	return Block{
		Index:        index,
		PreviousHash: previousHash,
		TimeStamp:    timeStamp,
		Data:         Data,
		Hash:         Hash,
	}
}

func CalculationHashForBlock(block Block) string {
	return CalculationHash(block.Index, block.PreviousHash, block.TimeStamp, block.Data)
}

func CalculationHash(index int64, previousHash string, timeStamp int64, data []byte) string {
	return fmt.Sprintf(&amp;quot;%x&amp;quot;, sha256.Sum256([]byte(fmt.Sprintf(&amp;quot;%v%v%v%s&amp;quot;, index, previousHash, timeStamp, data))))
}

func GenerateNextBlock(blockData []byte) Block {
	var (
		previousBlock = getLatestBlock()
		nextIndex     = previousBlock.Index + 1
		nextTimeStamp = time.Now().Unix()
		nextHash      = CalculationHash(nextIndex, previousBlock.Hash, nextTimeStamp, blockData)
	)
	return NewBlock(nextIndex, previousBlock.Hash, nextTimeStamp, blockData, nextHash)
}

func GetGenesiseBlock() Block {
	return NewBlock(0, &amp;quot;0&amp;quot;, 1465154705, []byte(&amp;quot;my genesis block!!&amp;quot;), &amp;quot;816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7&amp;quot;)
}

func AddBlock(newBlock Block) {
	if isValidNewBlock(newBlock, getLatestBlock()) {
		blockChain = append(blockChain, newBlock)
	}
}

func replaceChain(newBlocks []Block) {
	if isValidBlock(newBlocks) &amp;amp;&amp;amp; len(newBlocks) &amp;gt; len(blockChain) {
		log.Warnf(&amp;quot;received blockchain is valid, replacing current blockchain with received blockchain&amp;quot;)
		blockChain = newBlocks
		// broadcast
		for _, peerClient := range peersConnections {
			go peerClient.Call(serviceAddBlockChain, &amp;amp;AddBlockChainArgs{NewBlockChain: blockChain}, &amp;amp;AddBlockChainReply{})
		}
	} else {
		log.Debugf(&amp;quot;received blockchain invalid&amp;quot;)
	}
}

func isValidNewBlock(newBlock, previousBlock Block) bool {
	if previousBlock.Index+1 != newBlock.Index {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid index&amp;quot;)
		return false
	}
	if previousBlock.Hash != newBlock.PreviousHash {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid previousHash&amp;quot;)
		return false
	}
	// check wether newBlock.Hash is right calculation by his content
	if CalculationHashForBlock(newBlock) != newBlock.Hash {
		log.Debugf(&amp;quot;invalid hash: %v, %v&amp;quot;, CalculationHashForBlock(newBlock), newBlock.Hash)
		return false
	}
	return true
}

func isValidBlock(blockChainToValidate []Block) bool {
	// check genesis block
	if blockChainToValidate[0].Hash != GetGenesiseBlock().Hash {
		return false
	}

	for i := 1; i &amp;lt; len(blockChainToValidate); i++ {
		if !isValidNewBlock(blockChainToValidate[i], blockChainToValidate[i-1]) {
			return false
		}
	}
	return true
}

func getLatestBlock() Block { return blockChain[len(blockChain)-1] }

func initHttpServer() {
	router := gin.Default()
	router.GET(&amp;quot;/blocks&amp;quot;, func(c *gin.Context) { json.NewEncoder(c.Writer).Encode(blockChain) })
	router.POST(&amp;quot;/mineBlock&amp;quot;, func(c *gin.Context) {
		var (
			buf []byte
			err error
		)
		if buf, err = ioutil.ReadAll(c.Request.Body); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusInternalServerError)
			return
		}
		AddBlock(GenerateNextBlock(buf))
		// broadcast to notify peers our has add new block
		for _, peerClient := range peersConnections {
			go func() {
				var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: blockChain}, AddBlockChainReply{}
				if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
					log.Error(&amp;quot;err&amp;quot;, err)
				}
			}()
		}
		c.Writer.WriteHeader(http.StatusOK)
	})
	router.GET(&amp;quot;/peers&amp;quot;, func(c *gin.Context) {
		var peers []string
		for peer, _ := range peersConnections {
			peers = append(peers, peer)
		}
		if err := json.NewEncoder(c.Writer).Encode(peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		}
	})
	router.POST(&amp;quot;/addPeer&amp;quot;, func(c *gin.Context) {
		var peers []string
		if err := json.NewDecoder(c.Request.Body).Decode(&amp;amp;peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusBadRequest)
			return
		}
		conncetToPeers(peers)
	})
	go http.ListenAndServe(*httpPort, router)
}

func initP2PServer() (net.Listener, error) {

	l, err := net.Listen(&amp;quot;tcp&amp;quot;, *p2pPort)
	if err != nil {
		return nil, err
	}
	server := netrpc.NewServer()
	server.Register(&amp;amp;s)
	server.Register(&amp;amp;netrpc.HealthCheck{})
	go server.Accept(l)

	return l, nil
}

func conncetToPeers(peers []string) {
	var (
		rpcOpt pool.NetRPCRingOpt
	)
	for _, peer := range peers {
		if _, ok := peersConnections[peer]; ok {
			continue
		}
		rpcOpt.Addr, rpcOpt.NetWork, rpcOpt.PoolSize = peer, &amp;quot;tcp&amp;quot;, 1
		if pools, err := pool.NewNetRPCRing([]pool.NetRPCRingOpt{rpcOpt}); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		} else {
			peersConnections[peer] = pools
		}
	}
}

// AddBlockChain add new blockchain into cluster
// if the new block is new than local lasted block, agree it
func handleBlockChain(args AddBlockChainArgs) {
	log.Debug(&amp;quot;who&amp;quot;, *p2pPort, &amp;quot;do&amp;quot;, &amp;quot;handle blockchain&amp;quot;)
	var (
		receivedBlocks      = args.NewBlockChain
		latestBlockReceived = receivedBlocks[len(receivedBlocks)-1]
		latestBlockHeld     = getLatestBlock()
	)
	if latestBlockReceived.Index &amp;gt; latestBlockHeld.Index {
		log.Warnf(&amp;quot;blockchain possibly behind. We got: %v Peer got: %v&amp;quot;, latestBlockHeld.Index, latestBlockReceived.Index)
		if latestBlockHeld.Hash == latestBlockReceived.PreviousHash {
			log.Warnf(&amp;quot;We can append the received block to our block&amp;quot;)
			blockChain = append(blockChain, latestBlockReceived)
			// broadcast to other
			for _, peerClient := range peersConnections {
				go func() {
					var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: args.NewBlockChain}, AddBlockChainReply{}
					if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					}
				}()
			}
		} else if len(receivedBlocks) == 1 {
			log.Warnf(&amp;quot;we have must query the chain from our peer&amp;quot;)
			// broadcast
			for _, peersClient := range peersConnections {
				go func() {
					var (
						rpcArgs  QueryAllBlockChainsArgs
						rpcreply QueryAllBlockChainsReply
						err      error
					)
					if err = peersClient.Call(serviceQueryAllBlockChains, &amp;amp;rpcArgs, &amp;amp;rpcreply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					} else {
						handleBlockChain(AddBlockChainArgs{NewBlockChain: rpcreply.NewBlockChains})
					}
				}()
			}
		} else {
			log.Debugf(&amp;quot;Received blockchain is longer than current blockchain&amp;quot;)
			replaceChain(receivedBlocks)
		}
	} else {
		log.Debug(&amp;quot;received blockchain is not longer than received blockchain. Do nothing&amp;quot;)
	}
}

const (
	serviceName                = &amp;quot;Service&amp;quot;
	serviceAddBlockChain       = serviceName + &amp;quot;.AddBlockChain&amp;quot;
	serviceQueryAllBlockChains = serviceName + &amp;quot;.QueryAllBlockChains&amp;quot;
)

type AddBlockChainArgs struct{ NewBlockChain []Block }

type AddBlockChainReply struct{}

///////
type QueryAllBlockChainsArgs struct{}
type QueryAllBlockChainsReply struct{ NewBlockChains []Block }

//////
type Service struct{}

func (s *Service) QueryAllMsg(_ context.Context, _ *QueryAllBlockChainsArgs, reply *QueryAllBlockChainsReply) error {
	reply.NewBlockChains = blockChain
	return nil
}

func (s *Service) AddBlockChain(_ context.Context, args *AddBlockChainArgs, reply *AddBlockChainReply) error {
	handleBlockChain(*args)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¯åŠ¨è„šæœ¬ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build -o blockchain main.go

sudo pkill -9 blockchain 

./blockchain -http_port=&amp;quot;localhost:7000&amp;quot; -p2p_port=&amp;quot;localhost:6660&amp;quot;   -peers=&amp;quot;localhost:6661&amp;quot; &amp;amp;

./blockchain -http_port=&amp;quot;localhost:7001&amp;quot; -p2p_port=&amp;quot;localhost:6661&amp;quot;   -peers=&amp;quot;localhost:6660&amp;quot; &amp;amp; 

sleep 1 

curl -v -XPOST &amp;quot;http://localhost:7001/addPeer&amp;quot; -d &#39;[localhost:6660]&#39; | jq 
sleep 2
curl -v -XPOST &amp;quot;http://localhost:7000/addPeer&amp;quot; -d &#39;[localhost:6661]&#39; | jq 
sleep 2

curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 


curl -v &amp;quot;http://localhost:7001/blocks&amp;quot; | jq 
sleep 1 

curl -v &amp;quot;http://localhost:7000/blocks&amp;quot; | jq 

curl -v &amp;quot;http://localhost:7000/peers&amp;quot; | jq 
curl -v &amp;quot;http://localhost:7001/peers&amp;quot; | jq 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æ¯”è¾ƒç®€å•ï¼Œæ‹¿æ¥çœ‹çœ‹å°±å¥½äº†ï¼Œåˆ«å¤ªåœ¨æ„&amp;hellip;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;åŸç‰ˆ &lt;a href=&#34;https://github.com/lhartikk/naivechain.git&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/lhartikk/naivechain.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>200è¡ŒåŒºå—é“¾-goè¯­è¨€ç‰ˆæœ¬</title>
      <link>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97%E9%93%BE-go%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sun, 12 Mar 2017 23:46:57 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2017/03/12/200%E8%A1%8C%E5%8C%BA%E5%9D%97%E9%93%BE-go%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/</guid>
      <description>&lt;pre&gt;&lt;code&gt;talk is cheap, show me the code!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;crypto/sha256&amp;quot;
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	log &amp;quot;github.com/laohanlinux/utils/gokitlog&amp;quot;
	&amp;quot;github.com/laohanlinux/utils/netrpc&amp;quot;
	pool &amp;quot;github.com/laohanlinux/utils/pool/rpc&amp;quot;
)

var (
	blockChain       = []Block{GetGenesiseBlock()}
	initialPeers     = flag.String(&amp;quot;peers&amp;quot;, &amp;quot;localhost:6660,localhost:6661,localhost:6662&amp;quot;, &amp;quot;&amp;quot;)
	httpPort         = flag.String(&amp;quot;http_port&amp;quot;, &amp;quot;localhost:7000&amp;quot;, &amp;quot;&amp;quot;)
	p2pPort          = flag.String(&amp;quot;p2p_port&amp;quot;, &amp;quot;localhost:6660&amp;quot;, &amp;quot;&amp;quot;)
	peersConnections = make(map[string]*pool.NetRPCRing)
	s                Service
)

func main() {
	flag.Parse()
	l, err := initP2PServer()
	if err != nil {
		log.Crit(&amp;quot;err&amp;quot;, err)
	}
	log.Debug(&amp;quot;p2pServer listener address&amp;quot;, *p2pPort)
	defer l.Close()
	peers := strings.Split(*initialPeers, &amp;quot;,&amp;quot;)
	conncetToPeers(peers)
	initHttpServer()
	time.Sleep(time.Hour * 10000)
}

type Block struct {
	Index        int64
	PreviousHash string
	TimeStamp    int64
	Data         []byte
	Hash         string
}

func NewBlock(index int64, previousHash string, timeStamp int64, Data []byte, Hash string) Block {
	return Block{
		Index:        index,
		PreviousHash: previousHash,
		TimeStamp:    timeStamp,
		Data:         Data,
		Hash:         Hash,
	}
}

func CalculationHashForBlock(block Block) string {
	return CalculationHash(block.Index, block.PreviousHash, block.TimeStamp, block.Data)
}

func CalculationHash(index int64, previousHash string, timeStamp int64, data []byte) string {
	return fmt.Sprintf(&amp;quot;%x&amp;quot;, sha256.Sum256([]byte(fmt.Sprintf(&amp;quot;%v%v%v%s&amp;quot;, index, previousHash, timeStamp, data))))
}

func GenerateNextBlock(blockData []byte) Block {
	var (
		previousBlock = getLatestBlock()
		nextIndex     = previousBlock.Index + 1
		nextTimeStamp = time.Now().Unix()
		nextHash      = CalculationHash(nextIndex, previousBlock.Hash, nextTimeStamp, blockData)
	)
	return NewBlock(nextIndex, previousBlock.Hash, nextTimeStamp, blockData, nextHash)
}

func GetGenesiseBlock() Block {
	return NewBlock(0, &amp;quot;0&amp;quot;, 1465154705, []byte(&amp;quot;my genesis block!!&amp;quot;), &amp;quot;816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7&amp;quot;)
}

func AddBlock(newBlock Block) {
	if isValidNewBlock(newBlock, getLatestBlock()) {
		blockChain = append(blockChain, newBlock)
	}
}

func replaceChain(newBlocks []Block) {
	if isValidBlock(newBlocks) &amp;amp;&amp;amp; len(newBlocks) &amp;gt; len(blockChain) {
		log.Warnf(&amp;quot;received blockchain is valid, replacing current blockchain with received blockchain&amp;quot;)
		blockChain = newBlocks
		// broadcast
		for _, peerClient := range peersConnections {
			go peerClient.Call(serviceAddBlockChain, &amp;amp;AddBlockChainArgs{NewBlockChain: blockChain}, &amp;amp;AddBlockChainReply{})
		}
	} else {
		log.Debugf(&amp;quot;received blockchain invalid&amp;quot;)
	}
}

func isValidNewBlock(newBlock, previousBlock Block) bool {
	if previousBlock.Index+1 != newBlock.Index {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid index&amp;quot;)
		return false
	}
	if previousBlock.Hash != newBlock.PreviousHash {
		log.Debug(&amp;quot;msg&amp;quot;, &amp;quot;invalid previousHash&amp;quot;)
		return false
	}
	// check wether newBlock.Hash is right calculation by his content
	if CalculationHashForBlock(newBlock) != newBlock.Hash {
		log.Debugf(&amp;quot;invalid hash: %v, %v&amp;quot;, CalculationHashForBlock(newBlock), newBlock.Hash)
		return false
	}
	return true
}

func isValidBlock(blockChainToValidate []Block) bool {
	// check genesis block
	if blockChainToValidate[0].Hash != GetGenesiseBlock().Hash {
		return false
	}

	for i := 1; i &amp;lt; len(blockChainToValidate); i++ {
		if !isValidNewBlock(blockChainToValidate[i], blockChainToValidate[i-1]) {
			return false
		}
	}
	return true
}

func getLatestBlock() Block { return blockChain[len(blockChain)-1] }

func initHttpServer() {
	router := gin.Default()
	router.GET(&amp;quot;/blocks&amp;quot;, func(c *gin.Context) { json.NewEncoder(c.Writer).Encode(blockChain) })
	router.POST(&amp;quot;/mineBlock&amp;quot;, func(c *gin.Context) {
		var (
			buf []byte
			err error
		)
		if buf, err = ioutil.ReadAll(c.Request.Body); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusInternalServerError)
			return
		}
		AddBlock(GenerateNextBlock(buf))
		// broadcast to notify peers our has add new block
		for _, peerClient := range peersConnections {
			go func() {
				var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: blockChain}, AddBlockChainReply{}
				if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
					log.Error(&amp;quot;err&amp;quot;, err)
				}
			}()
		}
		c.Writer.WriteHeader(http.StatusOK)
	})
	router.GET(&amp;quot;/peers&amp;quot;, func(c *gin.Context) {
		var peers []string
		for peer, _ := range peersConnections {
			peers = append(peers, peer)
		}
		if err := json.NewEncoder(c.Writer).Encode(peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		}
	})
	router.POST(&amp;quot;/addPeer&amp;quot;, func(c *gin.Context) {
		var peers []string
		if err := json.NewDecoder(c.Request.Body).Decode(&amp;amp;peers); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
			c.Writer.WriteHeader(http.StatusBadRequest)
			return
		}
		conncetToPeers(peers)
	})
	go http.ListenAndServe(*httpPort, router)
}

func initP2PServer() (net.Listener, error) {

	l, err := net.Listen(&amp;quot;tcp&amp;quot;, *p2pPort)
	if err != nil {
		return nil, err
	}
	server := netrpc.NewServer()
	server.Register(&amp;amp;s)
	server.Register(&amp;amp;netrpc.HealthCheck{})
	go server.Accept(l)

	return l, nil
}

func conncetToPeers(peers []string) {
	var (
		rpcOpt pool.NetRPCRingOpt
	)
	for _, peer := range peers {
		if _, ok := peersConnections[peer]; ok {
			continue
		}
		rpcOpt.Addr, rpcOpt.NetWork, rpcOpt.PoolSize = peer, &amp;quot;tcp&amp;quot;, 1
		if pools, err := pool.NewNetRPCRing([]pool.NetRPCRingOpt{rpcOpt}); err != nil {
			log.Error(&amp;quot;err&amp;quot;, err)
		} else {
			peersConnections[peer] = pools
		}
	}
}

// AddBlockChain add new blockchain into cluster
// if the new block is new than local lasted block, agree it
func handleBlockChain(args AddBlockChainArgs) {
	log.Debug(&amp;quot;who&amp;quot;, *p2pPort, &amp;quot;do&amp;quot;, &amp;quot;handle blockchain&amp;quot;)
	var (
		receivedBlocks      = args.NewBlockChain
		latestBlockReceived = receivedBlocks[len(receivedBlocks)-1]
		latestBlockHeld     = getLatestBlock()
	)
	if latestBlockReceived.Index &amp;gt; latestBlockHeld.Index {
		log.Warnf(&amp;quot;blockchain possibly behind. We got: %v Peer got: %v&amp;quot;, latestBlockHeld.Index, latestBlockReceived.Index)
		if latestBlockHeld.Hash == latestBlockReceived.PreviousHash {
			log.Warnf(&amp;quot;We can append the received block to our block&amp;quot;)
			blockChain = append(blockChain, latestBlockReceived)
			// broadcast to other
			for _, peerClient := range peersConnections {
				go func() {
					var rpcArgs, rpcReply = AddBlockChainArgs{NewBlockChain: args.NewBlockChain}, AddBlockChainReply{}
					if err := peerClient.Call(serviceAddBlockChain, &amp;amp;rpcArgs, &amp;amp;rpcReply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					}
				}()
			}
		} else if len(receivedBlocks) == 1 {
			log.Warnf(&amp;quot;we have must query the chain from our peer&amp;quot;)
			// broadcast
			for _, peersClient := range peersConnections {
				go func() {
					var (
						rpcArgs  QueryAllBlockChainsArgs
						rpcreply QueryAllBlockChainsReply
						err      error
					)
					if err = peersClient.Call(serviceQueryAllBlockChains, &amp;amp;rpcArgs, &amp;amp;rpcreply); err != nil {
						log.Error(&amp;quot;err&amp;quot;, err)
					} else {
						handleBlockChain(AddBlockChainArgs{NewBlockChain: rpcreply.NewBlockChains})
					}
				}()
			}
		} else {
			log.Debugf(&amp;quot;Received blockchain is longer than current blockchain&amp;quot;)
			replaceChain(receivedBlocks)
		}
	} else {
		log.Debug(&amp;quot;received blockchain is not longer than received blockchain. Do nothing&amp;quot;)
	}
}

const (
	serviceName                = &amp;quot;Service&amp;quot;
	serviceAddBlockChain       = serviceName + &amp;quot;.AddBlockChain&amp;quot;
	serviceQueryAllBlockChains = serviceName + &amp;quot;.QueryAllBlockChains&amp;quot;
)

type AddBlockChainArgs struct{ NewBlockChain []Block }

type AddBlockChainReply struct{}

///////
type QueryAllBlockChainsArgs struct{}
type QueryAllBlockChainsReply struct{ NewBlockChains []Block }

//////
type Service struct{}

func (s *Service) QueryAllMsg(_ context.Context, _ *QueryAllBlockChainsArgs, reply *QueryAllBlockChainsReply) error {
	reply.NewBlockChains = blockChain
	return nil
}

func (s *Service) AddBlockChain(_ context.Context, args *AddBlockChainArgs, reply *AddBlockChainReply) error {
	handleBlockChain(*args)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¯åŠ¨è„šæœ¬ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build -o blockchain main.go

sudo pkill -9 blockchain 

./blockchain -http_port=&amp;quot;localhost:7000&amp;quot; -p2p_port=&amp;quot;localhost:6660&amp;quot;   -peers=&amp;quot;localhost:6661&amp;quot; &amp;amp;

./blockchain -http_port=&amp;quot;localhost:7001&amp;quot; -p2p_port=&amp;quot;localhost:6661&amp;quot;   -peers=&amp;quot;localhost:6660&amp;quot; &amp;amp; 

sleep 1 

curl -v -XPOST &amp;quot;http://localhost:7001/addPeer&amp;quot; -d &#39;[localhost:6660]&#39; | jq 
sleep 2
curl -v -XPOST &amp;quot;http://localhost:7000/addPeer&amp;quot; -d &#39;[localhost:6661]&#39; | jq 
sleep 2

curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 
curl -v -XPOST &amp;quot;http://localhost:7001/mineBlock&amp;quot; -d &#39;hello word&#39; | jq 
sleep 1 


curl -v &amp;quot;http://localhost:7001/blocks&amp;quot; | jq 
sleep 1 

curl -v &amp;quot;http://localhost:7000/blocks&amp;quot; | jq 

curl -v &amp;quot;http://localhost:7000/peers&amp;quot; | jq 
curl -v &amp;quot;http://localhost:7001/peers&amp;quot; | jq 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æ¯”è¾ƒç®€å•ï¼Œæ‹¿æ¥çœ‹çœ‹å°±å¥½äº†ï¼Œåˆ«å¤ªåœ¨æ„&amp;hellip;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;åŸç‰ˆ &lt;a href=&#34;https://github.com/lhartikk/naivechain.git&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/lhartikk/naivechain.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>goimæºç å‰–æ1</title>
      <link>https://laohanlinux.github.io/2016/12/22/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%901/</link>
      <pubDate>Thu, 22 Dec 2016 00:47:22 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/12/22/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%901/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Goim Analysis of Source Code</title>
      <link>https://laohanlinux.github.io/2016/12/04/goim-analysis-of-source-code/</link>
      <pubDate>Sun, 04 Dec 2016 15:03:15 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/12/04/goim-analysis-of-source-code/</guid>
      <description>

&lt;h2 id=&#34;comet&#34;&gt;Comet&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;comet&lt;/code&gt;ä¸ºç”¨æˆ·ä»£ç†æœåŠ¡å™¨ï¼Œç”¨äºå®¢æˆ·ç«¯çš„è¿æ¥ï¼Œæ ¹æ®æƒ…å†µå¯éƒ¨ç½²å¤šä¸ª&lt;code&gt;comet&lt;/code&gt;(éƒ¨ç½²æœºæˆ¿é€‰æ‹©ä»¥ç”¨æˆ·æ¥å…¥ä¸ºåŸºç¡€ï¼Œå¦‚ï¼šæœ€è¿‘æ¥å…¥ã€æŒ‰è¿è¥å•†æ¥å…¥)ã€‚&lt;/p&gt;

&lt;h3 id=&#34;æµç¨‹å›¾&#34;&gt;æµç¨‹å›¾&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;comet&lt;/code&gt;æ”¯æŒ&lt;code&gt;tcp&lt;/code&gt;ä»¥åŠ&lt;code&gt;websocket&lt;/code&gt;çš„æ–¹å¼å’Œå®¢æˆ·ç«¯äº¤äº’ï¼Œè€Œå’Œ&lt;code&gt;logic&lt;/code&gt;ã€&lt;code&gt;job&lt;/code&gt;æ¨¡å—ä¹‹é—´çš„äº¤äº’é‡‡ç”¨&lt;code&gt;rpc&lt;/code&gt;çš„æ–¹å¼ï¼Œ&lt;code&gt;comet&lt;/code&gt;çš„ä¸»è¦æµç¨‹å›¾å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/comet-websocket.png&#34; alt=&#34;websocket&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; å›¾ 1-1ï¼š comet websocket protoc&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/comet-tcp.png&#34; alt=&#34;tcp&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt; å›¾ 1-2ï¼š comet tcp protoc&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;å®¢æˆ·ç«¯é¦–å…ˆè¿æ¥åˆ°&lt;code&gt;comet&lt;/code&gt;æœåŠ¡ï¼Œ&lt;code&gt;comet&lt;/code&gt;è°ƒç”¨&lt;code&gt;logic&lt;/code&gt;æ¥æ ¡éªŒç”¨æˆ·çš„åˆæ³•æ€§ï¼Œ&lt;code&gt;logic&lt;/code&gt;ä¼šè¿”å›ä¸€ä¸ª&lt;code&gt;subKey&lt;/code&gt;ç»™&lt;code&gt;comet&lt;/code&gt;ï¼Œè¯¥&lt;code&gt;subKey&lt;/code&gt;æˆä¸ºè¯¥è¿æ¥çš„å”¯ä¸€æ ‡ç¤ºï¼›&lt;/li&gt;
&lt;li&gt;å®¢æˆ·ç«¯æ¥ä¸‹æ¥å¯ä»¥å‘å¿ƒè·³åŒ…ç»™&lt;code&gt;comet&lt;/code&gt;ï¼ŒåŒæ—¶ï¼Œ&lt;code&gt;job&lt;/code&gt;æœåŠ¡å°†&lt;code&gt;MQ-Kafka&lt;/code&gt;çš„æ¶ˆæ¯è½¬å‘åˆ°å¯¹åº”&lt;code&gt;comet&lt;/code&gt;ï¼Œ&lt;code&gt;comet&lt;/code&gt;å†å°†å…¶è½¬å‘åˆ°å¯¹åº”çš„å®¢æˆ·ç«¯&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;å…¶ä¸­Logicå‰é¢å¯ä»¥åŠ ä¸Šä¸€å±‚4å±‚ä»£ç†æœåŠ¡å™¨ï¼Œå¦‚LVSã€‚&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ä¸»è¦é€»è¾‘ä»£ç åˆ†æ&#34;&gt;ä¸»è¦é€»è¾‘ä»£ç åˆ†æ&lt;/h3&gt;

&lt;h4 id=&#34;bucket&#34;&gt;bucket&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type BucketOptions struct {
	ChannelSize   int 
	RoomSize      int   // æˆ¿é—´ï¼ˆBucket.roomsï¼‰çš„åˆå§‹åŒ–ä¸ªæ•°
	RoutineAmount int64 // Bucket.routinesæ•°ç»„å¤§å°
    RoutineSize   int   // æˆ¿é—´ä¿¡é“é€šä¿¡(proto.BoardcastRoomArg)ç¼“å†²åŒºçš„å¤§å°
}

// Bucket is a channel holder.
type Bucket struct {
	cLock    sync.RWMutex        // protect the channels for chs
	chs      map[string]*Channel // map sub key to a channel
	boptions BucketOptions
	// room
	rooms       map[int32]*Room // bucket room channels
	routines    []chan *proto.BoardcastRoomArg // èŠ‚ç‚¹æˆ¿é—´çš„æ€»ä¿¡é“æ•°
	routinesNum uint64 // å¤„ç†routinesä¿¡é“çš„goroutineä¸ªæ•°ï¼Œç”¨äºæ¶ˆè´¹æˆ¿æ’­çš„ä¿¡é“æ¶ˆæ¯
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bucket-goroutine.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;å›¾ 1-3&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;æˆ¿é—´ä¿¡æ¯æ¨é€æµç¨‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1ã€jobé€šè¿‡rpcçš„æ–¹å¼å‘é€msgåˆ°comet
2ã€cometå†…éƒ¨å°†æ¶ˆæ¯æ¨é€åˆ°è‡³bucket.routinesï¼Œbucket.routinesä»¥è½®è¯¢çš„æ–¹å¼é€‰å‡ºä¸€ä¸ªproto.BoardcastRoomArgä¿¡é“è¿›è¡Œæ¶ˆæ¯è½¬å‘
3ã€bucket.routines&#39;s worker æ¶ˆè´¹æ¶ˆæ¯ï¼Œæ ¹æ®msg&#39;roomidä»roomsMap(bucket.rooms)é€‰å‡ºè¯¥roomçš„æ‰€æœ‰å®¢æˆ·ç«¯Channelsï¼Œå†å°†æ¶ˆæ¯ä¸€ä¸€è½¬å‘è‡³client&#39;Channel
4ã€dispatchWorkeræ¶ˆè´¹client&#39;Channelæ¶ˆæ¯ï¼Œé€šè¿‡websocketæˆ–è€…tcpåè®®å‘é€åˆ°å®¢æˆ·ç«¯
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å•æ’­æ¨é€æµç¨‹ï¼š&lt;/p&gt;

&lt;p&gt;å•æ’­ç›¸å¯¹äº&amp;rdquo;æˆ¿æ’­ï¼ˆç¾¤æ’­ï¼‰&amp;rdquo;ï¼Œç®€åŒ–äº†æˆ¿é—´æ£€ç´¢çš„æ­¥éª¤ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1ã€jobé€šè¿‡rpcçš„æ–¹å¼å‘é€msgåˆ°comet
2ã€cometå†…éƒ¨æ ¹æ®æ¶ˆæ¯çš„subKeyï¼Œä»bucketsä¸­æ‰¾å‡ºå¯¹åº”çš„channelï¼Œå°†æ¶ˆæ¯è½¬å‘åˆ°å¯¹åº”çš„Channel
3ã€dispatchWorkeræ¶ˆè´¹client&#39;Channelæ¶ˆæ¯ï¼Œé€šè¿‡websocketæˆ–è€…tcpåè®®å‘é€åˆ°å®¢æˆ·ç«¯
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;æ³¨ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; subKeyçš„ç”Ÿæˆé‡‡ç”¨city32çš„hashç®—æ³•ï¼Œbucketæ˜¯ä¸€ä¸ªå¤§å°ä¸ºnçš„hashMap sliceï¼Œå…¶ä¸»è¦ç›®çš„æ˜¯å°†æ•°æ®åˆ‡åˆ†æˆæ›´å°çš„å—ï¼Œä»è€Œé™ä½èµ„æºçš„ç«äº‰ã€‚
&amp;gt; ```

å¤šæ’­ä»¥å•æ’­æ¨é€æµç¨‹ç±»ä¼¼ï¼Œå¹¿æ’­ä¹Ÿç±»ä¼¼ã€‚

#### room

```go
type Room struct {
	id     int32        // æˆ¿é—´å·
	rLock  sync.RWMutex // é”
	next   *Channel     // è¯¥æˆ¿é—´çš„æ‰€æœ‰å®¢æˆ·ç«¯çš„Channel
	drop   bool         // æ ‡ç¤ºæˆ¿é—´æ˜¯å¦å­˜æ´»
	Online int          // æˆ¿é—´çš„channelæ•°é‡ï¼Œå³æˆ¿é—´çš„åœ¨çº¿ç”¨æˆ·çš„å¤šå°‘
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;next *Channel&lt;/code&gt;æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œå¤æ‚åº¦ä¸º&lt;code&gt;o(1)&lt;/code&gt;ï¼Œæ•ˆç‡æ¯”è¾ƒé«˜ã€‚&lt;/p&gt;

&lt;h4 id=&#34;tcp&#34;&gt;tcp&lt;/h4&gt;

&lt;p&gt;åè®®ï¼š&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/tcp-proto.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;å›¾ 1-4&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BodySize&lt;/code&gt;èŒƒå›´ï¼š&lt;code&gt;0&amp;lt;=BodySize&amp;lt;=MaxBodySize = int32(1&amp;lt;&amp;lt;10)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PackSize&lt;/code&gt;èŒƒå›´ï¼š&lt;code&gt;RawHeaderSize&amp;lt;=PackSize&amp;lt;=MacPackSize(RawHeaderSize+BodySize)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Terry-Mao/goim/blob/master/doc/protocol.png&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;å®˜ç½‘&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;websocket&#34;&gt;websocket&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Terry-Mao/goim/blob/master/doc/proto.md&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;websocketåè®®&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;rpc&#34;&gt;RPC&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;rpc&lt;/code&gt;ç”¨äº&lt;code&gt;logic&lt;/code&gt;ã€&lt;code&gt;job service&lt;/code&gt;æ¨¡å—çš„é€šä¿¡ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Push RPC
type PushRPC struct {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) Ping(arg *proto.NoArg, reply *proto.NoReply) error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¿ƒè·³&lt;code&gt;rpc&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) PushMsg(arg *proto.PushMsgArg, reply *proto.NoReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æ ¹æ®æŒ‡å®šçš„&lt;code&gt;subKey&lt;/code&gt;æ¨é€æ¶ˆæ¯&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) MPushMsg(arg *proto.MPushMsgArg, reply *proto.MPushMsgReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æ ¹æ®æŒ‡å®šçš„&lt;code&gt;subKey&lt;/code&gt;ä¸€æ¬¡æ¨é€å¤šä¸ªæ¶ˆæ¯ï¼Œä¸»è¦ç”¨äº&lt;code&gt;ç¾¤æ’­&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) MPushMsgs(arg *proto.MPushMsgsArg, reply *proto.MPushMsgsReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¤šæ’­&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) Broadcast(arg *proto.BoardcastArg, reply *proto.NoReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¹¿æ’­&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) BroadcastRoom(arg *proto.BoardcastRoomArg, reply *proto.NoReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æŒ‰æˆ¿é—´æ¨é€&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (this *PushRPC) Rooms(arg *proto.NoArg, reply *proto.RoomsReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è·å–æ‰€æœ‰æˆ¿é—´ï¼ŒåŒ…æ‹¬ä¸‹çº¿çš„æˆ¿é—´&lt;/p&gt;

&lt;h4 id=&#34;ring&#34;&gt;ring&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/comet-ring.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;å›¾ 1-5&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ring&lt;/code&gt;æ˜¯ä¸€ä¸ªç¯å½¢å¯¹è±¡æ± ï¼Œç”¨äºç®¡ç†åè®®å¯¹è±¡-&lt;code&gt;proto&lt;/code&gt;ï¼Œå…¶å†…å­˜ç»“æ„å¦‚å›¾æ‰€ç¤ºï¼Œ&lt;code&gt;rp&lt;/code&gt;ä¸ºå¯è¯»æ¸¸æ ‡ï¼Œwpä¸ºå¯å†™æ¸¸æ ‡ï¼Œå†…å­˜çš„å¤§å°ä¸º&lt;code&gt;4&lt;/code&gt;çš„æ•´æ•°å€ã€‚&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) Get() (proto *proto.Proto, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è·å–ä¸€ä¸ª&lt;code&gt;proto&lt;/code&gt;å¯¹è±¡çš„å¼•ç”¨ï¼Œç”¨äºè¯»ï¼Œä¸ä¼šç§»åŠ¨å¯è¯»æ¸¸æ ‡&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) GetAdv()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ç§»åŠ¨å¯è¯»æ¸¸æ ‡&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) Set() (proto *proto.Proto, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è·å–ä¸€ä¸ª&lt;code&gt;proto&lt;/code&gt;å¯¹è±¡çš„å¼•ç”¨ï¼Œç”¨äºå†™ï¼Œä¸ä¼šç§»åŠ¨å¯å†™æ¸¸æ ‡&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) SetAdv()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ç§»åŠ¨å¯å†™æ¸¸æ ‡&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *Ring) Reset()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é‡ç½®&lt;code&gt;pool&lt;/code&gt;å¯¹è±¡&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;æ³¨ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; å¦‚æœwpç§»åŠ¨è¿‡å¿«ï¼Œä¼šå½±å“rpæ¸¸æ ‡æŒ‡å‘çš„æ•°æ®ï¼Œå¦‚å›¾ï¼š
&amp;gt; ```

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/comet-ring-1.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;å›¾ 1-6&amp;lt;/center&amp;gt;

å½“ç¨‹åºè¿è¡Œåˆ°ç¬¬`3`æ­¥çš„æ—¶å€™ï¼Œ`wp`å·²ç»åˆé‡æ–°è¶…è¿‡`rp`çš„ç´¢å¼•äº†ï¼Œè¿™æ—¶å€™ï¼Œç¬¬`6`ä¸ªå¯¹è±¡è¿˜æ²¡è¢«`rp`è¯»å–è¿‡ï¼Œä½†æ˜¯å®ƒçš„æ•°æ®å·²ç»è¢«ä¿®æ”¹äº†ï¼Œè¿™æ ·å³ä½¿`rp`è¯»å–ç¬¬6ä¸ªå¯¹è±¡ï¼Œä¹Ÿæ˜¯ä¸€ä¸ª`dirty`å¯¹è±¡ã€‚

#### Signal

ä¿¡å·å¤„ç†æ¨¡å—ï¼Œå¯ç”¨äºåœ¨çº¿åŠ è½½é…ç½®ï¼Œé…ç½®åŠ¨æ€åŠ è½½çš„ä¿¡å·ä¸º`SIGHUP`ã€‚

## Job

`Job`è´Ÿè´£æ¶ˆè´¹`kafka`æ¶ˆæ¯ï¼Œç„¶åè½¬å‘è‡³`comet`ã€‚

### å•/å¤šæ’­

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt;å¤šæ’­.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;å›¾ 2-1&amp;lt;/center&amp;gt;

### å¹¿æ’­

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt; å¹¿æ’­.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;å›¾ 2-2&amp;lt;/center&amp;gt;

### æŒ‰æˆ¿é—´æ¨é€

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt;æŒ‰æˆ¿é—´æ¨é€.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;å›¾ 2-3&amp;lt;/center&amp;gt;

### ä¸»è¦é€»è¾‘ä»£ç åˆ†æ

#### comet

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/Job=&amp;gt;comet.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;å›¾ 3-4&amp;lt;/center&amp;gt;

```go
type CometOptions struct {
	RoutineSize int64 // æ¯ä¸ªcomet rpc goroutineä¸ªæ•°
	RoutineChan int   // æ¯ä¸ªåè®®é€šé“çš„ç¼“å†²å¤§å°
}

type Comet struct {
	serverId             int32                      		// comet service id
	rpcClient            *xrpc.Clients              		// rpcè¿æ¥å¯¹è±¡
	pushRoutines         []chan *proto.MPushMsgArg  		// å•/å¤šæ’­ä¿¡é“
	broadcastRoutines    []chan *proto.BoardcastArg      	// å¹¿æ’­ä¿¡é“
	roomRoutines         []chan *proto.BoardcastRoomArg  	// ç¾¤æ’­-æˆ¿æ’­ä¿¡é“
	pushRoutinesNum      int64 								// å•/å¤šæ’­åè®®ä¿¡é“=ã€‹ç”¨äºå¾ªç¯
	roomRoutinesNum      int64 								// æˆ¿æ’­-ç¾¤æ’­åè®®ä¿¡é“=ã€‹
	broadcastRoutinesNum int64 								// å¹¿æ’­åè®®ä¿¡é“=ã€‹
	options              CometOptions
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) Push(arg *proto.MPushMsgArg) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¾ªç¯é€‰æ‹©ä¸€ä¸ª&lt;code&gt;MPushMsgArg channel&lt;/code&gt;ï¼Œå°†æ¶ˆæ¯æ¨é€è‡³è¯¥ä¿¡é“&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) BroadcastRoom(arg *proto.BoardcastRoomArg) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æŒ‰ç…§æˆ¿é—´æ¨é€ï¼Œå¾ªç¯é€‰æ‹©ä¸€ä¸ª&lt;code&gt;BoardcastRoomArg Channel&lt;/code&gt;ï¼Œå°†æ¶ˆæ¯æ¨é€è‡³è¯¥ä¿¡é“&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) Broadcast(arg *proto.BoardcastArg) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¹¿æ’­ï¼Œå¾ªç¯é€‰æ‹©ä¸€ä¸ª&lt;code&gt;BoardcastArg Channe&lt;/code&gt;ï¼Œå°†æ¶ˆæ¯æ¨é€è‡³è¯¥ä¿¡é“&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (c *Comet) process(pushChan chan *proto.MPushMsgArg, roomChan chan *proto.BoardcastRoomArg, broadcastChan chan *proto.BoardcastArg)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;IO&lt;/code&gt;å¤ç”¨åç¨‹ï¼Œä½œä¸º&lt;code&gt;pushChan&lt;/code&gt;ï¼Œ&lt;code&gt;roomChan&lt;/code&gt;ï¼Œ&lt;code&gt;broadcastChan&lt;/code&gt;ä¿¡é“çš„æ¶ˆè´¹è€…ï¼Œæ¶ˆè´¹å®Œåï¼Œè½¬å‘&lt;code&gt;comet service&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;room&#34;&gt;room&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RoomBucket struct {
	roomNum int 
	rooms   map[int32]*Room
	rwLock  sync.RWMutex
	options RoomOptions
	round   *Round
}
type RoomOptions struct {
	BatchNum   int  			//æ±‡æ€»é˜ˆå€¼
	SignalTime time.Duration
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;room&lt;/code&gt;æ¨¡å—ç”¨äºæ¥æ”¶&lt;code&gt;kafka&lt;/code&gt;çš„&lt;code&gt;push&lt;/code&gt;æ¨¡å—å‘é€çš„æ¶ˆæ¯ï¼Œæ¯ä¸ª&lt;code&gt;room&lt;/code&gt;éƒ½æœ‰ä¸€ä¸ªåç¨‹ï¼Œå…¶åç¨‹çš„ä¿¡é“ç¼“å†²åŒºçš„å¤§å°ä¸º&lt;code&gt;RoomOptions.BatchNum&lt;/code&gt;çš„ä¸¤å€ã€‚&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;æ³¨ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 1ã€roomåç¨‹åœ¨æ¥æ”¶åˆ°çš„æ¶ˆæ¯æ¡æ•°&amp;gt;=BatchNum*2æˆ–è€…timeoutæ—¶ï¼Œæ‰ä¼šè§¦å‘è½¬å‘æ¶ˆæ¯çš„è¡Œä¸º(è½¬å‘è‡³broadcastRoutines)ï¼Œå³å…¶å…·æœ‰æ±‡æ€»æ“ä½œã€‚
&amp;gt; 
&amp;gt; 2ã€æˆ¿é—´çš„æ¶ˆæ¯ä½¿ç”¨äº†Libs/bytes.Writerè¿›è¡Œæ±‡æ€»ç¼“å­˜ã€‚
&amp;gt; ```

#### push/kafka

`push/kafka`æ¨¡å—ç”¨äºé¢„å¤„ç†æ¶ˆæ¯ï¼Œæ¶ˆæ¯ä»`kafkaé›†ç¾¤`æµå‡ºï¼Œç»è¿‡`kafka`æ¨¡å—è½¬å‘è‡³`push`æ¨¡å—ï¼Œ`push`æ¨¡å—å¯¹æ¶ˆæ¯é¢„å¤„ç†/è¿‡æ»¤/åˆ†ç±»ï¼Œç„¶åå‘è‡³ä¸åŒçš„`comet ä¿¡é“`ä¸­ï¼Œå…·ä½“ä½¿ç”¨è¯·å‚ç…§`Jobçš„`å‰3ç« å›¾.

æ¶ˆæ¯çš„åˆ†ç±»ï¼š

- `KAFKA_MESSAGE_MULTI`=&amp;gt;å¤šæ’­

- `KAFKA_MESSAGE_BROADCAST`=&amp;gt;å¹¿æ’­

- `KAFKA_MESSAGE_BROADCAST_ROOM`=&amp;gt;ç¾¤æ’­/æˆ¿æ’­

#### Round/RoundOptions

æ—¶é’Ÿç®¡ç†å™¨



## Logic

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/logic-router.png)&amp;lt;/center&amp;gt;

&amp;lt;center&amp;gt;å›¾ 3-5&amp;lt;/center&amp;gt;

`Logic`æ˜¯`goim`æ˜¯ä¸»è¦ä¸šåŠ¡å¤„ç†æ¨¡å—ï¼Œè´Ÿè´£çš„å†…å®¹æœ‰ï¼š

- æ³¨å†Œ/æ³¨é”€
- éªŒè¯
- æ¶ˆæ¯`Push`ä»£ç†

### åè®®

#### Pushåè®®

[linked](https://github.com/Terry-Mao/goim/blob/master/doc/push.md)

å…¶ä¸­`ensure`å‚æ•°æ˜¯é¢å¤–çš„å‚æ•°ï¼Œç”¨äºæ§åˆ¶æ¶ˆæ¯æ˜¯å¦å¿…è¾¾ï¼Œä¸ºå¸ƒå¶å€¼ã€‚

#### å…¶ä»–httpåè®®

##### åˆ é™¤comet service

| æ¥å£å                                | URL             | è®¿é—®æ–¹å¼ |
| ------------------------------------- | --------------- | -------- |
| åˆ é™¤`comet service`                   | `/1/server/del` | `POST`   |
| è·å–æ‰€æœ‰`comet service`æˆ–è€…`room`ä¿¡æ¯ | `/1/count`      | `POST`   |

è¯·æ±‚ä¾‹å­ï¼š

- `/1/server/del`

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl -XPOST &amp;ldquo;&lt;a href=&#34;http://127.0.0.1:7172/1/server/del?server=1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://127.0.0.1:7172/1/server/del?server=1&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
- `/1/count`

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl -XPOST &amp;ldquo;&lt;a href=&#34;http://127.0.0.1:7172/1/count?type=room&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://127.0.0.1:7172/1/count?type=room&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
### ä¸»è¦é€»è¾‘ä»£ç åˆ†æ

#### Auth

```go
type Auther interface {
	Auth(token string) (userId int64, roomId int32)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;ç”¨æˆ·éªŒè¯æ¨¡å—&lt;/p&gt;

&lt;h4 id=&#34;router&#34;&gt;router&lt;/h4&gt;

&lt;p&gt;è´Ÿè´£ä¸&lt;code&gt;Router Service&lt;/code&gt;äº¤äº’ï¼Œå¤šä¸ª&lt;code&gt;Router Service&lt;/code&gt;é‡‡ç”¨çš„æ˜¯ä¸€è‡´æ€§&lt;code&gt;hash&lt;/code&gt;ç®—æ³•ï¼Œ&lt;code&gt;hash&lt;/code&gt;çš„è¾“å…¥ä¸º&lt;code&gt;Router Serviceid&lt;/code&gt;ï¼Œé»˜è®¤æ‰€æœ‰çš„&lt;code&gt;Router Service&lt;/code&gt;æƒå€¼æ˜¯ä¸€æ ·çš„ï¼Œå¦‚æœéœ€è¦æ§åˆ¶ä¸åŒçš„æƒå€¼ï¼Œå¯ä»¥åœ¨é…ç½®&lt;code&gt;router service&lt;/code&gt;çš„æ—¶å€™åŠ å¤šä¸ªç«¯å£å®ä¾‹æˆ–è€…åŒä¸€ä¸ªèŠ‚ç‚¹é…ç½®æˆå¤šä¸ª&lt;code&gt;serviceid&lt;/code&gt;æ ‡ç­¾ã€‚&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;æ³¨ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; ä¸€è‡´æ€§hashæ²¡æœ‰å®ç°åŠ¨æ€æ‰©å®¹ï¼Œå³æ²¡æœ‰è‡ªåŠ¨å¹³è¡¡ï¼Œæ‰€ä»¥ä¸èƒ½å¤ŸåŠ¨æ€æ”¹å˜Router serviceæ˜ å°„é…ç½®ï¼Œä¸”æ¯ä¸ªLogicèŠ‚ç‚¹çš„Router Serviceé…ç½®é¡¹éœ€ä¿æŒä¸€è‡´ã€‚
&amp;gt; ```

- func getRouterByServer(server string) (*xrpc.Clients, error)

é€šè¿‡`router serverid`è·å–å¯¹åº”çš„`router service client`

- func getRouterByUID(userID int64) (*xrpc.Clients, error)

é€šè¿‡`userID`è·å–`router service client`

- func getRouterNode(userID int64) string

é€šè¿‡`userID`è·å–åˆ°`Router èŠ‚ç‚¹`

- func connect(userID int64, server, roomId int32) (seq int32, err error)

æ³¨å†Œã€éªŒè¯ç”¨æˆ·ï¼Œè¿”å›ä¸€ä¸ªè‡ªå¢åºåˆ—å·(`cometServiceID_incr`)

- func disconnect(userID int64, seq, roomId int32) (has bool, err error)

æ³¨é”€ä¸€ä¸ªç”¨æˆ·

- func delServer(server int32) (err error)

ä¸‹çº¿ä¸€ä¸ª`comet service`

- func allRoomCount(client *xrpc.Clients) (counter map[int32]int32, err error

è·å–æ‰€æœ‰æˆ¿é—´ä¸ªæ•°

- func allServerCount(client *xrpc.Clients) (counter map[int32]int32, err error)

è·å–æ‰€æœ‰`comet-service`

- func genSubKey(userId int64) (res map[int32][]string)

é€šè¿‡ç”¨æˆ·`ID`ç”Ÿæˆ`subKey`ï¼›åŒä¸€ä¸ªç”¨æˆ·å¯ä»¥åŒæ—¶å¤šå¤„ç™»é™†æˆ–è€…åŒå¤„å¤šå®ä¾‹ç™»é™†ï¼Œå®ƒä»¬éƒ½ä¼šè¢«åŒç­‰å¯¹å¾…ã€‚

`subKeyç”Ÿæˆä»£ç ï¼š`

```go
func encode(userId int64, seq int32) string {
	return fmt.Sprintf(&amp;quot;%d_%d&amp;quot;, userId, seq)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;seq&lt;/code&gt;ä¸ºæ¯ä¸ª&lt;code&gt;comet service&lt;/code&gt;çš„è‡ªå¢é•¿åºç´¢å¼•ï¼Œå‡è®¾&lt;code&gt;comet service 1&lt;/code&gt;æ¥å—åˆ°ä¸€ä¸ªç”¨æˆ·è¯·æ±‚ï¼Œç”¨æˆ·çš„&lt;code&gt;ID&lt;/code&gt;ä¸º&lt;code&gt;10&lt;/code&gt;ï¼Œè€Œæ­¤æ—¶&lt;code&gt;Router buckets&lt;/code&gt;çš„&lt;code&gt;seqIdx&lt;/code&gt;ä¸º&lt;code&gt;9&lt;/code&gt;ï¼Œåˆ™&lt;code&gt;subKey = 10_9&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func getSubKeys(res chan *proto.MGetReply, serverId string, userIds []int64) | func genSubKeys(userIds []int64) (divide map[int32][]string)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¹¶è¡Œè·å–å¤šä¸ªç”¨æˆ·ä¿¡æ¯ï¼Œè¿”å›å€¼ä¸º&lt;code&gt;map[comet.serverId][]subkey&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;rpc-1&#34;&gt;rpc&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RPC
type RPC struct {
	auther Auther
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LogicService&lt;/code&gt;ç”¨äºå¿ƒè·³çš„æ£€æµ‹ä»¥åŠå®¢æˆ·ç«¯çš„æ³¨å†Œ/æ³¨é”€ã€‚&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *RPC) Connect(arg *proto.ConnArg, reply *proto.ConnReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æ³¨å†Œ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (r *RPC) Disconnect(arg *proto.DisconnArg, reply *proto.DisconnReply) (err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æ³¨é”€&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;æ³¨ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; goimä¸æ”¯æŒç¦»çº¿æ¶ˆæ¯ï¼Œå¦‚æœéœ€è¦æ”¯æŒç¦»çº¿æ¶ˆæ¯çš„æ¨é€ï¼Œåº”hookè¯¥æ¨¡å—ï¼Œå®ç°ç¦»çº¿æ¶ˆæ¯æ¨é€é€»è¾‘
&amp;gt; ```

## Router

### ä¸»è¦é€»è¾‘ä»£ç åˆ†æ

#### session

```go
type Session struct {
	seq     int32                     // åºåˆ—å·è‡ªå¢æ ‡è®°å™¨
	servers map[int32]int32           // seq:server
	rooms   map[int32]map[int32]int32 // roomid:seq:server with specified room id
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;å®¢æˆ·ç«¯ä¼šè¯ä¿¡æ¯ç®¡ç†ï¼Œä»¥ç”¨æˆ·&lt;code&gt;id&lt;/code&gt;ä¸ºå•ä½ï¼Œå³æ¯ä¸ªç”¨æˆ·æœ‰ä¸”æ‹¥æœ‰ä¸€ä¸ª&lt;code&gt;session&lt;/code&gt;ï¼Œ&lt;code&gt;session&lt;/code&gt;åŒ…å«äº†ç”¨æˆ·æ¯ä¸ªè¿æ¥çš„&lt;code&gt;comet service&lt;/code&gt;ä¿¡æ¯ï¼Œä»¥åŠæ¯ä¸ªè¿æ¥æ‰€å±çš„&lt;code&gt;roomid&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Put(server int32) (seq int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å…³è”ä¸€ä¸ª&lt;code&gt;subKey&lt;/code&gt;å’Œ&lt;code&gt;session&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) PutRoom(server int32, roomId int32) (seq int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å…³è”ä¸€ä¸ª&lt;code&gt;subKey&lt;/code&gt;åˆ°&lt;code&gt;comet servicey&lt;/code&gt; ä»¥åŠ&lt;code&gt;room&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Servers() (seqs []int32, servers []int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¿”å›&lt;code&gt;session&lt;/code&gt;å…³è”çš„æ‰€æœ‰&lt;code&gt;comet service&lt;/code&gt;ä¿¡æ¯&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Del(seq int32) (has, empty bool, server int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;åˆ é™¤æŒ‡å®šçš„&lt;code&gt;subKey&lt;/code&gt;æ‰€å…³è”çš„&lt;code&gt;Session.Servers&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) DelRoom(seq int32, roomId int32) (has, empty bool, server int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;åˆ é™¤æŒ‡å®šçš„&lt;code&gt;subKey&lt;/code&gt;ã€&lt;code&gt;roomid&lt;/code&gt;æ‰€å…³è”çš„&lt;code&gt;Session.rooms&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (s *Session) Count() int&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¿”å›&lt;code&gt;session&lt;/code&gt;æ‰€å…³è”çš„æ‰€æœ‰&lt;code&gt;comet service&lt;/code&gt;ä¿¡æ¯&lt;/p&gt;

&lt;h4 id=&#34;bucket-1&#34;&gt;bucket&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Bucket struct {
	bLock             sync.RWMutex
	server            int                       // session server map init num
	session           int                       // bucket session init num
	sessions          map[int64]*Session        // userid-&amp;gt;sessions, ä¸€ä¸ªå¯èƒ½åŒæ—¶å¤šå¤„ç™»é™†
	roomCounter       map[int32]int32           // roomid-&amp;gt;count
	serverCounter     map[int32]int32           // server-&amp;gt;count
	userServerCounter map[int32]map[int64]int32 // serverid-&amp;gt;userid count
	cleaner           *Cleaner                  // bucket map cleaner
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) counter(userId int64, server int32, roomId int32, incr bool)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¢åŠ ä¸€ä¸ªç”¨æˆ·æˆ–è€…å‡å°‘ä¸€ä¸ªç”¨æˆ·&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) Put(userId int64, server int32, roomId int32) (seq int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å…³è”&lt;code&gt;channel(session)&lt;/code&gt;åˆ°æŒ‡å®šçš„ç”¨æˆ·&lt;code&gt;id&lt;/code&gt;ï¼Œ&lt;code&gt;comet id&lt;/code&gt;ä»¥åŠ&lt;code&gt;room id&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) Get(userId int64) (seqs []int32, servers []int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æŒ‡å®šç”¨æˆ·çš„&lt;code&gt;session&lt;/code&gt;ä¿¡æ¯&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Bucket) GetAll() (userIds []int64, seqs [][]int32, servers [][]int32)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¿”å›è¯¥&lt;code&gt;bucket&lt;/code&gt;çš„æ‰€æœ‰ç”¨æˆ·ã€&lt;code&gt;subKey&lt;/code&gt;ã€&lt;code&gt;comet&lt;/code&gt;ä¿¡æ¯&lt;/p&gt;

&lt;p&gt;å…¶ä»–å‡½æ•°çœç•¥&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;cleaner&#34;&gt;cleaner&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type CleanData struct {
	Key        int64
	expireTime time.Time
	next, prev *CleanData
}

type Cleaner struct {
	cLock sync.Mutex
	size  int
	root  CleanData
	maps  map[int64]*CleanData
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lru&lt;/code&gt;å¯¹è±¡ç®¡ç†å™¨ï¼Œåªè´Ÿè´£ç®¡ç†ï¼Œä¸è´Ÿè´£è§¦å‘&lt;code&gt;GC&lt;/code&gt;ï¼Œ&lt;code&gt;GC&lt;/code&gt;äº¤ç»™&lt;code&gt;Runtime&lt;/code&gt;å¤„ç†ã€‚&lt;/p&gt;

&lt;p&gt;ä¸»è¦åº”ç”¨äºå®¢æˆ·ç«¯çš„&lt;code&gt;session&lt;/code&gt;ç®¡ç†ï¼Œå®šæ—¶å¤„ç†æ‰ä¸€äº›è¿‡æœŸçš„&lt;code&gt;session&lt;/code&gt;å¯¹è±¡ã€‚&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1ã€æ•°æ®ç»“æ„ä½¿ç”¨mapå’ŒåŒå‘åˆ—è¡¨ï¼Œmapç”¨äºå¿«é€Ÿæ£€ç´¢ï¼›&lt;/p&gt;

&lt;p&gt;2ã€åŒå‘é“¾è¡¨ç”¨äºå¿«é€Ÿå‰”é™¤æ•°æ®ï¼šå› ä¸ºä»mapä¸­å‰”é™¤æ•°æ®ï¼Œmapçš„ç»“æ„ä¼šå®æ—¶æ”¹å˜ï¼Œæ¯å‰”é™¤ä¸€ä¸ªéƒ½å¾—å†æ¬¡ä»èµ·ç‚¹å¼€å§‹éå†mapï¼Œè€Œä½¿ç”¨é“¾è¡¨ä¸ç”¨é‡æ–°éå†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º&lt;code&gt;O(logN)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;libs&#34;&gt;Libs&lt;/h2&gt;

&lt;h3 id=&#34;ç¼“å†²io-bufio&#34;&gt;ç¼“å†²io-bufio&lt;/h3&gt;

&lt;h4 id=&#34;reader&#34;&gt;Reader&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Reader struct {
  	buf []byte
  	rd	io.Reader
  	r, w int
  	err error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt;æ˜¯ä¸€ä¸ªå…·æœ‰ç¼“å­˜çš„å¯è¯»&lt;code&gt;IO&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bufio-reader.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;å›¾ 5-1&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ä¸»è¦å‡½æ•°&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Reset(r io.Reader)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é‡ç½®&lt;code&gt;IO&lt;/code&gt;ï¼Œå¯è¯»æ¸¸æ ‡é‡ç½®ä¸º&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) ResetBuffer(r io.Reader, buf []byte)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é‡ç½®&lt;code&gt;IO&lt;/code&gt;ï¼Œå¯è¯»æ¸¸æ ‡é‡ç½®ä¸º&lt;code&gt;0&lt;/code&gt;ï¼Œä¸”&lt;code&gt;b.buf&lt;/code&gt;å˜ä¸º&lt;code&gt;buf&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Peek(n int) ([]byte, error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;çª¥æ¢ç¼“å­˜çš„&lt;code&gt;n&lt;/code&gt;ä¸ªå­—èŠ‚ï¼Œå¯è¯»æ¸¸æ ‡ç»´æŒä¸å˜ï¼Œå¯å†™æ¸¸æ ‡å¯èƒ½ä¼šæ”¹å˜;&lt;/p&gt;

&lt;p&gt;å¦‚æœå¯çª¥æ¢çš„æ•°æ®å°‘äº&lt;code&gt;n&lt;/code&gt;ï¼Œåˆ™è°ƒç”¨&lt;code&gt;b.fill()&lt;/code&gt;å°è¯•è¯»å–è¿œç«¯æ•°æ®ç”¨äºå¡«å……&lt;code&gt;b.buf&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Pop(n int) ([]byte, error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¿”å›&lt;code&gt;[b.r:b.r+n]&lt;/code&gt;å¤„çš„æ•°æ®ï¼Œè¯¥å‡½æ•°ä¼šè°ƒç”¨&lt;code&gt;b.Peek&lt;/code&gt;ï¼Œè€Œä¸”ä¼šæ”¹å˜å¯è¯»æ¸¸æ ‡å’Œç§‘åæ¸¸æ ‡&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Discard(n int) (discarded int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ä¸¢å¼ƒ&lt;code&gt;n&lt;/code&gt;ä¸ªæ•°æ®ï¼›å¦‚æœç¼“å†²åŒºçš„å¯è¯»æ•°æ®å°äº&lt;code&gt;n&lt;/code&gt;ï¼Œåˆ™ä¸€è‡´è°ƒç”¨&lt;code&gt;b.fill()&lt;/code&gt;å°è¯•è¯»å–è¿œç¨‹çš„æ•°æ®ï¼Œç›´åˆ°&lt;code&gt;b.buf&lt;/code&gt;çš„å¯è¯»ç¼“å†²åŒºå¤§äºæˆ–è€…ç­‰äº&lt;code&gt;n&lt;/code&gt;æˆ–è€…å‡ºç°ç½‘ç»œå¼‚å¸¸ä¸ºæ­¢&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) Read(p []byte) (n int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¯»å–ç¼“å†²åŒºæ•°æ®ï¼›&lt;/p&gt;

&lt;p&gt;å¦‚æœç¼“å†²åŒºä¸ºç©ºï¼Œä¸ºäº†æé«˜æ•ˆç‡ï¼Œé¿å…åº”ç”¨å±‚çš„æ•°æ®æ‹·è´ï¼ˆ&lt;code&gt;kernel net stack=&amp;gt;b.buf==&amp;gt;p&lt;/code&gt;ï¼‰ï¼Œç›´æ¥å°†&lt;code&gt;kernel net stack&lt;/code&gt;æ‹·è´åˆ°&lt;code&gt;p []byte&lt;/code&gt;ï¼Œå¹¶ä¸”è°ƒç”¨&lt;code&gt;f.fill()&lt;/code&gt;æ•´ç†ç¼“å†²åŒº.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Reader) fill()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bufio-reader-fill.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;å›¾ 5-2&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;è¯»å–è¿œç¨‹æ–°å—æ•°æ®åˆ°æœ¬åœ°ç¼“å†²åŒºçš„&lt;code&gt;b.buf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fill&lt;/code&gt;ä¼šæœ‰æ•°æ®çš„ç§»åŠ¨ï¼Œå¦‚&lt;code&gt;å›¾ 5-2&lt;/code&gt;æ‰€ç¤ºã€‚&lt;/p&gt;

&lt;h4 id=&#34;writer&#34;&gt;Writer&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Writer struct {
	err error
	buf []byte
	n   int
	wr  io.Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Writer&lt;/code&gt;æ˜¯ä¸€ä¸ªå…·æœ‰ç¼“å­˜çš„å¯å†™&lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Reset(w io.Writer) {&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é‡ç½®&lt;code&gt;IO&lt;/code&gt;ï¼Œå¯å†™æ¸¸æ ‡é‡ç½®ä¸º&lt;code&gt;0&lt;/code&gt;ï¼Œå¥æŸ„å˜ä¸º&lt;code&gt;w&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) ResetBuffer(w io.Writer, buf []byte)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é‡ç½®&lt;code&gt;IO&lt;/code&gt;ï¼Œå¯å†™æ¸¸æ ‡é‡ç½®ä¸º&lt;code&gt;0&lt;/code&gt;ï¼Œå¥æŸ„å˜ä¸º&lt;code&gt;w&lt;/code&gt;ï¼Œç¼“å†²åŒºå˜ä¸º&lt;code&gt;buf&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) flush() error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;åˆ·æ–°ç¼“å†²åŒºï¼Œå°†æœ¬åœ°ç¼“å†²åŒºçš„æ•°æ®å‘é€è‡³å†…æ ¸ç½‘ç»œæ ˆï¼›&lt;/p&gt;

&lt;p&gt;æ¸¸æ ‡è¢«é‡ç½®ï¼ˆä¸ä¸€å®šä¼šè¢«é‡ç½®ä¸º0ï¼Œå¯èƒ½ä¸ºå…¶ä»–å€¼ï¼Œå› ä¸ºæœ¬åœ°ç¼“å†²çš„æ•°æ®å¤§äºå†…æ ¸å¯å†™ç¼“å†²åŒºï¼Œè¿™æ—¶è¿˜ä¼šé€ æˆæ•°æ®çš„æ¬è¿ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bufio-writer.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Available() int&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¯å†™å­—èŠ‚æ•°&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Buffered()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å·²å†™ç¼“å†²å¤§å°&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Write(p []byte) (nn int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å°†&lt;code&gt;p []byte&lt;/code&gt;å†™åˆ°ç¼“å†²åŒºæˆ–è€…ç›´æ¥å†™åˆ°ç½‘ç»œå†…æ ¸æ ˆï¼ˆæ­¤æ—¶ç¼“å†²åŒºå·²æ»¡ï¼‰ï¼Œå¯èƒ½é€ æˆå¯å†™æ¸¸æ ‡çš„ç§»åŠ¨&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) WriteRaw(p []byte) (nn int, err error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å’Œb.Write()ç±»ä¼¼&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (b *Writer) Peek(n int) ([]byte, error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;çª¥æ¢å¯å†™ç¼“å†²åŒºå‰©ä½™å€¼ï¼Œå¦‚æœå¯å†™ç¼“å†²åŒºçš„å‰©ä½™å€¼å°äº&lt;code&gt;n&lt;/code&gt;ï¼Œä¼šè°ƒç”¨&lt;code&gt;flush&lt;/code&gt;ï¼Œå¯å†™æ¸¸æ ‡ç›¸åº”å¯èƒ½ä¼šæ”¹å˜&lt;/p&gt;

&lt;h4 id=&#34;timer&#34;&gt;timer&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;timer&lt;/code&gt;æ˜¯ä¸€ä¸ªæœ€å°å †ç®—æ³•å®ç°çš„æ—¶é’Ÿå¯¹è±¡ï¼Œä¸²è¡Œæ‰§è¡Œæ—¶é’Ÿä»»åŠ¡ï¼Œæ‰€ä»¥æ—¶é’Ÿä»»åŠ¡åº”è¯¥å°½é‡å°ï¼Œ&lt;code&gt;timer&lt;/code&gt;ä¸é€‚åˆå¤ªè€—æ—¶çš„ä»»åŠ¡ï¼Œå½“ç„¶ç”¨æˆ·å¯ä»¥æ§åˆ¶æ—¶é’Ÿä»»åŠ¡çš„å¹¶å‘ã€‚&lt;/p&gt;

&lt;h3 id=&#34;bytes&#34;&gt;bytes&lt;/h3&gt;

&lt;h4 id=&#34;pool&#34;&gt;Pool&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Buffer struct {
	buf  []byte
	next *Buffer // next free buffer
}
type Pool struct {
	lock sync.Mutex
	free *Buffer
	max  int
	num  int
	size int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pool&lt;/code&gt;å†…å­˜ç»„ç»‡å¦‚ä¸‹ï¼Œ&lt;code&gt;pool&lt;/code&gt;æ˜¯ä¸€ä¸ªé“¾å¼å­˜å‚¨çš„&lt;code&gt;æ ˆ&lt;/code&gt;ï¼Œæ•°æ®ä»æ ˆé¡¶å‡ºï¼ŒåŒæ—¶æ•°æ®ä¹Ÿä»æ ˆé¡¶å›æ”¶ã€‚&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/goim/bytes.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (p *Pool) Get() (b *Buffer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è·å–ä¸€ä¸ªç¼“å†²åŒº&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (p *Pool) Put(b *Buffer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å½’è¿˜ä¸€ä¸ªç¼“å†²åŒº&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (p *Pool) grow()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é‡ç½®&lt;code&gt;Pool&lt;/code&gt;å¯¹è±¡&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;æ³¨ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; pool æ˜¯ä¸€ä¸ªä¸é™å¤§å°çš„å†…å­˜æ± ï¼Œå¦‚æœæ ˆæ²¡æœ‰æ•°æ®äº†ï¼Œé‚£ä¹ˆpoolä¼šè°ƒç”¨glow()é‡æ–°ç”Ÿæˆæ•°æ®ï¼Œæ‰€ä»¥æœ€åå¯èƒ½é€ æˆçš„å†…å­˜æ¶æ„å¦‚ä¸‹å›¾æ‰€ç¤º
&amp;gt; ```

&amp;lt;center&amp;gt;![](http://laohanlinux.github.io/images/img/goim/bytes-2.png)&amp;lt;/center&amp;gt;

å¦‚æœç§Ÿå€Ÿçš„é€Ÿåº¦å¤§äºå½’è¿˜çš„é€Ÿåº¦ï¼Œä¼šé€ æˆå†…å­˜çš„æº¢å‡ºã€‚

#### Writer

```go
type Writer struct {
	n   int 	//æ¸¸æ ‡
	buf []byte
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;writer&lt;/code&gt;æ˜¯ä¸€ä¸ªå…·æœ‰ç¼“å†²çš„å¯å†™&lt;code&gt;IO&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Size()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ç¼“å†²åŒºçš„å¤§å°&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Reset()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;é‡ç½®ç¼“å†²åŒºï¼Œæ¸¸æ ‡é‡ç½®ä¸º&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Buffer() []byte&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¿”å›ç¼“å†²åŒºçš„å†…å®¹&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) Peek(n int) []byte&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;çª¥æ¢ç¼“å†²åŒºçš„&lt;code&gt;n&lt;/code&gt;ä¸ªå­—èŠ‚ï¼Œå¦‚æœç¼“å†²åŒºçš„å‰©ä½™ç©ºé—´å°äº&lt;code&gt;n&lt;/code&gt;ï¼Œåˆ™ä¼šè°ƒç”¨&lt;code&gt;w.grow()&lt;/code&gt;è‡ªå¢é•¿æ•°æ®ç¼“å†²åŒºï¼Œæ¸¸æ ‡ä¼šç§»åŠ¨&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;func (w *Writer) grow(n int)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æŒ‰ç…§&lt;code&gt;2&lt;/code&gt;å€çš„å¤§å°å¢é•¿ç¼“å†²åŒºï¼Œä¼šå‘ç”Ÿæ•°æ®çš„ç§»åŠ¨&lt;/p&gt;

&lt;h3 id=&#34;net&#34;&gt;net&lt;/h3&gt;

&lt;h4 id=&#34;xrpc&#34;&gt;xrpc&lt;/h4&gt;

&lt;p&gt;æ ¹æ®åŸç”Ÿçš„&lt;code&gt;rpc&lt;/code&gt;å°è£…çš„ï¼Œå…¶è°ƒç”¨é‡‡ç”¨å¼‚æ­¥çš„æ–¹å¼ï¼Œå…·æœ‰é‡è¿åŠŸèƒ½ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xrpc&lt;/code&gt;å¹¶æ²¡æœ‰åšè´Ÿè½½å‡è¡¡çš„å·¥ä½œï¼Œåªæ˜¯ç®€å•åšä¸€ä¸‹å®¹ç¾è€Œå·²ï¼Œç›¸å¯¹æ¥æ—¶ä¸æ˜¯å¾ˆçµæ´»ï¼Œç”¨æˆ·å¯ä»¥ç¨å¾®ä¿®æ”¹ä¸€ä¸‹ï¼Œå°±æ”¯æŒè´Ÿè½½å‡è¡¡äº†ã€‚&lt;/p&gt;

&lt;p&gt;åŒæ—¶&lt;code&gt;xrpc&lt;/code&gt;ä¹Ÿæ²¡æœ‰åœ¨ä»£ç å±‚é¢ä¸Šå®ç°&lt;code&gt;[host:por]&lt;/code&gt;è¿æ¥æ± ï¼Œå³åŒä¸€ä¸ª&lt;code&gt;[host:port]&lt;/code&gt;é…ç½®åªä¼šæœ‰ä¸€ä¸ª&lt;code&gt;rpc&lt;/code&gt;é•¿é“¾æ¥ï¼Œé™¤éå¢åŠ å¤šé…ç½®ã€‚&lt;/p&gt;

&lt;h4 id=&#34;proto&#34;&gt;proto&lt;/h4&gt;

&lt;p&gt;ä¸»è¦çš„&lt;code&gt;rpc&lt;/code&gt;åè®®è¯´æ˜ï¼š&lt;/p&gt;

&lt;h5 id=&#34;job&#34;&gt;job&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type KafkaMsg struct {
	OP       string   `json:&amp;quot;op&amp;quot;` 				//æ“ä½œç±»å‹
	RoomId   int32    `json:&amp;quot;roomid,omitempty&amp;quot;` //æˆ¿é—´å·
	ServerId int32    `json:&amp;quot;server,omitempty&amp;quot;`	//comet id
	SubKeys  []string `json:&amp;quot;subkeys,omitempty&amp;quot;`
	Msg      []byte   `json:&amp;quot;msg&amp;quot;`
	Ensure   bool     `json:&amp;quot;ensure,omitempty&amp;quot;`	//æ˜¯å¦å¼ºæ¨é€(ä¼ªå¼ºæ¨)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;logic&#34;&gt;logic&lt;/h5&gt;

&lt;p&gt;å®¢æˆ·ç«¯ä¸Šçº¿ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ç”¨äºcometå‘é€å®¢æˆ·ç«¯çš„æ ¡éªŒä¿¡æ¯
type ConnArg struct {
	Token  string // Token
	Server int32  // comet id
}

// logic æ ¡éªŒåº”ç­”
type ConnReply struct {
	Key    string 	// subKey
	RoomId int32	// æˆ¿é—´å·
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å®¢æˆ·ç«¯ä¸‹çº¿ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ç”¨äºcometå‘é€å®¢æˆ·ç«¯è¿æ¥ä¸‹çº¿
type DisconnArg struct {
	Key    string	// subKey
	RoomId int32	// æˆ¿é—´å·
}
// åº”ç­”å®¢æˆ·ç«¯ä¸‹çº¿
type DisconnReply struct {
	Has bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;comet-1&#34;&gt;comet&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;Push RPC&lt;/code&gt;æ¨¡å—&lt;/p&gt;

&lt;p&gt;å¿ƒè·³ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type NoArg struct {
}

type NoReply struct {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Job----&amp;gt;comet&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// å•æ’­
type PushMsgArg struct {
	Key string	//subKey
	P   Proto
}
type NoReply struct {
}

// æŠŠæŸæ¡æ¶ˆæ¯æ¨é€ç»™å¤šä¸ªsubKey
type MPushMsgArg struct {
	Keys []string
	P    Proto
}

type MPushMsgReply struct {
	Index int32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// å¤šæ’­
type MPushMsgsArg struct {
    PMArgs []*PushMsgArg
}&lt;/p&gt;

&lt;p&gt;type MPushMsgsReply struct {
    Index int32
}&lt;/p&gt;

&lt;p&gt;// å¹¿æ’­
type BoardcastArg struct {
    P Proto
}&lt;/p&gt;

&lt;p&gt;// å§æŸæ¡æ¶ˆæ¯æ¨é€ç»™æŸä¸ªæˆ¿é—´çš„æ‰€æœ‰channels
type BoardcastRoomArg struct {
    RoomId int32
    P      Proto
}&lt;/p&gt;

&lt;p&gt;type RoomsReply struct {
    RoomIds map[int32]struct{}
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##### router

å¢åŠ ç”¨æˆ·ï¼š

â€‹```go
type PutArg struct {
	UserId int64
	Server int32
	RoomId int32
}
type PutReply struct {
	Seq int32	// åºåˆ—å·
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç§»é™¤ç”¨æˆ·ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type DelArg struct {
	UserId int64
	Seq    int32
	RoomId int32
}

type DelReply struct {
	Has bool	//	æ˜¯å¦å­˜åœ¨ç›®æ ‡ç”¨æˆ·
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä»–ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// å‰”é™¤comet server
type DelServerArg struct {
	Server int32
}

// è·å–ç”¨æˆ·ä¿¡æ¯
type GetArg struct {
	UserId int64
}

// è·å–Routerçš„æ‰€æœ‰ä¿¡æ¯
type GetReply struct {
	Seqs    []int32
	Servers []int32
}

type GetAllReply struct {
	UserIds  []int64
	Sessions []*GetReply
}

// è·å–å¤šä¸ªç”¨æˆ·ä¿¡æ¯
type MGetArg struct {
	UserIds []int64
}

type MGetReply struct {
	UserIds  []int64
	Sessions []*GetReply
}

// è¿”å›æ‰€æœ‰è¿æ¥ä¸ªæ•°
type CountReply struct {
	Count int32
}

// è·å–ç‰¹å®šæˆ¿é—´çš„æ‰€æœ‰è¿æ¥
type RoomCountArg struct {
	RoomId int32
}

type RoomCountReply struct {
	Count int32
}

// è·å–æ‰€æœ‰æˆ¿é—´çš„è¿æ¥ä¸ªæ•°
type AllRoomCountReply struct {
	Counter map[int32]int32
}

// è·å–æ‰€æœ‰çš„comet serverä¸ªæ•°
type AllServerCountReply struct {
	Counter map[int32]int32
}

// è·å–æ‰€æœ‰çš„ç”¨æˆ·ä¸ªæ•°
type UserCountArg struct {
	UserId int64
}

type UserCountReply struct {
	Count int32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;æ¨é€åè®®&#34;&gt;æ¨é€åè®®&lt;/h5&gt;

&lt;p&gt;å‚ç…§å®˜ç½‘&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Riak Core åŸç†åˆ†æ-1</title>
      <link>https://laohanlinux.github.io/2016/06/13/riak-core-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-1/</link>
      <pubDate>Mon, 13 Jun 2016 23:38:23 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/06/13/riak-core-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ä½¿ç”¨Golangè¯­è¨€å®ç°ä¸€ä¸ªç®€å•çš„Bitcaskå¼•æ“çš„æ–‡ä»¶å­˜å‚¨ç³»ç»Ÿ</title>
      <link>https://laohanlinux.github.io/2016/04/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84bitcask%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 25 Apr 2016 23:45:22 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/25/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84bitcask%E5%BC%95%E6%93%8E%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid>
      <description>

&lt;p&gt;&lt;code&gt;bitcask&lt;/code&gt;æ˜¯&lt;code&gt;bashro&lt;/code&gt;çš„è®¾è®¡çš„ä¸€ä¸ªåº•å±‚å­˜å‚¨å¼•æ“ï¼Œä¸»è¦åº”ç”¨äº&lt;code&gt;Riak&lt;/code&gt;äº§å“ä¸­ï¼ˆ&lt;code&gt;ps&lt;/code&gt;:å›½å†…çš„&lt;code&gt;beansdb&lt;/code&gt;çš„åº•å±‚å­˜å‚¨å¼•æ“ä¹Ÿæ˜¯ä½¿ç”¨&lt;code&gt;bitcask&lt;/code&gt;ï¼Œåˆ†å¸ƒå¼ä¸Šä¹Ÿæ˜¯ä½¿ç”¨&lt;code&gt;dynamo&lt;/code&gt;ï¼Œå¹¶ä¸”ä»–ä»¬ä¹Ÿæ ¹æ®è‡ªå·±çš„å®é™…åº”ç”¨åšäº†ç›¸åº”çš„ä¼˜åŒ–ï¼‰ï¼Œå…¶è®¾è®¡ç®€å•æ˜“æ‡‚ï¼Œç®—æ³•ä¹Ÿæ˜¯å¾ˆç®€æ˜çš„ç®—æ³•ã€‚å…¶å­˜å‚¨å¯¹è±¡ç±»å‹æ˜¯&lt;code&gt;key/value&lt;/code&gt;ç±»å‹ã€‚&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/basho/bitcask&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;riak bitcask github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/laohanlinux/bitcask&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;go bitcask github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://image.haha.mx/2013/04/03/middle/803545_68a109882550ec3556a2b19e277ddb10_1364992759.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;code&gt;talk is cheap, show me the code!&lt;/code&gt; &lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;è®¾è®¡æ¨¡å‹ä»¥åŠç‰¹ç‚¹&#34;&gt;è®¾è®¡æ¨¡å‹ä»¥åŠç‰¹ç‚¹&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;æ‰€æœ‰çš„&lt;code&gt;key&lt;/code&gt;éƒ½å­˜å‚¨äºå†…å­˜ä¸­ï¼›æ‰€æœ‰çš„&lt;code&gt;value&lt;/code&gt;éƒ½å­˜å‚¨äºç£ç›˜ä¸­&lt;/li&gt;
&lt;li&gt;ä»¥è¿½åŠ çš„æ–¹å¼å†™ç£ç›˜ï¼Œå³å†™æ“ä½œæ˜¯æœ‰åºçš„ï¼Œè¿™æ ·å¯ä»¥å‡å°‘ç£ç£ç›˜çš„å¯»é“æ—¶é—´ï¼Œæ˜¯ä¸€ç§é«˜ååé‡çš„å†™å…¥æ–¹æ¡ˆï¼Œåœ¨æ›´æ–°æ•°æ®æ—¶ï¼Œä¹Ÿæ˜¯æŠŠæ–°æ•°æ®è¿½åŠ åˆ°æ–‡ä»¶çš„åé¢ï¼Œç„¶åæ›´æ–°ä¸€ä¸‹æ•°æ®çš„æ–‡ä»¶æŒ‡é’ˆæ˜ å°„å³å¯&lt;/li&gt;
&lt;li&gt;è¯»å–æ•°æ®æ—¶ï¼Œé€šè¿‡æ•°æ®çš„æŒ‡é’ˆä»¥åŠåç§»é‡å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º&lt;code&gt;O(1)&lt;/code&gt;ï¼Œå› ä¸ºæ‰€æœ‰&lt;code&gt;key&lt;/code&gt;éƒ½æ˜¯å­˜å‚¨äºå†…å­˜ä¸­ï¼ŒæŸ¥æ‰¾æ•°æ®æ—¶ï¼Œä¸ç”¨æ£€ç´¢ç£ç›˜æ–‡ä»¶ï¼Œè¿™å¤§å¤§å‡å°‘äº†æ£€ç´¢æ—¶é—´&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bitcask&lt;/code&gt;æœ‰ä¸€ä¸ªåˆå¹¶çš„æ—¶é—´çª—å£ï¼Œå½“æ—§æ•°æ®ç«™åˆ°ä¸€å®šæ¯”ä¾‹æ—¶ï¼Œä¼šè§¦å‘åˆå¹¶æ“ä½œï¼ŒåŒæ—¶ä¸ºäº†è®¾è®¡æ›´ç®€å•ï¼Œä¼šæŠŠæ—§æ•°æ®é‡æ–°è¿½åŠ åˆ°å¯å†™æ–‡ä»¶ä¸­(&lt;code&gt;riak&lt;/code&gt;é‡Œé¢çš„åˆå¹¶ç­–ç•¥è·Ÿå¤šï¼Œå…·ä½“çš„åˆå¹¶ç­–ç•¥å¯ä»¥å»çœ‹å®ƒçš„æºç )(&lt;code&gt;ps&lt;/code&gt;:è™½ç„¶è‡ªå·±å®ç°äº†è¿™ä¸ªæ“ä½œï¼Œä½†æ˜¯è¿˜åœ¨æµ‹è¯•é˜¶æ®µï¼Œåº”è¯¥æœ‰æ½œåœ¨çš„&lt;code&gt;Debug&lt;/code&gt;,å¦‚æœå“ªä½æœ‰å¯¹è¿™ä¸ªé¡¹ç›®æœ‰å…´èµ·ï¼Œå¯ä»¥ä¿®å¤ä¸€ä¸‹)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;å…·ä½“çš„ç»„ä»¶è®¾è®¡å›¾&#34;&gt;å…·ä½“çš„ç»„ä»¶è®¾è®¡å›¾&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bitcask&lt;/code&gt;çš„æ•°æ®æ–‡ä»¶åˆ†ä¸º&lt;strong&gt;åªè¯»æ–‡ä»¶&lt;/strong&gt;å’Œå”¯ä¸€&lt;strong&gt;ä¸€ä¸ªè¯»å†™æ–‡ä»¶&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/bitcask-1.png&#34; alt=&#34;å›¾-1&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ä¸ºäº†åŠ å¿«ç´¢å¼•çš„é‡å»ºé€Ÿåº¦ï¼Œæ¯ä¸ªæ•°æ®æ–‡ä»¶å¯¹åº”ä¸€ä¸ª&lt;code&gt;hint&lt;/code&gt;æ–‡ä»¶ï¼Œå¦‚ï¼š&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/bitcask-2.png&#34; alt=&#34;å›¾-2&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;æ–‡ä»¶çš„æ ¼å¼å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;crc32(4byte)|tStamp(4byte)|ksz(4byte)|valueSz(4byte)|key|value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™æ ·é€šè¿‡&lt;code&gt;key&lt;/code&gt;çš„å¤§å°å’Œ&lt;code&gt;value&lt;/code&gt;çš„å¤§å°å°±å¯ä»¥æ‰¾åˆ°&lt;code&gt;key&lt;/code&gt;çš„ä½ç½®å’Œ&lt;code&gt;value&lt;/code&gt;çš„æ–‡ä»¶ï¼Œä½†æ˜¯å¦‚æœ&lt;code&gt;bitcask&lt;/code&gt;é‡å¯åï¼Œç›´æ¥æ‰«æ&lt;code&gt;data&lt;/code&gt;æ–‡ä»¶æ¥å»ºç«‹ç´¢å¼•æ˜¯ä¸€ä»¶éå¸¸è€—æ—¶çš„å·¥ä½œï¼Œè¿™æ—¶å€™&lt;code&gt;hint&lt;/code&gt;æ–‡ä»¶å°±æ´¾ä¸Šåœºäº†ï¼Œ&lt;code&gt;hint&lt;/code&gt;æ–‡ä»¶æ ¼å¼å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tstamp(4byte)|ksz(4byte)|valuesz(4byte)|valuePos(8byte)|key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™æ ·åœ¨å¯ä»¥è·³è¿‡&lt;code&gt;value&lt;/code&gt;çš„æ‰«æï¼Œæ‰«æé€Ÿåº¦è‡ªç„¶å°±èµ·æ¥äº†ï¼Œé€šè¿‡&lt;code&gt;valuePos&lt;/code&gt;å°±å¯ä»¥ç›´æ¥æ‰¾åˆ°æ–‡ä»¶çš„å†…å®¹ã€‚&lt;/p&gt;

&lt;h3 id=&#34;æ•°æ®ç»“æ„çš„è®¾è®¡&#34;&gt;æ•°æ®ç»“æ„çš„è®¾è®¡&lt;/h3&gt;

&lt;h4 id=&#34;æ–‡ä»¶æ˜ å°„çš„ç»“æ„ä½“&#34;&gt;æ–‡ä»¶æ˜ å°„çš„ç»“æ„ä½“&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type BFile struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BFile å¯å†™æ–‡ä»¶ä¿¡æ¯ 1: datafile and hint file
type BFile struct {
	// fp is the writeable file
	fp          *os.File
	fileID      uint32
	writeOffset uint64
	// hintFp is the hint file
	hintFp *os.File
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fp&lt;/code&gt;æŒ‡å‘&lt;code&gt;Active data file&lt;/code&gt;ï¼Œ &lt;code&gt;fileID&lt;/code&gt;è¡¨ç¤º&lt;code&gt;Active data file&lt;/code&gt;çš„æ–‡ä»¶åï¼Œ&lt;code&gt;hintFp&lt;/code&gt;è¡¨ç¤º&lt;code&gt;Active hint file&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type BFiles struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BFiles ...
type BFiles struct {
	bfs    map[uint32]*BFile
	rwLock *sync.RWMutex
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bfs&lt;/code&gt;æ¯ä¸€é¡¹è¡¨ç¤ºä¸€ä¸ªæ–‡ä»¶ç´¢å¼•é¡¹ï¼Œç›´æ¥ä½¿ç”¨&lt;code&gt;map&lt;/code&gt;æ¥å­˜å‚¨ä¸æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„æ–¹æ³•ï¼Œä»¥åå†ä¼˜åŒ–å§&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;key-value-ç»“æ„ä½“&#34;&gt;&lt;code&gt;key/value&lt;/code&gt;ç»“æ„ä½“&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type entry struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type entry struct {
	fileID      uint32 // file id
	valueSz     uint32 // value size in data block
	valueOffset uint64 // value offset in data block
	timeStamp   uint32 // file access time spot
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¯¥ç»“æ˜¯&lt;code&gt;hint&lt;/code&gt;æ–‡ä»¶çš„æ˜ å°„ï¼Œ&lt;code&gt;fileID&lt;/code&gt;ä¸º&lt;code&gt;data&lt;/code&gt;çš„æ–‡ä»¶åï¼Œ&lt;code&gt;valueSz&lt;/code&gt;è¡¨ç¤ºå€¼çš„å¤§å°ï¼Œ&lt;code&gt;valueOffset&lt;/code&gt;è¡¨ç¤º&lt;code&gt;value&lt;/code&gt;åœ¨&lt;code&gt;data&lt;/code&gt;æ–‡ä»¶çš„ç´¢å¼•ä½ç½®ï¼Œ&lt;code&gt;timeStamp&lt;/code&gt;è¡¨ç¤º&lt;code&gt;value&lt;/code&gt;çš„å­˜å‚¨æ—¶é—´ï¼ˆè¿™ä¸ªå­˜å‚¨æ—¶é—´æ˜¯ä¼šå˜çš„ï¼Œå› ä¸ºåœ¨&lt;code&gt;merge&lt;/code&gt;çš„æ—¶å€™ï¼Œæ—§çš„æ•°æ®ä¼šé‡æ–°è¿½åŠ åˆ°&lt;code&gt;Active&lt;/code&gt;æ–‡ä»¶ä¸­ï¼Œè¿™æ ·è¿™äº›æ—§çš„æ•°æ®ä¼šé‡æ–°æ´—ç‰Œï¼Œå˜æˆæ–°çš„æ•°æ®ï¼‰.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type KeyDirs struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// KeyDirs ...
type KeyDirs struct {
	entrys map[string]*entry
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™ä¸ªç»“æ„æ˜¯ä¸»è¦çš„å å†…å­˜çš„åœ°æ–¹ï¼Œå› ä¸ºæ‰€æœ‰&lt;code&gt;key&lt;/code&gt;éƒ½å­˜å‚¨äºæ­¤ï¼Œè¿™ä¸ªç»“æ„ä½“ç”±&lt;code&gt;hint&lt;/code&gt;æ–‡ä»¶æ„å»ºçš„.&lt;/p&gt;

&lt;p&gt;è¿™ä¸ªç»“æ„ä½“ä¹Ÿæ˜¯åç»­éœ€è¦ä¼˜åŒ–çš„åœ°æ–¹ï¼Œæ¯”å¦‚ï¼š&lt;code&gt;fileID&lt;/code&gt;å¾ˆå¤šæ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥å°†ä»–ä»¬å­˜å‚¨åœ¨ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œ&lt;code&gt;entry&lt;/code&gt;åªè¦å­˜å‚¨æ•°ç»„çš„&lt;code&gt;fileID&lt;/code&gt;ç´¢å¼•å³å¯ã€‚&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type BitCask struct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BitCask ...
type BitCask struct {
	Opts      *Options      // opts for bitcask
	oldFile   *BFiles       // hint file, data file
	lockFile  *os.File      // lock file with process
	keyDirs   *KeyDirs      // key/value hashMap, building with hint file
	dirFile   string        // bitcask storage  root dir
	writeFile *BFile        // writeable file
	rwLock    *sync.RWMutex // rwlocker for bitcask Get and put Operation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bitcask&lt;/code&gt;æ˜¯æœ€é‡è¦çš„ç»“æ„ä½“ï¼Œæ˜¯ç¨‹åºçš„å…¥å£ï¼Œ&lt;code&gt;oldFile&lt;/code&gt;æ˜¯åªè¯»æ–‡ä»¶çš„ç´¢å¼•ï¼›&lt;code&gt;writeFile&lt;/code&gt;æ˜¯&lt;code&gt;Active file&lt;/code&gt;çš„ç´¢å¼•ï¼›&lt;code&gt;keyDirs&lt;/code&gt;æ˜¯&lt;code&gt;key&lt;/code&gt;çš„ç´¢å¼•ã€‚&lt;/p&gt;

&lt;h3 id=&#34;å…³äºmerge&#34;&gt;å…³äºMerge&lt;/h3&gt;

&lt;p&gt;ä¸ºäº†èŠ‚çœç©ºé—´ï¼Œ&lt;code&gt;bitcask&lt;/code&gt;é‡‡ç”¨&lt;code&gt;merge&lt;/code&gt;çš„æ–¹å¼å‰”é™¤è„æ•°æ®ï¼Œ&lt;code&gt;merge&lt;/code&gt;æœŸé—´ä¼šå½±å“åˆ°æœåŠ¡çš„è®¿é—®ï¼Œ&lt;code&gt;merge&lt;/code&gt;æ˜¯ä¸€ä»¶æ¶ˆè€—&lt;code&gt;disk io&lt;/code&gt;æ—¶é—´ï¼Œç”¨æˆ·åº”è¯¥é”™å¼€&lt;code&gt;merge&lt;/code&gt;çš„&lt;code&gt;io&lt;/code&gt;é«˜å³°æœŸ.å…¶ä¸­&lt;code&gt;merge&lt;/code&gt;çš„è§¦å‘ä¹Ÿæœ‰å¾ˆå¤šç§ï¼ˆè§¦å‘ä¸ä¸€å®šå°±ä¼šæ‰§è¡Œï¼‰ï¼Œå¦‚ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;å®šæ—¶ç­–ç•¥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ç”¨æˆ·è‡ªå®šä¹‰è§¦å‘&lt;code&gt;merge&lt;/code&gt;çš„æ—¶é—´
- é—´éš”ç­–ç•¥
æ¯éš”ä¸€å®šçš„æ—¶é—´è§¦å‘&lt;code&gt;merge&lt;/code&gt;äº‹ä»¶&lt;/p&gt;

&lt;p&gt;å…¶ä»–ç­‰ç­‰&amp;hellip;..&lt;/p&gt;

&lt;p&gt;å½“&lt;code&gt;merge&lt;/code&gt;æ—¶é—´è§¦å‘æ—¶ï¼Œ&lt;code&gt;bitcask&lt;/code&gt;å°±ä¼šæ ¹æ®ç”¨æˆ·è‡ªå®šçš„ç­–ç•¥å»å†³å®šæ˜¯å¦æ‰§è¡Œ&lt;code&gt;merge&lt;/code&gt;æ“ä½œï¼Œ&lt;code&gt;merge&lt;/code&gt;æ‰§è¡Œç­–ç•¥å¦‚ï¼š
- å®šæ—¶ç­–ç•¥
åœ¨ç”¨æˆ·å®šä¹‰çš„æ—¶é—´å†…æ‰§è¡Œ&lt;code&gt;merge&lt;/code&gt;æ“ä½œï¼Œè¯¥æ“ä½œä¼šæŸè€—æœåŠ¡çš„èƒ½åŠ›ï¼Œç”¨æˆ·åº”è¯¥é¿å…é«˜å³°æœŸï¼Œåœ¨ä½å³°æœŸæ—¶æ‰æ‰§è¡Œè¯¥æ“ä½œ
- å®¹é‡ç­–ç•¥
å½“èƒ€æ•°æ®è¾¾åˆ°ä¸€å®šçš„æ¯”ä¾‹æˆ–è€…å¤§å°æ—¶ï¼Œæ‰§è¡Œ&lt;code&gt;merge&lt;/code&gt;æ“ä½œ&lt;/p&gt;

&lt;p&gt;å…¶ä»–çš„ç­‰ç­‰&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;å¦‚ä½•å®ç°ä¸€ä¸ªç®€å•çš„-merge&#34;&gt;å¦‚ä½•å®ç°ä¸€ä¸ªç®€å•çš„&lt;code&gt;Merge&lt;/code&gt;:&lt;/h3&gt;

&lt;p&gt;ä¸ºç®€åŒ–è®¾è®¡ï¼Œä¾¿äºå®ç°ï¼Œ&lt;code&gt;merge&lt;/code&gt;æ“ä½œæŠŠéœ€è¦çš„&lt;code&gt;old file&lt;/code&gt;æ–‡ä»¶é‡æ–°æ‰«æï¼Œå¦‚æœè®°å½•æ˜¯è€çš„æˆ–è€…è¢«åˆ é™¤äº†å¾—ï¼Œå°±è¿‡æ»¤æ‰ï¼›éœ€è¦ä¿ç•™çš„å°±æŒ‰æ­£å¸¸çš„æ“ä½œé‡æ–°æ’å…¥åˆ°&lt;code&gt;active file&lt;/code&gt;æ–‡ä»¶ä¸­ã€‚&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/bitcask-3.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;ps:æœ¬äººåªå®ç°äº†ä¸€ä¸ªç®€å•çš„mergeæ“ä½œï¼Œç”±äºæ¯”è¾ƒå¿™ï¼Œä¼˜åŒ–å’Œç­–ç•¥æ–¹é¢è¿˜æ²¡å…¨é¢&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&#34;todo-list&#34;&gt;TODO LIST&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ä¼˜åŒ–hashmap&lt;/li&gt;
&lt;li&gt;å¢åŠ å¤šç§åˆå¹¶ç­–ç•¥&lt;/li&gt;
&lt;li&gt;å‡å°‘é”çš„é¢—ç²’åº¦&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ç®€å•çš„æ“ä½œ&#34;&gt;ç®€å•çš„æ“ä½œ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
        &amp;quot;os&amp;quot;

        &amp;quot;github.com/laohanlinux/bitcask&amp;quot;
        &amp;quot;github.com/laohanlinux/go-logger/logger&amp;quot;
)

func main() {
        os.RemoveAll(&amp;quot;exampleBitcaskDir&amp;quot;)
        bc, err := bitcask.Open(&amp;quot;exampleBitcaskDir&amp;quot;, nil)
        if err != nil {
                logger.Fatal(err)
        }
        defer bc.Close()
        k1 := []byte(&amp;quot;xiaoMing&amp;quot;)
        v1 := []byte(&amp;quot;æ¯•ä¸šäºæ–°ä¸œæ–¹æ¨åœŸæœºå­¦é™¢&amp;quot;)

        k2 := []byte(&amp;quot;zhanSan&amp;quot;)
        v2 := []byte(&amp;quot;æ¯•ä¸šäºæ–°ä¸œæ–¹å¨å¸ˆå­¦é™¢&amp;quot;)

        bc.Put(k1, v1)
        bc.Put(k2, v2)

        v1, _ = bc.Get(k1)
        v2, _ = bc.Get(k2)
        logger.Info(string(k1), string(v1))
        logger.Info(string(k2), string(v2))
        // override
        v2 = []byte(&amp;quot;æ¯•ä¸šäºæ–°ä¸œæ–¹ç¾å®¹ç¾å‘å­¦é™¢&amp;quot;)
        bc.Put(k2, v2)
        v2, _ = bc.Get(k2)
        logger.Info(string(k2), string(v2))

        bc.Del(k1)
        bc.Del(k2)
        logger.Info(&amp;quot;æ¯•ä¸šåçš„æ•°æ®åº“ï¼š&amp;quot;)
        v1, e := bc.Get(k1)
        if e != bitcask.ErrNotFound {
                logger.Info(string(k1), &amp;quot;shoud be:&amp;quot;, bitcask.ErrNotFound)
        } else {
                logger.Info(string(k1), &amp;quot;å·²ç»æ¯•ä¸š.&amp;quot;)
        }
        v2, e = bc.Get(k2)
        if e != bitcask.ErrNotFound {
                logger.Info(string(k1), &amp;quot;shoud be:&amp;quot;, bitcask.ErrNotFound)
        } else {
                logger.Info(string(k2), &amp;quot;å·²ç»æ¯•ä¸š.&amp;quot;)
        }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;gt; go run example/bitcask_main.go
2016/05/01 16:22:28 bitcask_main.go:28 [info] xiaoMingæ¯•ä¸šäºæ–°ä¸œæ–¹æ¨åœŸæœºå­¦é™¢
2016/05/01 16:22:28 bitcask_main.go:29 [info] zhanSanæ¯•ä¸šäºæ–°ä¸œæ–¹å¨å¸ˆå­¦é™¢
2016/05/01 16:22:28 bitcask_main.go:34 [info] zhanSanæ¯•ä¸šäºæ–°ä¸œæ–¹ç¾å®¹ç¾å‘å­¦é™¢
2016/05/01 16:22:28 bitcask_main.go:38 [info] æ¯•ä¸šåçš„æ•°æ®åº“ï¼š
2016/05/01 16:22:28 bitcask_main.go:43 [info] xiaoMingå·²ç»æ¯•ä¸š.
2016/05/01 16:22:28 bitcask_main.go:49 [info] zhanSanå·²ç»æ¯•ä¸š.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ä½¿ç”¨raftç®—æ³•å¿«é€Ÿæ„å»ºä¸€ä¸ªåˆ†å¸ƒå¼kvç³»ç»Ÿ</title>
      <link>https://laohanlinux.github.io/2016/04/25/%E4%BD%BF%E7%94%A8raft%E7%AE%97%E6%B3%95%E5%BF%AB%E7%86%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84key-value%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 25 Apr 2016 23:44:25 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/25/%E4%BD%BF%E7%94%A8raft%E7%AE%97%E6%B3%95%E5%BF%AB%E7%86%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84key-value%E7%B3%BB%E7%BB%9F/</guid>
      <description>

&lt;p&gt;&lt;code&gt;raft&lt;/code&gt;æ˜¯ä¸€ç§ç±»ä¼¼äº&lt;code&gt;paoxs&lt;/code&gt;çš„åˆ†å¸ƒå¼ç®—æ³•ï¼Œç›¸å¯¹äº&lt;code&gt;paxos&lt;/code&gt;ç®—æ³•ï¼Œ&lt;code&gt;raft&lt;/code&gt;æ›´å®¹æ˜“äºç†è§£ä»¥åŠå®ç°ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§å…¸å‹çš„&lt;code&gt;åŠæ•°åè®®ç®—æ³•&lt;/code&gt;ã€‚è¿™é‡Œä¸è¯¦ç»†ä»‹ç»&lt;code&gt;raft&lt;/code&gt;ç®—æ³•ï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥å‚ç…§ä¸€ä¸‹ä¸‹é¢çš„æ–‡ç« ï¼š&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://laohanlinux.github.io/2016/03/13/raft%E7%AE%97%E6%B3%95/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;raft Algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;æœ¬æ¬¡æ•™ç¨‹å®ç°çš„&lt;code&gt;key/value&lt;/code&gt;åˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿçš„&lt;code&gt;github&lt;/code&gt;åœ°å€ä¸ºï¼š&lt;a href=&#34;https://github.com/laohanlinux/riot&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;riot github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;å¦‚ä½•å¿«é€Ÿä½¿ç”¨-hashicorp-raft-æ­å»ºä¸€ä¸ªç®€å•çš„åˆ†å¸ƒå¼ç³»ç»Ÿ&#34;&gt;å¦‚ä½•å¿«é€Ÿä½¿ç”¨&lt;code&gt;hashicorp raft&lt;/code&gt;æ­å»ºä¸€ä¸ªç®€å•çš„åˆ†å¸ƒå¼ç³»ç»Ÿ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;raft&lt;/code&gt;ç®—æ³•ç§ç±»çš„å®ç°æœ‰å¾ˆå¤šï¼Œæ¯”è¾ƒæµè¡Œçš„æ˜¯&lt;code&gt;etcd raft&lt;/code&gt;å’Œ&lt;code&gt;hashicorp raft&lt;/code&gt;ï¼Œè¿™ä¸¤ä¸ªéƒ½æ˜¯&lt;code&gt;Go&lt;/code&gt;è¯­è¨€å®ç°çš„&lt;code&gt;raft&lt;/code&gt;ç®—æ³•åº“ï¼Œå¹¶ä¸”éƒ½å¤§é‡åº”ç”¨åˆ°ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œå¯é æ€§é«˜ã€‚ç”±äºæœ¬äººå¯¹&lt;code&gt;hashiro raft&lt;/code&gt;ç†Ÿæ‚‰ä¸€ç‚¹ï¼Œåˆšå¥½åˆå¯¹&lt;code&gt;Go&lt;/code&gt;è¯­è¨€æœ‰å…´è¶£ï¼Œæ‰€ä»¥é€‰æ‹©äº†&lt;code&gt;hashicorp raft&lt;/code&gt;æ¥å®ç°ä¸€ä¸ªç®€å•çš„åˆ†å¸ƒå¼&lt;code&gt;key/value&lt;/code&gt;ç³»ç»Ÿ.&lt;/p&gt;

&lt;p&gt;ç³»ç»Ÿè®¾è®¡çš„åŸºæœ¬ç›®æ ‡ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;å…·æœ‰å®¹é”™æ€§&lt;/li&gt;
&lt;li&gt;å¯ä»¥åœ¨çº¿è‡ªåŠ¨çº¿æ€§æ‰©å±•èŠ‚ç‚¹&lt;/li&gt;
&lt;li&gt;å¯ä»¥è‡ªåŠ¨å¢åˆ èŠ‚ç‚¹&lt;/li&gt;
&lt;li&gt;å…·ä½“å¢åˆ æŸ¥æ”¹æ“ä½œ&lt;/li&gt;
&lt;li&gt;å¯ä»¥é€‚é…å¤šç§å­˜å‚¨å¼•æ“&lt;/li&gt;
&lt;li&gt;æ”¯æŒæ—¥å¿—/å¿«ç…§é‡å»º&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;raft&lt;/code&gt;çš„è¯·æ±‚å¤„ç†æµç¨‹ï¼š&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohan.qiniudn.com/raft/raft_1.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;é™¤æ­¤ä¹‹å¤–è¿˜æœ‰ä¸€ä¸ªçŠ¶æ€æœºå¿«ç…§çš„æ¨¡å—ã€‚&lt;/p&gt;

&lt;p&gt;ä½¿ç”¨&lt;code&gt;hashicorp raft&lt;/code&gt;æ„å»ºä¸€ä¸ªåˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿæ—¶ï¼Œä¸»è¦éœ€è¦å®ç°çš„æ¨¡å—æœ‰ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FSM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;fsm&lt;/code&gt;ä¸º&lt;code&gt;raft&lt;/code&gt;çš„æ—¥å¿—çŠ¶æ€æœº&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Snapshot&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Snapshot&lt;/code&gt;ä¸º&lt;code&gt;raft&lt;/code&gt;çš„å¿«ç…§å¯¹è±¡&lt;/p&gt;

&lt;p&gt;è¿™ä¸¤ä¸ªå¯¹è±¡æ˜¯æ¯”è¾ƒé‡è¦çš„ï¼ŒåŸºæœ¬ä¸Šæ‰€æœ‰çš„æ ¸å¿ƒéƒ½åŸºäºè¿™ä¸ªä¸¤ä¸ªå¯¹è±¡è¿›è¡Œæ„å»ºã€‚&lt;/p&gt;

&lt;h2 id=&#34;riot-çš„ä¸»è¦ç»„ä»¶&#34;&gt;&lt;code&gt;Riot&lt;/code&gt;çš„ä¸»è¦ç»„ä»¶&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;æ¨¡å—å›¾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohan.qiniudn.com/raft/riot_2.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;æµç¨‹å›¾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://7rflb0.com1.z0.glb.clouddn.com/raft/riot_4.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;backend-store&#34;&gt;Backend Store&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotStorage interface {
	Get([]byte) ([]byte, error)
	Set([]byte, []byte) error
	Del([]byte) error
	Rec() &amp;lt;-chan store.Iterm
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Rec()&lt;/code&gt;è¿”å›ä¸€ä¸ªåªè¯»çš„ä¿¡é“ï¼Œè¯¥ä¿¡é“ç”¨äº&lt;code&gt;riot&lt;/code&gt;çš„å¿«ç…§ç³»ç»Ÿã€‚&lt;/p&gt;

&lt;p&gt;ä¸ºäº†ä¾¿äºæ‰©å±•æ›´å¤šçš„å­˜å‚¨åç«¯ï¼Œè¯¥æ¥å£å¯¹å¤–å¼€æ”¾ï¼Œæœ‰å…´è¶£çš„æœ‹å‹åªè¦å®ç°è¿™ä¸ªæ¥å£å³å¯ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type leveldbStorage struct {
	*leveldb.DB
	c chan Iterm
	l *sync.Mutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Riot&lt;/code&gt;ç›®å‰é‡‡ç”¨çš„å­˜å‚¨åç«¯ä¸º&lt;code&gt;leveldb&lt;/code&gt;ï¼Œæœªäº†ä¼šå¢åŠ &lt;code&gt;Bitcask&lt;/code&gt;&lt;a href=&#34;https://github.com/laohanlinux/bitcask&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;github-link&lt;/a&gt;å­˜å‚¨åç«¯,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Iterm struct {
	Err   error
	Key   []byte
	Value []byte
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­å½“&lt;code&gt;iterm.Err = ErrFinished&lt;/code&gt;æ˜¯è¡¨ç¤ºæ‰€æœ‰çš„&lt;code&gt;key&lt;/code&gt;å·²è¿­ä»£å®Œæ¯•ã€‚&lt;/p&gt;

&lt;p&gt;ä¸ºäº†ç¡®ä¿ä¸€ä¸ªèŠ‚ç‚¹ä¸­ï¼ŒåŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªå¿«ç…§æ“ä½œï¼Œéœ€è¦æ“ä½œï¼ˆ&lt;code&gt;raft&lt;/code&gt;æœ¬èº«å°±ä¹Ÿç¡®ä¿äº†ï¼Œä¸ºäº†æ›´åŠ ä¿é™©ï¼Œå»ºè®®è¿˜æ˜¯åŠ ä¸Šé”ï¼Œæ¯•ç«Ÿ&lt;code&gt;IO&lt;/code&gt;æ‰æ˜¯è¿™ä¸ªç³»ç»Ÿçš„ç“¶é¢ˆï¼Œé”çš„æŸè€—å¯ä»¥å¿½ç•¥ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;å®ç°èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒæ˜äº†çš„ã€‚&lt;/p&gt;

&lt;h3 id=&#34;fsm-snapshot&#34;&gt;FSMã€SnapShot&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;raft fsm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type FSM interface {
    
    Apply(*Log) interface{}
  
    Snapshot() (FSMSnapshot, error)
    
    Restore(io.ReadCloser) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”¨æˆ·è‡ªå®šä¹‰çš„&lt;code&gt;fsm&lt;/code&gt;åªè¦å®ç°è¿™ä¸ªæ¥å£å³å¯ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;riot fsm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type StorageFSM struct {
	l  *sync.Mutex //äº’æ–¥é”
	rs RiotStorage //å­˜å‚¨åç«¯
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™é‡Œçš„äº’æ–¥é”æ˜¯å¿…é¡»çš„ï¼Œå› ä¸º&lt;code&gt;fsm&lt;/code&gt;çš„&lt;code&gt;Apply&lt;/code&gt;å’Œ&lt;code&gt;Snapshot&lt;/code&gt;ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚&lt;/p&gt;

&lt;p&gt;å…¶ä¸­ä¸šåŠ¡æ“ä½œéƒ½ä¼šåº”ç”¨åˆ°&lt;code&gt;Apply&lt;/code&gt;æ–¹æ³•ä¸­ï¼Œæ‰€ä»¥æŠŠæ‰€æœ‰çš„ä¸šåŠ¡è¯·æ±‚éƒ½æŒ‰ä¸€å®šçš„æ ¼å¼æ‰“åŒ…å³å¯ï¼Œç„¶åå†è§£åŒ…ï¼Œæ ¹æ®åŒ…çš„&lt;code&gt;action&lt;/code&gt;ç±»å‹ï¼Œåšç›¸åº”çš„æ“ä½œã€‚å…¶ä¸­æ“ä½œä¸»è¦æœ‰ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SET&lt;/li&gt;
&lt;li&gt;DEL&lt;/li&gt;
&lt;li&gt;SHARE&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;æ³¨:&lt;/p&gt;

&lt;p&gt;1ã€&lt;code&gt;SHARE&lt;/code&gt; æ“ä½œç±»å‹ç”¨äºRiotèŠ‚ç‚¹é€šä¿¡æœ‰çš„ï¼Œ&lt;code&gt;Riot&lt;/code&gt;é›†ç¾¤åœ¨å¯åŠ¨çš„æ—¶å€™ï¼Œä»–ä»¬ä¹‹é—´çš„æœ‰äº›ä¿¡æ¯éœ€è¦åŒæ­¥ï¼Œç›®å‰ç”¨äºåŒæ­¥Leaderçš„RPCåœ°å€å’Œç«¯å£&lt;/p&gt;

&lt;p&gt;2ã€ä¸ºäº†æ€§èƒ½ï¼Œ&lt;code&gt;GET&lt;/code&gt;æ“ä½œå¹¶æ²¡æœ‰æ”¾åœ¨Applyæ–¹æ³•ä¸­ï¼Œæ‰€ä»¥GETè¯·æ±‚ä¼šæœ‰404çš„æƒ…å†µå‡ºç°ï¼Œæœªæ¥ä¼šæŠŠæŸ¥è¯¢è¯·æ±‚æ˜¯å¦ç»è¿‡Leaderçš„æƒé™äº¤ç»™ç”¨æˆ·.&lt;/p&gt;

&lt;p&gt;3ã€&lt;code&gt;DEL&lt;/code&gt;å’Œ&lt;code&gt;SHARE&lt;/code&gt;æ“ä½œå…¨éƒ¨äº¤ç»™Leaderå¤„ç†,å†ç”±Leaderä¸‹å‘åˆ°FollowerèŠ‚ç‚¹&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Shapshot&lt;/code&gt;æ–¹æ³•ä¼šåœ¨å¿«ç…§æ—¶è¢«æ‰§è¡Œ,è¿™æ—¶å€™,åªè¦æŠŠæ‰€æœ‰çš„&lt;code&gt;key/value&lt;/code&gt;ä¼ é€’ç»™&lt;code&gt;FSMSnapshot&lt;/code&gt;å¯¹è±¡å³å¯.åœ¨&lt;code&gt;Riot&lt;/code&gt;ä¸­.åªè¦ä¼ é€’&lt;code&gt;RiotStorage&lt;/code&gt;å¯¹è±¡ç»™&lt;code&gt;StorageSnapshot&lt;/code&gt;å³å¯;&lt;/p&gt;

&lt;p&gt;ç„¶å&lt;code&gt;StorageSnapshot.Persist&lt;/code&gt;æ–¹æ³•å°†è¢«è°ƒç”¨,&lt;code&gt;StorageSnapshot&lt;/code&gt;åªè¦éå†è¿™äº›æ•°æ®,æŒ‰ä¸€å®šçš„æ ¼å¼å¿«ç…§åˆ°SnapshotSinkä¸­å³å¯.&lt;/p&gt;

&lt;p&gt;&lt;center&gt; &lt;img src=&#34;http://7rflb0.com1.z0.glb.clouddn.com/raft/Riot_3.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
å½“æœåŠ¡é‡å¯æ—¶,&lt;code&gt;Riot&lt;/code&gt;ä¼šæ£€æµ‹æ˜¯å¦å­˜åœ¨å¿«ç…§,å¦‚æœå­˜åœ¨å¿«ç…§,å¿«ç…§çš„æ•°æ®å°±ä¼šè¢«&lt;code&gt;StorageFSM.Restore&lt;/code&gt;è¿›è¡Œé‡å»º;é‡å»ºå®Œå,&lt;code&gt;raft&lt;/code&gt;ä¼šæ ¹æ®æ—¥å¿—çš„ç´¢å¼•,é‡æ”¾é‚£äº›æ²¡æœ‰è¢«å¿«ç…§åˆ°æ—¥å¿—æ¡ç›®,è¿™æ ·
æ‰€æœ‰çš„æ•°æ®å°±æ¢å¤å®Œæˆäº†.&lt;/p&gt;

&lt;h3 id=&#34;cluster&#34;&gt;Cluster&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Cluster struct {
	Dir         string
	R           *raft.Raft
	Stores      *raft.InmemStore
	FSM         *fsm.StorageFSM
	Snap        raft.SnapshotStore
	Tran        raft.Transport
	PeerStorage raft.PeerStore
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¥½å§ï¼Œå·ä¸ªæ‡’ï¼Œ&lt;code&gt;raft.Raft&lt;/code&gt;è®¿é—®æƒé™ç›´æ¥æš´éœ²å‡º&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PeerStorge&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;èŠ‚ç‚¹åœ°å€åˆ—è¡¨çš„å­˜å‚¨å¯¹è±¡
- Tran&lt;/p&gt;

&lt;p&gt;èŠ‚ç‚¹ç½‘ç»œé€šä¿¡å¯¹è±¡
- Snap&lt;/p&gt;

&lt;p&gt;æ—¥å¿—å¿«ç…§
- FSM&lt;/p&gt;

&lt;p&gt;çŠ¶æ€æœº
- Stores&lt;/p&gt;

&lt;p&gt;æ—¥å¿—å­˜å‚¨å¯¹è±¡&lt;/p&gt;

&lt;h3 id=&#34;rpc&#34;&gt;RPC&lt;/h3&gt;

&lt;p&gt;èŠ‚ç‚¹ä¹‹é—´çš„ä¸šåŠ¡é€šä¿¡ä¸»è¦é‡‡ç”¨&lt;code&gt;gRPC&lt;/code&gt;æ–¹å¼.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pb&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-probuffer&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;

package pb;

service RiotGossip {
    rpc OpRPC(OpRequest) returns (OpReply) {}
}

message OpRequest {
    string op = 1;
    string key= 2;
    bytes value = 3;
}

message OpReply {
    int32 status = 1;
    string msg = 2;
    int32 errCode = 3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OpRequest.op&lt;/code&gt;è¡¨ç¤ºæ“ä½œç±»å‹ï¼Œå…¶å–å€¼ä¸ºï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;CmdGet   = &amp;quot;GET&amp;quot;
CmdSet   = &amp;quot;SET&amp;quot;
CmdDel   = &amp;quot;DEL&amp;quot;
CmdShare = &amp;quot;SHARE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æ€»å…±4åšæ“ä½œç±»å‹ï¼Œå…¶ä¸­&lt;code&gt;SHARE&lt;/code&gt;å’Œ&lt;code&gt;CmdGet&lt;/code&gt;è¿™ä¸¤ç±»å‹ä¸ä¼šå½±å“åˆ°æ—¥å¿—å¿«ç…§ã€‚&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;PS&lt;/code&gt;ï¼š&lt;code&gt;OpReply&lt;/code&gt;ç»“æ„éœ€è¦è°ƒæ•´ä¸€ä¸‹ï¼Œå¦‚æœ&lt;code&gt;GET&lt;/code&gt;æ“ä½œå¢åŠ ä¸€è‡´æ€§ï¼Œèµ·ç éœ€è¦å¢åŠ ä¸€é¡¹&lt;code&gt;value&lt;/code&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RiotRPCClient&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotRPCClient struct {
	l    *sync.RWMutex
	conn map[string]*grpc.ClientConn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æ¯ä¸ªæœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯çš„è¿æ¥æœ‰ä¸”åªæœ‰ä¸€ä¸ª&lt;code&gt;conn&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RiotRPCService&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotRPCService struct{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RiotRPCService&lt;/code&gt;åªè¦å®ç°&lt;code&gt;OpRPC&lt;/code&gt;è¿™ä¸ªæ–¹æ³•å³å¯&lt;/p&gt;

&lt;h3 id=&#34;http-interface&#34;&gt;Http Interface&lt;/h3&gt;

&lt;p&gt;æ‰€æœ‰çš„ä¸šåŠ¡å…¥å£éƒ½æ˜¯&lt;code&gt;http&lt;/code&gt;è¯·æ±‚ï¼ŒåŒ…æ‹¬é›†ç¾¤ç®¡ç†&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RiotHandler&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type RiotHandler struct{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RiotHandler&lt;/code&gt;æ›´å…·è¯·æ±‚ç±»å‹æ¥åˆ¤å®šæ“ä½œç±»å‹.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AdminHandlerFunc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;AdminHandlerFunc&lt;/code&gt;å¯ä»¥è·å–åˆ°é›†ç¾¤çš„&lt;code&gt;Leader&lt;/code&gt;åœ°å€ã€é›†ç¾¤èŠ‚ç‚¹åœ°å€ä¿¡æ¯ã€èŠ‚ç‚¹è§’è‰²ä¿¡æ¯ã€èŠ‚ç‚¹çš„&lt;code&gt;rpc&lt;/code&gt;åœ°å€ä¿¡æ¯ï¼›è¿˜æœ‰åˆ é™¤é›†ç¾¤ä¸­çš„æŸä¸€ä¸ªèŠ‚ç‚¹ä»¥åŠæŠŠæ–°èŠ‚ç‚¹åŠ å…¥åˆ°é›†ç¾¤ä¸­ã€‚&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;è„šæœ¬ä½äº&amp;rsquo;riot/tool&amp;rsquo;ç›®å½•ä¸‹ï¼š&lt;/p&gt;

&lt;h3 id=&#34;å¯åŠ¨é›†ç¾¤&#34;&gt;å¯åŠ¨é›†ç¾¤&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;bash-3.2$ ./cluster1.sh
raft: {127.0.0.1 12000 [127.0.0.1:12000] raft0/raft_peer_storage raft0/raft_snapshot_storage raft0/storage_backend_path raft0/raft_log_path raft0/apply_log_path true}
rpc: {127.0.0.1 32123}
leader rpc: { }
server:{localhost 8080}
raft: {127.0.0.1 12001 [127.0.0.1:12001] raft1/raft_peer_storage raft1/raft_snapshot_storage raft1/storage_backend_path raft1/raft_log_path raft1/apply_log_path false}
rpc: {127.0.0.1 32124}
leader rpc: { }
server:{localhost 8081}
2016/05/02 23:35:11 admin_handler.go:124 [info] The Leader Name is :127.0.0.1:12000
2016/05/02 23:35:11 admin_handler.go:130 [debug] 127.0.0.1:12001will join the cluster, leader is :127.0.0.1:12000
2016/05/02 23:35:11 [DEBUG] raft-net: 127.0.0.1:12001 accepted connection from: 127.0.0.1:61792
2016/05/02 23:35:11 riot.go:147 [error] 127.0.0.1:12000timed out enqueuing operation
2016/05/02 23:35:11 riot.go:124 [info] {&amp;lt;nil&amp;gt; 0 0.0030684640000000003 {0 0 &amp;lt;nil&amp;gt;}}
2016/05/02 23:35:11 [DEBUG] raft-net: 127.0.0.1:12001 accepted connection from: 127.0.0.1:61793
raft: {127.0.0.1 12002 [127.0.0.1:12002] raft2/raft_peer_storage raft2/raft_snapshot_storage raft2/storage_backend_path raft2/raft_log_path raft2/apply_log_path false}
rpc: {127.0.0.1 32125}
leader rpc: { }
server:{localhost 8082}
2016/05/02 23:35:13 admin_handler.go:124 [info] The Leader Name is :127.0.0.1:12000
2016/05/02 23:35:13 admin_handler.go:130 [debug] 127.0.0.1:12002will join the cluster, leader is :127.0.0.1:12000
2016/05/02 23:35:13 [DEBUG] raft-net: 127.0.0.1:12002 accepted connection from: 127.0.0.1:61797
2016/05/02 23:35:13 riot.go:124 [info] {&amp;lt;nil&amp;gt; 0 0.004264005 {0 0 &amp;lt;nil&amp;gt;}}
2016/05/02 23:35:13 [DEBUG] raft-net: 127.0.0.1:12002 accepted connection from: 127.0.0.1:61798
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;æŸ¥çœ‹é›†ç¾¤ä¿¡æ¯&#34;&gt;æŸ¥çœ‹é›†ç¾¤ä¿¡æ¯&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  &amp;quot;http://localhost:8080/admin/status&amp;quot;
{
  &amp;quot;results&amp;quot;: &amp;quot;Leader&amp;quot;,
  &amp;quot;error&amp;quot;: 0,
  &amp;quot;time&amp;quot;: 3.9520000000000004e-06
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  &amp;quot;http://localhost:8080/admin/peer&amp;quot;
{
  &amp;quot;results&amp;quot;: [
    &amp;quot;127.0.0.1:12002&amp;quot;,
    &amp;quot;127.0.0.1:12000&amp;quot;,
    &amp;quot;127.0.0.1:12001&amp;quot;
  ],
  &amp;quot;error&amp;quot;: 0,
  &amp;quot;time&amp;quot;: 0.017415839000000002
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  &amp;quot;http://localhost:8080/admin/status&amp;quot;
{
  &amp;quot;results&amp;quot;: &amp;quot;Leader&amp;quot;,
  &amp;quot;error&amp;quot;: 0,
  &amp;quot;time&amp;quot;: 2.7490000000000003e-06
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;åŸºæœ¬æ“ä½œ&#34;&gt;åŸºæœ¬æ“ä½œ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SET&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl http://localhost:8080/riot\?key\=a -d &#39;1024&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl http://localhost:8081/riot\?key\=a
1024%
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DEL&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl -XDELETE http://localhost:8082/riot\?key\=a
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;curl  http://localhost:8082/riot\?key\=a
{&amp;quot;errCode&amp;quot;:40004,&amp;quot;msg&amp;quot;:&amp;quot;not found&amp;quot;}%
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;å¢åŠ å¿«ç…§çš„å‹ç¼©ç®—æ³•,æé«˜å‹ç¼©æ•ˆç‡&lt;/li&gt;
&lt;li&gt;å¢åŠ è·Ÿå¤šçš„ç›‘æ§ä¿¡æ¯&lt;/li&gt;
&lt;li&gt;å¢åŠ å¤šç§åç«¯å­˜å‚¨å¼•æ“çš„æ”¯æŒ&lt;/li&gt;
&lt;li&gt;ä¼˜åŒ–ä»£ç ç»“æ„&lt;/li&gt;
&lt;li&gt;é‡æ–°è®¾è®¡&lt;code&gt;http api&lt;/code&gt;ï¼Œæ–°çš„&lt;code&gt;api&lt;/code&gt;ä¸º&lt;code&gt;REST&lt;/code&gt;é£æ ¼&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>erlangå­¦ä¹ ç¬”è®°</title>
      <link>https://laohanlinux.github.io/2016/04/25/erlang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 25 Apr 2016 00:15:14 +0000</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/25/erlang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h2 id=&#34;erlang-ä¹‹ç®€å•çš„-diction-å®ç°&#34;&gt;&lt;code&gt;erlang&lt;/code&gt; ä¹‹ç®€å•çš„&lt;code&gt;Diction&lt;/code&gt;å®ç°&lt;/h2&gt;

&lt;p&gt;æœ€è¿‘åœ¨çœ‹å­¦erlang ï¼Œçœ‹åˆ°äº†å­—å…¸è¿™ä¸ªdemo ï¼ŒæŠŠç¨‹åºCopyå‡ºæ¥å’Œå¤§å®¶åˆ†äº«ä¸€ä¸‹&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module (diction).  
    -export([new/0,lookup/2,add/3,delete/2]).  
    new()   -&amp;gt;  
        [].  
      
    lookup(Key , [{Key,Value}|Rest])    -&amp;gt;  
        {value,Value};  
    lookup(Key,[Pair|Rest])     -&amp;gt;  
        lookup(Key,Rest);  
    lookup(Key,[])  -&amp;gt;  
        undefined.  
    add(Key,Value,Diction)  -&amp;gt;  
        NewDict =   delete(Key,Diction) ,  
        [{Key,Value}|NewDict].  
      
    delete(Key,[{Key,Value}|Rest])  -&amp;gt;  
        Rest;  
    delete(Key,[Pair|Rest]) -&amp;gt;  
        [Pair|delete(Key,Rest)];  
    delete(Key,[])  -&amp;gt;  
        [].  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å‡½æ•°ç¼–ç¨‹ä¹ æƒ¯ä¹‹åï¼Œå†™èµ·æ¥ä¹Ÿæ˜¯æŒºçˆ½çš„æ„è§äº‹ï¼ŒåŸºæœ¬ä¸Šéƒ½æ˜¯é€’å½’çš„æ€æƒ³ã€‚&lt;/p&gt;

&lt;h2 id=&#34;erlang-ä¹‹ç®€å•å¯†ç åŠ å¯†&#34;&gt;&lt;code&gt;erlang&lt;/code&gt; ä¹‹ç®€å•å¯†ç åŠ å¯†&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;è¿™äº›ç¨‹åºä¸»è¦æ˜¯æ¥ä¹‹ è¿åŸ ç¿»è¯‘çš„ä¸€ä¸ªä¹¦é‡Œé¢çš„ä»£ç &lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(encode).  
    -export([encode/2]).  
    encode(Pin.Password)    -&amp;gt;  
        Code = {nil,nil,nil,nil,nil,nil,nil,nil,nil,  
            nil,nil,nil,nil,nil,nil,nil,nil,nil,  
            nil,nil,nil,nil,nil,nil,nil,nil},  
        encode(Pin,Password,Code).  
    encode([],_,Code)   -&amp;gt;  
        Code ;  
    encode(Pin,[],code) -&amp;gt;  
        io:format(&amp;quot;Out of Letters~n&amp;quot;,[]);  
      
    encode(H|T,[Letter|T1],Code)    -&amp;gt;  
        Arg = index(Letter) +1 ,  
        case element(Arg,Code) of   
            nil -&amp;gt;  
                encode (T,T1,setelement(Arg,Code,index(H)));  
        _-&amp;gt;  
            encode ([H|T],T1,Code)  
        end.  
      
    index(X)    when X &amp;gt;= $0 ,X =&amp;lt; $9 -&amp;gt;  
            X - $0;  
    index(X)    when X&amp;gt;=$A , X =&amp;lt; $Z  -&amp;gt;  
            X - $A.  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;erlang-ç®€å•çš„æ ‘æ“ä½œ&#34;&gt;erlang ç®€å•çš„æ ‘æ“ä½œ&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-module(tree).  
-export([test1/0]).  
lookup(Key,nil) -&amp;gt;  
    not_found;  
lookup(Key,{Key,Value,_,_}) -&amp;gt;  
    {found,Value};  
lookup(Key,{Key1,_,Smaller,_}) when Key &amp;lt; Key1   -&amp;gt;  
    lookup(Key,Smaller);  
lookup(Key,{Key1,_,_,Bigger})   when Key &amp;gt; Key1 -&amp;gt;  
    lookup(Key,Bigger).  
  
insert(Key,Value ,nil)  -&amp;gt;  
    {Key,Value,nil,nil};  
insert(Key,Value,{Key,_,Smaller,Bigger})    -&amp;gt;  
    {Key,Value,Smaller,Bigger}  ;  
insert(Key,Value,{Key1,V,Smaller,Bigger})   when Key &amp;lt; Key1 -&amp;gt;  
    {Key1,V,insert(Key,Value,Smaller),Bigger};  
insert(Key,Value,{Key1,V,Smaller,Bigger})   when Key &amp;gt; Key1  -&amp;gt;  
    {Key1,V,Smaller,insert(Key,Value,Bigger)}.  
write_tree(T)   -&amp;gt;  
    write_tree(0,T).  
write_tree(D,nil)   -&amp;gt;  
    io:tab(D),  
    io:format(&#39;nil&#39;,[]);  
write_tree(D,{Key,Value,Smaller,Bigger})    -&amp;gt;  
    D1 = D +4 ,  
    write_tree(D1,Bigger),  
    io:format(&#39;~n&#39;,[]),  
    io:tab(D),  
    io:format(&#39;~w ==&amp;gt; ~w~n&#39;,[Key,Value]),  
    write_tree(D1,Smaller).  
  
test1() -&amp;gt;  
    S1=nil,  
    S2=insert(4,joe,S1),  
    S3=insert(12,fred,S2),  
    S4=insert(3,jane,S3),  
    S5=insert(7,kalle,S4),  
    S6=insert(6,thomes,S5),  
    S7=insert(5,rickard,S6),  
    S8=insert(9,susan,S7),  
    S9=insert(2,tobbe,S8),  
    S10=insert(8,dan,S9),  
    write_tree(S10).  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä»£ç ä¸å¤šï¼Œ&lt;code&gt;erlang&lt;/code&gt;å†™ç®—æ³•&amp;hellip;&amp;hellip;å‘µå‘µå‘µå‘µå‘µå‘µ&lt;/p&gt;

&lt;h2 id=&#34;erlang-å¹¶å‘ç¼–ç¨‹&#34;&gt;erlang å¹¶å‘ç¼–ç¨‹&lt;/h2&gt;

&lt;p&gt;æœ€è¿‘ä¸Šç­æ¯”è¾ƒå¿™ï¼Œæ²¡æ—¶é—´å­¦ä¹ erlang ï¼Œå®åœ¨å¯¹ä¸èµ·è‡ªå·±å•Šï¼Œä»¥å‰ä¸€ç›´åœ¨æ‰¾erlangç›¸å…³çš„æ•™ç¨‹ï¼Œç»ˆäºæ‰¾åˆ°ä¸€ä¸ªäº†ï¼Œè¿™ä¸ªç½‘ç«™æ˜¯å‰å‡ å¤©æ‰å¼€å§‹è¿è¡Œçš„ï¼Œä»¥åçš„æ–‡ç« å¯èƒ½éƒ½æ˜¯æ¥è‡ªäºé‚£é‡Œï¼Œç½‘ç«™æ˜¯&lt;code&gt;http://www.erlang-cn.com&lt;/code&gt; ï¼Œå¤§å®¶å¿™æ²¡äº‹å¤šå­¦ä¹ ï¼å¤§ç¬‘&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;å¹¶å‘ç¼–ç¨‹ä¸€&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-module(tut15).  
-export([start/0,ping/2,pong/0]).  
ping(0,Pong_PID)    -&amp;gt;  
    %%æƒ³å¯¹æ–¹å‘é€é€€å‡ºä¿¡å·  
    Pong_PID ! finished,  
    io:format(&amp;quot;ping finished~n&amp;quot;,Pong_PID);  
ping(N,Pong_PID)    -&amp;gt;  
    Pong_PID ! {ping,self()},  
    receive   
        pong    -&amp;gt;  
            io:format(&amp;quot;Ping receive pong ~n&amp;quot;,[])  
    end,  
    %%ç»§ç»­æ¥å—ä¿¡æ¯ï¼Œç›´åˆ° N == 0  
    ping(N-1,Pong_PID).  
  
pong()  -&amp;gt;  
    receive  
        finished    -&amp;gt;  
            io:format(&amp;quot;Pong finished~n&amp;quot;,[]);  
        {ping,Ping_PID} -&amp;gt;  
            io:format(&amp;quot;Pong received ping ~n&amp;quot;,[]),  
            Ping_PID!pong,  
            %%å†æ¬¡ç­‰å¾…å¯¹æ–¹çš„ä¿¡æ¯ï¼Œç›´åˆ°ä¿¡æ¯ä¸ºffinished  
            pong()  
        end.  
start() -&amp;gt;  
    %% å¼€å¯ä¸€ä¸ªè¿›ç¨‹ï¼Œç”¨æ¥ç­‰å¾…å…¶ä»–è¿›ç¨‹çš„ä¿¡æ¯  
    Pong_PID = spawn(tut15,pong,[]),  
    %%å¼€å¯ä¸€ä¸ªè¿›ç¨‹ï¼Œç”¨æ¥å‘é€ä¿¡æ¯  
    spawn(tut15,ping,[3,Pong_PID]),  
    io:format(&amp;quot;Main Process Exit~n&amp;quot;,[]). 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿›ç¨‹çš„æ ‡è¯† ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€ç§æ›´åŠ çµæ´»çš„æ–¹æ³•æ¥æ ‡è®°å¥¹é‚£å°±æ˜¯ä½¿ç”¨&lt;code&gt;register&lt;/code&gt;å‡½æ•°&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-module(tut16).  
-export([start/0,ping/1,pong/0]).  
  
ping(0) -&amp;gt;  
    pong ! finished,  
    io:format(&amp;quot;ping finished ~n&amp;quot;,[]);  
ping(N) -&amp;gt;  
    %% send the message to pong proccess  
    pong ! {ping,self()},  
  
    receive   
        pong -&amp;gt;  
            io:format(&amp;quot;Ping received pong ~n&amp;quot;,[])  
    end ,  
    ping(N-1).  
  
pong()  -&amp;gt;  
    receive   
        finished    -&amp;gt;  
            io:format(&amp;quot;Pong finished~n&amp;quot;,[]);  
        {ping,Ping_PID} -&amp;gt;  
            io:format(&amp;quot;Pong received ping~n&amp;quot;,[]),  
            Ping_PID ! pong,  
            pong()  
    end.  
  
start() -&amp;gt;  
    register(pong,spawn(tut16,pong,[])),  
    spawn(tut16,ping,[3]).  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;register&lt;/code&gt;ä¸­çš„&lt;code&gt;pong&lt;/code&gt;å°±æ ‡è¯†äº†&lt;code&gt;spawn(tut16,pong,[])&lt;/code&gt;è¿™ä¸ªè¿›ç¨‹ï¼Œè¿™ä¸ª&lt;code&gt;pingï¼ˆï¼‰&lt;/code&gt;å‡½æ•°åªè¦ä¸€ä¸ª&lt;code&gt;N&lt;/code&gt;å°±è¡Œäº†ï¼Œ&lt;code&gt;pong&lt;/code&gt;å¯ä»¥çœ‹ä½œæ˜¯è¿›ç¨‹ä¹‹é—´å…±äº«çš„å˜é‡.&lt;/p&gt;

&lt;h2 id=&#34;erlang-ä¹‹-echo-æœåŠ¡å™¨&#34;&gt;erlang ä¹‹ echo æœåŠ¡å™¨&lt;/h2&gt;

&lt;p&gt;ç®€å•å®ç°äº†ä¸€ä¸ªecho æœåŠ¡å™¨&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;echo_server1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(echo).  
    -export([start/0,loop/0]).  
      
    start() -&amp;gt;  
        Pid = spawn(echo,loop,[]),  
        Pid ! {self(),&#39;Hello Word&#39;},  
        receive   
            {Pid,Msg}   -&amp;gt;  
                io:format(&#39;~w~n&#39;,[Msg])  
        end,  
        Pid ! stop.  
      
    loop()  -&amp;gt;  
        receive   
            {FromOther,Msg} -&amp;gt;  
                io:format(&amp;quot;~w~n&amp;quot;,[Msg]),  
                FromOther!{self(),&#39;Loop Proccess Send to You !&#39;},  
                loop();  
            {stop}  -&amp;gt;  
                %%io:format(&#39;~w~n&#39;,[loop_stop]),  
                true  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outputï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;29&amp;gt; echo:start().  
&#39;Hello Word&#39;  
&#39;Loop Proccess Send to You !&#39;  
stop  
30&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­ stop æ˜¯ä¸»è¿›ç¨‹çš„è¿”å›å€¼&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;echo_server2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¿™æ˜¯ä¸€ä¸ªç®€å•ç”¨äºç­‰å¾…å¤–éƒ¨ä¿¡æ¯çš„echo server&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(echo_server).  
    -export([start/0,print/1,stop/0,loop/0]).  
      
    start() -&amp;gt;  
        Pid = spawn(echo_server , loop , []),  
        register(sub1,Pid),   
        {ok,Pid}.  
      
    loop()  -&amp;gt;  
        receive   
            {print,A}   -&amp;gt;  
                io:format(&amp;quot;~p.~n&amp;quot;,[A]),  
                loop();  
            stop    -&amp;gt;  
                true;  
            Other -&amp;gt;  
                io:format(&amp;quot;~p~n&amp;quot;,[Other]),  
                loop()   
        end.  
      
    print(A)    -&amp;gt;  
        sub1 ! {print,A},  
        true .  
    stop()  -&amp;gt;  
        sub1 ! stop ,  
        %%   
        true .  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;timeout-çš„ç®€å•ä½¿ç”¨&#34;&gt;timeout çš„ç®€å•ä½¿ç”¨&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;ä»Šå¤©æ™šä¸Šæœ‰ç‚¹æ™šäº†ï¼Œä¸è¿‡è¿˜æ˜¯åšæŒæ¯ä¸€å¤©å†™ä¸€ä¸ªç¨‹åºï¼&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ä¸‹é¢çš„æ—¶è¶…æ—¶å™¨ ï¼š&lt;/p&gt;

&lt;p&gt;å»ºè®¾&lt;code&gt;A&lt;/code&gt;è¦æƒ³&lt;code&gt;db&lt;/code&gt;è¿›ç¨‹å‘é€ä¸€ä¸ªä¿¡æ¯ï¼Œç„¶ååœ¨è§„å®šçš„æ—¶é—´å†…ç­‰å¾…æ¶ˆæ¯çš„è¿”å›ï¼Œé‚£ä¹ˆ&lt;code&gt;A&lt;/code&gt;å¯ä»¥è®¾ç½®ä¸€ä¸ªè¶…æ—¶å™¨ï¼Œæ³¨æ„çš„æ˜¯åœ¨å‘é€æ¶ˆæ¯ä¹‹å‰ï¼Œå¾—å…ˆæ¸…ç©ºæ¶ˆæ¯é˜Ÿåˆ—ï¼Œè¦ä¸ç„¶ç­‰è¯‘æ¥åˆ°çš„æ¶ˆæ¯å¯èƒ½&lt;code&gt;db&lt;/code&gt;è¿˜æ²¡å‘é€ä¹‹å‰çš„äº†.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    read(Key)   -&amp;gt;  
        flush(),  
        db | {self(),{read,Key}},  
        receive   
            {read,R}    -&amp;gt; {ok,R};  
            {error,Reason}  -&amp;gt; {error,Reason}  
        after 1000  -&amp;gt;   {error,timeout}  
        end.  
      
    flush() -&amp;gt;  
        receive   
            {read,_}    -&amp;gt; flush();  
            {error,_}   -&amp;gt;flush()  
        after 0 -&amp;gt;ok   
    end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;erlangè¿›ç¨‹ç”Ÿæˆæµ‹è¯•&#34;&gt;Erlangè¿›ç¨‹ç”Ÿæˆæµ‹è¯•&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(myring).  
    -export([start/1,start_proc/2]).  
    start(Num)  -&amp;gt;  
        start_proc(Num,self()).  
    start_proc(0,Pid)   -&amp;gt;  
        receive   
            ok -&amp;gt; ok   
        end,  
        Pid ! ok ;  
    start_proc(Num,Pid) -&amp;gt;  
        NPid = spawn(?MODULE,start_proc ,[Num-1,Pid]),  
        NPid ! ok ,  
        receive   
            ok -&amp;gt; ok ,  
            io:format(&amp;quot;~w~n&amp;quot;,[Num])  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿›ç¨‹é€€å‡ºæ—¶ä¼šè¿”å›okã€‚&lt;/p&gt;

&lt;h2 id=&#34;erlang-ä¹‹æ—¶é’Ÿ&#34;&gt;&lt;code&gt;erlang&lt;/code&gt;ä¹‹æ—¶é’Ÿ&lt;/h2&gt;

&lt;p&gt;ä»Šå¤©æ¥çœ‹ä¸€ä¸‹&lt;code&gt;erlang&lt;/code&gt;ä¸­çš„æ—¶é’Ÿå¦‚ä½•å®ç°çš„ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(timeout).  
    -export([sleep/1,flush_buffer/0]).  
      
      
      
    %%%ç¡çœ å‡½æ•°  
    sleep(Time) -&amp;gt;  
        receive   
            after Time -&amp;gt;  
            true  
        end.  
      
    %%%æ¸…ç©ºé‚®ç®±  
      
    flush_buffer()  -&amp;gt;  
        receive   
            AnyMessage  -&amp;gt;  
                flush_buffer()  
            after   0   -&amp;gt;  
                true  
        end.  
      
    %%% æ¶ˆæ¯ä¼˜å…ˆçº§çš„å®ç°  
    %% å‡½æ•°priority_receiveä¼šè¿”å›é‚®ç®±ä¸­ç¬¬ä¸€ä¸ªæ¶ˆæ¯ï¼Œé™¤éæœ‰æ¶ˆæ¯interruptå‘é€åˆ°äº†é‚®ç®±ä¸­ï¼Œæ­¤æ—¶å°†è¿”  
    %%å›interruptã€‚é€šè¿‡é¦–å…ˆä½¿ç”¨è¶…æ—¶æ—¶é•¿0æ¥è°ƒç”¨receiveå»åŒ¹é…interruptï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥é‚®ç®±ä¸­æ˜¯å¦å·²ç»æœ‰äº†  
    %%%è¿™ä¸ªæ¶ˆæ¯ã€‚å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬å°±è¿”å›å®ƒï¼Œå¦åˆ™ï¼Œæˆ‘ä»¬å†é€šè¿‡æ¨¡å¼AnyMessageå»è°ƒç”¨receiveï¼Œè¿™å°†é€‰ä¸­é‚®ç®±ä¸­çš„  
    %%ç¬¬ä¸€æ¡æ¶ˆæ¯ã€‚  
    priority_receive()  -&amp;gt;  
        receive  
            interrupt   -&amp;gt;  
                interrupt  
            after   0   -&amp;gt;  
                receive  
                    AnyMessage  -&amp;gt;  
                        AnyMessage  
                end  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä¸Šé¢ä¸»è¦æ˜¯ç¡çœ  å’Œæ¸…ç©ºâ€œé‚®ç®±â€ ï¼Œè¿˜æœ‰å°±æ˜¯ä¼˜å…ˆçº§çš„ç®€å•å®ç°.&lt;/p&gt;

&lt;p&gt;ä¸‹é¢å†æ¥ä¸€æ®µå§ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    -module(timer).  
    -export([timeout/2,cancel/1,timer/3]).  
      
    timeout(Time,Alarm) -&amp;gt;  
        spawn(timer,timer,[self(),Time,Alarm]).  
      
      
    cancel(Timer)   -&amp;gt;  
        Timer ! {self(),cancel}.  
    timer(Pid,Time,Alarm)   -&amp;gt;  
        receive       
            {Pid,cancel}    -&amp;gt;  
                true  
        after   Time    -&amp;gt;  
            Pid ! Alarm  
        end.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;ä¸­æ¼”ç¤ºä¸€ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;    13&amp;gt; Pid=self(),  
    13&amp;gt; timer:timer(Pid,1000,hellword).  
    hellword  
    14&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-simple-erlang-process-pool-analysis&#34;&gt;a simple erlang process pool analysis&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/blog/erlang/pool/ppoll.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;è¿™æ˜¯ä¸€ä¸ªç®€å•çš„&lt;code&gt;erlang&lt;/code&gt;è¿›ç¨‹æ± åˆ†æï¼Œæ˜¯&lt;code&gt;learn you some erlang for Great Good&lt;/code&gt;é‡Œé¢çš„ä¸€ä¸ª&lt;code&gt;example&lt;/code&gt;ï¼Œè¯¦ç»†çš„å†…å®¹å¯åˆ°å®˜ç½‘æŸ¥çœ‹ï¼&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;å®ç°åŸç†&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;è¿™ä¸ªçš„ä¾‹å­çš„å®ç°åŸç†å®˜ç½‘éƒ½æœ‰æ¯”è¾ƒè¯¦ç»†çš„è¯´æ˜ï¼Œä¸»è¦æ¨¡å—åœ¨&lt;code&gt;ppool_serv&lt;/code&gt;ä¸­ï¼Œ&lt;code&gt;ppool_serv&lt;/code&gt;æ˜¯ä¸€ä¸ª&lt;code&gt;gen_server behaviour&lt;/code&gt;, è€Œ&lt;code&gt;ppool_sup&lt;/code&gt;æ˜¯ä¸€ä¸ª&lt;code&gt;one_for_all&lt;/code&gt;çš„ç­–ç•¥,å¦‚æœ&lt;code&gt;ppool_serv&lt;/code&gt;æˆ–è€…&lt;code&gt;worker_sup&lt;/code&gt;å‡ºç°é—®é¢˜ï¼Œå½¼æ­¤ä¹Ÿæ²¡æœ‰å­˜åœ¨çš„å¿…è¦äº†ã€‚&lt;/p&gt;

&lt;p&gt;è¿™é‡Œ&lt;code&gt;ppool_serv&lt;/code&gt;å’Œ&lt;code&gt;worker_sup&lt;/code&gt;çš„å®ç°ï¼Œä½¿ç”¨äº†ä¸€ä¸ªç®€å•çš„æŠ€å·§ï¼Œå› ä¸º&lt;code&gt;worker_sup&lt;/code&gt;ä¸æ˜¯&lt;code&gt;ppool_sup&lt;/code&gt;ç›´æ¥è°ƒç”¨ç”Ÿæˆçš„ï¼Œå®ƒæ˜¯ç”±&lt;code&gt;ppool_serv&lt;/code&gt;æ§åˆ¶ç”Ÿæˆçš„ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;
%% Gen server
init({Limit, MFA, Sup}) -&amp;gt;
    %% We need to find the Pid of the worker supervisor from here,
    %% but alas, this would be calling the supervisor while it waits for us!
    self() ! {start_worker_supervisor, Sup, MFA},
    {ok, #state{limit=Limit, refs=gb_sets:empty()}}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;woker_sup&lt;/code&gt;ç”±&lt;code&gt;ppool_serv&lt;/code&gt;è‡ªå·±åœ¨&lt;code&gt;init&lt;/code&gt;å‡½æ•°ä¸­ï¼Œå‘ç»™è‡ªå·±ä¸€ä¸ª&lt;code&gt;Message&lt;/code&gt;ï¼Œç„¶ååœ¨å›è°ƒå‡½æ•°ä¸­æ‰ç”Ÿæˆï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;handle_info({start_worker_supervisor, Sup, MFA}, S = #state{}) -&amp;gt;
    {ok, Pid} = supervisor:start_child(Sup, ?SPEC(MFA)),
    link(Pid),
    {noreply, S#state{sup=Pid}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¦‚æœä»–ä»¬ä¸€èµ·ç›´æ¥ç”Ÿäº§ï¼Œé‚£ä¹ˆä¼šäº§ç”Ÿæ­»é”ï¼Œ
&lt;center&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/blog/erlang/pool/ppool_1.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;å½“ç„¶ï¼Œä»–è¿™é‡Œçš„ç”Ÿæˆé¡ºåºï¼Œå¯ä»¥è‡ªå·±ä¿®æ”¹ä¸€ä¸‹ï¼Œä¹Ÿä¸ä¼šå‡ºç°æ­»é”ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gen_serv&lt;/code&gt;çš„ä¸»è¦æ•°æ®ç»“æ„&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-define(SPEC(MFA),
        {worker_sup,
         {ppool_worker_sup, start_link, [MFA]},
          temporary,
          10000,
          supervisor,
          [ppool_worker_sup]}).

-record(state, {limit=0,
                sup,
                refs,
                queue=queue:new()}).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;?SPEC(MFA)&lt;/code&gt;, è¿™é‡Œçš„&lt;code&gt;MFA&lt;/code&gt;æŒ‡æ˜ä¸€ç±»&lt;code&gt;Task&lt;/code&gt;ï¼Œæ‰€ä»¥åŒä¸€ä¸ª&lt;code&gt;ppool_worker_sup&lt;/code&gt;,ä¸ä¼šæœ‰ä¸åŒç±»å‹çš„&lt;code&gt;Task&lt;/code&gt;ï¼Œå®ƒçš„ç­–ç•¥ä¹Ÿæ˜¯&lt;code&gt;simple_one_for_one&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½¿ç”¨äº†ä¸€ä¸ª&lt;code&gt;gen_server -- nnager module&lt;/code&gt;ä½œä¸º&lt;code&gt;Task&lt;/code&gt;ï¼Œè¿™ä¸ª&lt;code&gt;Task&lt;/code&gt;çš„å‚æ•°ä¸ºï¼š&lt;code&gt;{Task, Delay, Max, SendTo}&lt;/code&gt;ï¼Œ &lt;code&gt;Task&lt;/code&gt;æ ‡ç¤ºä»»åŠ¡åå­—ï¼Œ&lt;code&gt;Delay&lt;/code&gt;ä½œä¸ºè¶…æ—¶æ—¶é—´ï¼Œåªæ˜¯æ ‡ç¤ºè¿™ä¸ªä»»åŠ¡æ˜¯æœ‰è¶…æ—¶é™åˆ¶çš„ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªè°ƒè¯•æŠ€å·§ï¼Œ&lt;code&gt;Max&lt;/code&gt;ä¸ºæœ€å¤§è¶…æ—¶æ¬¡æ•°ï¼Œ&lt;code&gt;SendTo&lt;/code&gt;ç”¨æ¥å‘é€ä¿¡æ¯ç»™å›è°ƒè¿›ç¨‹ï¼Œè¿™ä¸ªè¿›ç¨‹å¯ä»¥æ˜¯&lt;code&gt;shell&lt;/code&gt;ï¼Œ å¦‚æœæ˜¯&lt;code&gt;shell&lt;/code&gt;ï¼Œ&lt;code&gt;flush()&lt;/code&gt;å°±ä¼šæ”¶åˆ°ä¿¡æ¯ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;record&lt;/code&gt;ç”¨æ¥æ ‡è¯†ä¸€äº›ä¸»è¦çš„ä¿¡æ¯ï¼Œ&lt;code&gt;Limit&lt;/code&gt;ä¸ºè¿›ç¨‹æ± çš„å¤§å°é™åˆ¶ï¼Œ&lt;code&gt;sup&lt;/code&gt;å¼€å§‹ä¸º&lt;code&gt;ppool_sup&lt;/code&gt;çš„&lt;code&gt;pidï¼ˆï¼‰&lt;/code&gt;ï¼Œåœ¨ç”Ÿæˆ&lt;code&gt;woker_sup&lt;/code&gt;è¿›ç¨‹åï¼Œå°±å˜æˆ&lt;code&gt;worker_sup&lt;/code&gt;çš„è¿›ç¨‹&lt;code&gt;pidï¼ˆï¼‰&lt;/code&gt;ï¼Œå› ä¸º&lt;code&gt;ppool_serv&lt;/code&gt;çš„ä¸»è¦äº¤æµå¯¹è±¡è¿˜æ˜¯&lt;code&gt;worker_sup&lt;/code&gt;å’Œ&lt;code&gt;worker(Task)&lt;/code&gt;ï¼› &lt;code&gt;refsï¼ˆgb_setï¼‰&lt;/code&gt;ä¸º&lt;code&gt;woker&lt;/code&gt;çš„è¿›ç¨‹é“¾æ¥ï¼Œè¿™æ ·å¯ä»¥åœ¨&lt;code&gt;worker&lt;/code&gt;è¿›ç¨‹&lt;code&gt;down&lt;/code&gt;æ‰æˆ–è€…&lt;code&gt;done&lt;/code&gt;æ—¶ï¼Œä»çº¿ç¨‹æ± ä¸­å‰”é™¤æ‰ï¼›&lt;code&gt;queue&lt;/code&gt;ä¸ºä»»åŠ¡é˜Ÿåˆ—ï¼Œå½“ä»»åŠ¡å¤§äº&lt;code&gt;limit&lt;/code&gt;æ—¶ï¼Œå°±æŠŠå¤šä½™çš„ä»»åŠ¡æ”¾åˆ°&lt;code&gt;queque&lt;/code&gt;ä¸­ï¼Œç­‰åˆ°è¿›ç¨‹æ± æœ‰ç©ºé—²æ—¶ï¼Œå°±ä»ä¸­&lt;code&gt;pop&lt;/code&gt;å‡ºä»»åŠ¡ï¼Œæ¥ç€å¤„ç†ã€‚&lt;/p&gt;

&lt;p&gt;è¿™é‡Œæœ‰äº›å±€é™çš„åœ°æ–¹ï¼š
- æ¯æ¬¡çš„ä»»åŠ¡éƒ½æ˜¯æ–°å»ºçš„è¿›ç¨‹å»å¤„ç†ï¼Œå°±æ˜¯è¯´è¿›ç¨‹çš„ç”Ÿå‘½å‘¨æœŸè·Ÿä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ä¸€æ ·çš„ï¼Œå¯ä»¥æŠŠè¿›ç¨‹è·Ÿä»»åŠ¡åˆ†ç¦»å‡ºæ¥ï¼Œè®©è¿›ç¨‹ä¸éšä»»åŠ¡çš„ç»“æŸè€Œç»“æŸï¼ˆå½“ç„¶è¿™çš„ä»»åŠ¡å°±ä¸è¦æ˜¯&lt;code&gt;gen_server&lt;/code&gt;,&lt;code&gt;gen_fsm&lt;/code&gt;è¿™äº›ï¼Œå› ä¸ºè¿™äº›ä¹Ÿæ˜¯&lt;code&gt;spawn&lt;/code&gt;å‡ºæ¥çš„è¿›ç¨‹ï¼‰ï¼Œè¿™æ ·è¿›ç¨‹å¼€é”€ç†è®ºä¸Šä¸€æ¬¡åˆå§‹åŒ–å°±è¡Œäº†ï¼Œè™½ç„¶è¿›ç¨‹åœ¨&lt;code&gt;erlang&lt;/code&gt;ä¸­å¼€é”€æ¯”è¾ƒå°‘ï¼›
- é˜Ÿåˆ—æ²¡æœ‰å¤§å°é™åˆ¶&lt;/p&gt;

&lt;h2 id=&#34;poolboy&#34;&gt;PoolBoy&lt;/h2&gt;

&lt;p&gt;source code ï¼š&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/devinus/poolboy&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/devinus/poolboy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://laohanlinux.github.io/images/img/blog/erlang/pool/poolboy.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Checkout&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;
ready({checkout, Block, Timeout}, {FromPid, _}=From, State) -&amp;gt;
    #state{supervisor = Sup,
           workers = Workers,
           monitors = Monitors,
           max_overflow = MaxOverflow} = State,
    case queue:out(Workers) of
        {{value, Pid}, Left} -&amp;gt;
            Ref = erlang:monitor(process, FromPid),
            true = ets:insert(Monitors, {Pid, Ref}),
            NextState = case queue:is_empty(Left) of
                true when MaxOverflow &amp;lt; 1 -&amp;gt; full;
                true -&amp;gt; overflow;
                false -&amp;gt; ready
            end,
            {reply, Pid, NextState, State#state{workers=Left}};
        {empty, Empty} when MaxOverflow &amp;gt; 0 -&amp;gt;
            {Pid, Ref} = new_worker(Sup, FromPid),
            true = ets:insert(Monitors, {Pid, Ref}),
            {reply, Pid, overflow, State#state{workers=Empty, overflow=1}};
        {empty, Empty} when Block =:= false -&amp;gt;
            {reply, full, full, State#state{workers=Empty}};
        {empty, Empty} -&amp;gt;
            Waiting = add_waiting(From, Timeout, State#state.waiting),
            {next_state, full, State#state{workers=Empty, waiting=Waiting}}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Checkout&lt;/code&gt;å‡ºä¸€ä¸ª&lt;code&gt;worker&lt;/code&gt;ä»&lt;code&gt;worker Queue&lt;/code&gt;ä¸­ï¼Œå¦‚æœæœ‰,åˆ™&lt;code&gt;monitorï¼ˆetsï¼‰&lt;/code&gt;è¿™ä¸ª&lt;code&gt;worker&lt;/code&gt;ï¼Œç„¶åæ ¹æ®é˜Ÿåˆ—çš„å®¹é‡å’Œ&lt;code&gt;MaxOverflow&lt;/code&gt;çš„å€¼æ¥ç¡®å®šä¸‹ä¸€çŠ¶æ€ä¸º&lt;code&gt;full&lt;/code&gt;ï¼Œ&lt;code&gt;overflow&lt;/code&gt;ï¼Œ&lt;code&gt;ready&lt;/code&gt; ï¼ˆ&lt;code&gt;ready + overflow &amp;lt;= full&lt;/code&gt;ï¼‰;å¦‚æœæ²¡æœ‰ï¼Œè€Œ&lt;code&gt;MaxOverFlow&lt;/code&gt;çš„å€¼å¤§äº&lt;code&gt;0&lt;/code&gt;ï¼Œåˆ™æ–°å»ºä¸€ä¸ª&lt;code&gt;worker&lt;/code&gt;ï¼Œå¹¶å°†å…¶åŠ å…¥&lt;code&gt;monitor&lt;/code&gt;ï¼Œæœ€åé‡ç½®çŠ¶æ€é¡¹&lt;code&gt;worker = empty, overflow = 1&lt;/code&gt;ï¼›å¦‚æœæ²¡æœ‰ï¼Œå¹¶ä¸”&lt;code&gt;MaxOverflow&lt;/code&gt; å°äº&lt;code&gt;1&lt;/code&gt;ï¼Œ &lt;code&gt;Block == false&lt;/code&gt;ï¼Œåˆ™&lt;code&gt;{reply, full, full, State#state{workers=Empty}}&lt;/code&gt;;å¦‚è¿‡æ²¡æœ‰ï¼Œ&lt;code&gt;MaxOverflow &amp;lt; 1&lt;/code&gt;, &lt;code&gt;Block == true&lt;/code&gt;,åˆ™ &lt;code&gt;{next_state, full, State#state{workers=Empty, waiting=Waiting}}&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Checkin&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;ready({checkin, Pid}, State) -&amp;gt;
    Monitors = State#state.monitors,
    case ets:lookup(Monitors, Pid) of
        [{Pid, Ref}] -&amp;gt;
            true = erlang:demonitor(Ref),
            true = ets:delete(Monitors, Pid),
            Workers = queue:in(Pid, State#state.workers),
            {next_state, ready, State#state{workers=Workers}};
        [] -&amp;gt;
            {next_state, ready, State}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä»&lt;code&gt;Monitor&lt;/code&gt;ä¸­å‰”é™¤å¯¹åº”çš„&lt;code&gt;worker&lt;/code&gt;ï¼Œç„¶åå›æ”¶åˆ°&lt;code&gt;worker queue&lt;/code&gt;ä¸­å»ã€‚
çŠ¶æ€è½¬å˜&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;çŠ¶æ€è½¬å˜çš„è®¡ç®—ï¼š&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;worker_queue_size&lt;/code&gt;(å½“å‰&lt;code&gt;size&lt;/code&gt;) + &lt;code&gt;maxoverflow&lt;/code&gt; ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ready&lt;/code&gt;åªä¸å½“å‰&lt;code&gt;worker_queque_size&lt;/code&gt;æœ‰å…³ï¼Œ&lt;code&gt;overflow&lt;/code&gt; å’Œ&lt;code&gt;worker_queue_size(0)&lt;/code&gt;å’Œ&lt;code&gt;maxoverflow&amp;gt;0&lt;/code&gt;æœ‰å…³ï¼Œ&lt;code&gt;full&lt;/code&gt;å’Œ&lt;code&gt;work_queue_size(0)&lt;/code&gt;, &lt;code&gt;overfllow = maxoverflow&lt;/code&gt;æœ‰å…³ã€‚
- &lt;code&gt;worker&lt;/code&gt;çš„æ¥æº&lt;/p&gt;

&lt;p&gt;æ‰€æœ‰çš„&lt;code&gt;worker&lt;/code&gt;è¦ä¹ˆåœ¨åˆå§‹åŒ–æ—¶åˆ›å»ºå¹³ï¼›è¦ä¹ˆè°ƒç”¨&lt;code&gt;checkout&lt;/code&gt;æ—¶ï¼Œç»è¿‡&lt;code&gt;poolboy&lt;/code&gt;åˆ›å»ºï¼Œä½†æ­¤æ—¶åˆ›å»ºçš„&lt;code&gt;worker&lt;/code&gt;æ²¡æœ‰è¿›åˆ°&lt;code&gt;worker queue&lt;/code&gt;ï¼Œè¦æƒ³è¿›åˆ°&lt;code&gt;worker queue&lt;/code&gt;ï¼Œåªèƒ½è°ƒç”¨&lt;code&gt;checkin&lt;/code&gt;ã€‚
&lt;code&gt;work pid&lt;/code&gt; å›æ”¶åˆ°&lt;code&gt;worker_queue&lt;/code&gt;ä¸­&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;checkin_while_full --ã€‹{empty, Empty} when MaxOverflow &amp;lt; 1 -&amp;gt;ï¼›
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Goimæºç å‰–æ</title>
      <link>https://laohanlinux.github.io/2016/04/04/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 04 Apr 2016 14:53:49 +0800</pubDate>
      
      <guid>https://laohanlinux.github.io/2016/04/04/goim%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>