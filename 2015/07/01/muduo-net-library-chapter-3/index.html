<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Rg">
  <meta name="description" content="Rg&#39;s blog">
  <meta name="keywords" content="blog, Hugo, Rust, Golang, Raft, 火箭少女, Rocket Girl">
  
  <link rel="prev" href="https://laohanlinux.github.io/2015/07/01/muduo-net-library-chapter-2/" />
  <link rel="next" href="https://laohanlinux.github.io/2016/03/13/udon-riak-core/" />
  <link rel="canonical" href="https://laohanlinux.github.io/2015/07/01/muduo-net-library-chapter-3/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           muduo net library chapter 3 | Welcome to Rg Home
       
  </title>
  <meta name="title" content="muduo net library chapter 3 | Welcome to Rg Home">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://laohanlinux.github.io"
    },
    "articleSection" : "posts",
    "name" : "muduo net library chapter 3",
    "headline" : "muduo net library chapter 3",
    "description" : "muduo 是一个linux 网络库，使用poll和epoll模式。 这些内容是本人在大学的时候，通过  &lt;&lt; c&#43;&#43;教程网 &gt;&gt;  所学的知识笔记. 已经过去好几年了，版本也是比较老的了，属于入门级别的教程； 如有错误，纯属正常!!!",
    "inLanguage" : "en-us",
    "author" : "Rg",
    "creator" : "Rg",
    "publisher": "Rg",
    "accountablePerson" : "Rg",
    "copyrightHolder" : "Rg",
    "copyrightYear" : "2015",
    "datePublished": "2015-07-01 00:24:59 &#43;0000 UTC",
    "dateModified" : "2015-07-01 00:24:59 &#43;0000 UTC",
    "url" : "https://laohanlinux.github.io/2015/07/01/muduo-net-library-chapter-3/",
    "wordCount" : "20666",
    "keywords" : [ "muduo", "Welcome to Rg Home"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://laohanlinux.github.io">Welcome to Rg Home</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://laohanlinux.github.io">Welcome to Rg Home</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">muduo net library chapter 3</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://laohanlinux.github.io" rel="author">Rg</a> with ♥ 
                <span class="post-time">
                on <time datetime=2015-07-01 itemprop="datePublished">July 1, 2015</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://laohanlinux.github.io/categories/muduo/"> muduo </a>
                        <a href="https://laohanlinux.github.io/categories/network-program/"> network program </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          

<h2 id="34-tcpserver-tcpconnection">[34] TcpServer/TcpConnection</h2>

<pre><code class="language-c++">Acceptor类的主要功能是socket、bind、listen
般来说，在上层应用程序中，我们不直接使用Acceptor，而是把它作为TcpServer的成员
TcpServer还包含了一个TcpConnection列表
TcpConnection与Acceptor类似，有两个重要的数据成员，Socket与Channel 
</code></pre>

<h3 id="时序图">时序图</h3>

<p><center> <figure><img src="/images/ring.svg" data-sizes="auto" data-src="http://laohanlinux.github.io/images/img/blog/muduo-net-library-chapter-3/tcpserver_tcpconnection.png" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure> </center></p>

<h3 id="tcpserver头文件">TcpServer头文件</h3>

<p>TcpServer.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_TCPSERVER_H
#define MUDUO_NET_TCPSERVER_H
 
#include &lt;muduo/base/Types.h&gt;
#include &lt;muduo/net/TcpConnection.h&gt;
 
#include &lt;map&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class Acceptor;
class EventLoop;
 
///
/// TCP server, supports single-threaded and thread-pool models.
///
/// This is an interface class, so don't expose too much details.
class TcpServer : boost::noncopyable
{
 public:
  //typedef boost::function&lt;void(EventLoop*)&gt; ThreadInitCallback;
 
  //TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);
  TcpServer(EventLoop* loop,
            const InetAddress&amp; listenAddr,
            const string&amp; nameArg);
  ~TcpServer();  // force out-line dtor, for scoped_ptr members.
 
  /*返回服务器的名称*/
  const string&amp; hostport() const { return hostport_; }
  /*返回服务器的监听端口*/
  const string&amp; name() const { return name_; }
 
  /// Starts the server if it's not listenning.
  ///
  /// It's harmless to call it multiple times.
  /// Thread safe.
  void start();
 
  /// Set connection callback.
  /// Not thread safe.
  // 设置连接到来或者连接关闭回调函数
  void setConnectionCallback(const ConnectionCallback&amp; cb)
  { connectionCallback_ = cb; }
 
  /// Set message callback.
  /// Not thread safe.
  // 设置消息到来回调函数
  void setMessageCallback(const MessageCallback&amp; cb)
  { messageCallback_ = cb; }
 
 
 private:
  /// Not thread safe, but in loop
  // Acceptor::handleRead函数中会回调用TcpServer::newConnection
  // _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)
  //应该还在IO线程里面
  // newConnection和connectionCallback_都是连接回调函数，但是connectionCallback_
  // 是给应用程序使用的，newConnection是库函数，不会暴露给用户。
  // 其实就是newConnection函数主要负责注册connectionCallback_ 函数
  void newConnection(int sockfd, const InetAddress&amp; peerAddr);
 
  typedef std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;
 
  EventLoop* loop_;  // the acceptor's loop，不一定是连接所属的eventloop
  const string hostport_;       // 服务端口
  const string name_;           // 服务名
  boost::scoped_ptr&lt;Acceptor&gt; acceptor_; // avoid revealing Acceptor
  /*连接到来的回调函数*/
  ConnectionCallback connectionCallback_;
  /*消息到来的回调函数*/
  MessageCallback messageCallback_;
  bool started_; /*连接是否启动*/
  // always in loop thread
  int nextConnId_;              // 下一个连接ID
  ConnectionMap connections_;   // 连接列表
};
 
}
}
 
#endif  // MUDUO_NET_TCPSERVER_H
</code></pre>

<h3 id="tcpserver源文件">TcpServer源文件</h3>

<p>TcpServer.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
 
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Acceptor.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
//#include &lt;muduo/net/EventLoopThreadPool.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;  // snprintf
 
using namespace muduo;
using namespace muduo::net;
 
TcpServer::TcpServer(EventLoop* loop,
                     const InetAddress&amp; listenAddr,
                     const string&amp; nameArg)
  : loop_(CHECK_NOTNULL(loop)),
    hostport_(listenAddr.toIpPort()),
    name_(nameArg),
    acceptor_(new Acceptor(loop, listenAddr)),
    /*threadPool_(new EventLoopThreadPool(loop)),
    connectionCallback_(defaultConnectionCallback),
    messageCallback_(defaultMessageCallback),*/
    started_(false),
    nextConnId_(1)
{
  // Acceptor::handleRead函数中会回调用TcpServer::newConnection
  // _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)
  acceptor_-&gt;setNewConnectionCallback(
      boost::bind(&amp;TcpServer::newConnection, this, _1, _2));
}
 
TcpServer::~TcpServer()
{
  loop_-&gt;assertInLoopThread();
  LOG_TRACE &lt;&lt; &quot;TcpServer::~TcpServer [&quot; &lt;&lt; name_ &lt;&lt; &quot;] destructing&quot;;
}
 
// 该函数多次调用是无害的
// 该函数可以跨线程调用
void TcpServer::start()
{
  if (!started_)
  {
    started_ = true;
  }
 
  /*如果还没有被执行，那么让他在IO线程中执行listen函数*/
  if (!acceptor_-&gt;listenning())
  {
    // get_pointer返回原生指针
    loop_-&gt;runInLoop(
        boost::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));
  }
}
 
void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)
{
  loop_-&gt;assertInLoopThread();
  char buf[32];
  snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, hostport_.c_str(), nextConnId_);
  ++nextConnId_;
  string connName = name_ + buf;
 
  LOG_INFO &lt;&lt; &quot;TcpServer::newConnection [&quot; &lt;&lt; name_
           &lt;&lt; &quot;] - new connection [&quot; &lt;&lt; connName
           &lt;&lt; &quot;] from &quot; &lt;&lt; peerAddr.toIpPort();
  InetAddress localAddr(sockets::getLocalAddr(sockfd));
  // FIXME poll with zero timeout to double confirm the new connection
  // FIXME use make_shared if necessary
  /*构建一个连接对象*/
  TcpConnectionPtr conn(new TcpConnection(loop_,
                                          connName,
                                          sockfd,
                                          localAddr,
                                          peerAddr));
  connections_[connName] = conn;
  conn-&gt;setConnectionCallback(connectionCallback_);
  conn-&gt;setMessageCallback(messageCallback_);
 
  conn-&gt;connectEstablished();
}
</code></pre>

<h3 id="tcpconnection头文件">TcpConnection头文件</h3>

<p>TcpConnection.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_TCPCONNECTION_H
#define MUDUO_NET_TCPCONNECTION_H
 
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/base/StringPiece.h&gt;
#include &lt;muduo/base/Types.h&gt;
#include &lt;muduo/net/Callbacks.h&gt;
//#include &lt;muduo/net/Buffer.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
//#include &lt;boost/any.hpp&gt;
#include &lt;boost/enable_shared_from_this.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class Channel;
class EventLoop;
class Socket;
 
///
/// TCP connection, for both client and server usage.
///
/// This is an interface class, so don't expose too much details.
class TcpConnection : boost::noncopyable,
                      public boost::enable_shared_from_this&lt;TcpConnection&gt;
{
 public:
  /// Constructs a TcpConnection with a connected sockfd
  ///
  /// User should not create this object.
  TcpConnection(EventLoop* loop,
                const string&amp; name,
                int sockfd,
                const InetAddress&amp; localAddr,
                const InetAddress&amp; peerAddr);
  ~TcpConnection();
 
  EventLoop* getLoop() const { return loop_; }
  const string&amp; name() const { return name_; }
  const InetAddress&amp; localAddress() { return localAddr_; }
  const InetAddress&amp; peerAddress() { return peerAddr_; }
  bool connected() const { return state_ == kConnected; }
 
  void setConnectionCallback(const ConnectionCallback&amp; cb)
  { connectionCallback_ = cb; }
 
  void setMessageCallback(const MessageCallback&amp; cb)
  { messageCallback_ = cb; }
 
  // called when TcpServer accepts a new connection
  void connectEstablished();   // should be called only once
 
 private:
  enum StateE { /*kDisconnected, */kConnecting, kConnected/*, kDisconnecting*/ };
  void handleRead(Timestamp receiveTime);
  void setState(StateE s) { state_ = s; }
 
  EventLoop* loop_;         // 所属EventLoop
  string name_;             // 连接名
  /*连接状态*/
  StateE state_;  // FIXME: use atomic variable
  // we don't expose those classes to client.
  boost::scoped_ptr&lt;Socket&gt; socket_;
  boost::scoped_ptr&lt;Channel&gt; channel_;
  InetAddress localAddr_;
  InetAddress peerAddr_;
  /*连接套接字的回调函数*/
  ConnectionCallback connectionCallback_;
  /*消息被读到应用层后的回调函数*/
  MessageCallback messageCallback_;
};
 
typedef boost::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;
 
}
}
 
#endif  // MUDUO_NET_TCPCONNECTION_H
</code></pre>

<h3 id="tcpconnection源文件">TcpConnection源文件</h3>

<p>TcpConnection.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
 
#include &lt;muduo/net/TcpConnection.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Channel.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/Socket.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
/*
void muduo::net::defaultConnectionCallback(const TcpConnectionPtr&amp; conn)
{
  LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
            &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;
            &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
}
 
void muduo::net::defaultMessageCallback(const TcpConnectionPtr&amp;,
                                        Buffer* buf,
                                        Timestamp)
{
  buf-&gt;retrieveAll();
}
*/
TcpConnection::TcpConnection(EventLoop* loop,
                             const string&amp; nameArg,
                             int sockfd,
                             const InetAddress&amp; localAddr,
                             const InetAddress&amp; peerAddr)
  : loop_(CHECK_NOTNULL(loop)),
    name_(nameArg),
    state_(kConnecting),
    socket_(new Socket(sockfd)),
    channel_(new Channel(loop, sockfd)),
    localAddr_(localAddr),
    peerAddr_(peerAddr)/*,
    highWaterMark_(64*1024*1024)*/
{
  // 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间
  channel_-&gt;setReadCallback(
      boost::bind(&amp;TcpConnection::handleRead, this, _1));
  LOG_DEBUG &lt;&lt; &quot;TcpConnection::ctor[&quot; &lt;&lt;  name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this
            &lt;&lt; &quot; fd=&quot; &lt;&lt; sockfd;
  socket_-&gt;setKeepAlive(true);
}
 
TcpConnection::~TcpConnection()
{
  LOG_DEBUG &lt;&lt; &quot;TcpConnection::dtor[&quot; &lt;&lt;  name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this
            &lt;&lt; &quot; fd=&quot; &lt;&lt; channel_-&gt;fd();
}
 
void TcpConnection::connectEstablished()
{
  //断言在eventloop IO线程中
  loop_-&gt;assertInLoopThread();
  //断言还没有连接
  assert(state_ == kConnecting);
  setState(kConnected);
  channel_-&gt;tie(shared_from_this());
  /*如果连接成功，则关注可读事件*/
  channel_-&gt;enableReading(); // TcpConnection所对应的通道加入到Poller关注
 
  connectionCallback_(shared_from_this());
}
 
void TcpConnection::handleRead(Timestamp receiveTime)
{
  /*
  loop_-&gt;assertInLoopThread();
  int savedErrno = 0;
  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);
  if (n &gt; 0)
  {
    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
  }
  else if (n == 0)
  {
    handleClose();
  }
  else
  {
    errno = savedErrno;
    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
    handleError();
  }
  */
  loop_-&gt;assertInLoopThread();
  char buf[65536];
  ssize_t n = ::read(channel_-&gt;fd(), buf, sizeof buf);
  messageCallback_(shared_from_this(), buf, n);
}
</code></pre>

<h3 id="callback源文件">CallBack源文件</h3>

<p>CallBack.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_CALLBACKS_H
#define MUDUO_NET_CALLBACKS_H
 
#include &lt;boost/function.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
 
#include &lt;muduo/base/Timestamp.h&gt;
 
namespace muduo
{
/*
// Adapted from google-protobuf stubs/common.h
// see License in muduo/base/Types.h
template&lt;typename To, typename From&gt;
inline ::boost::shared_ptr&lt;To&gt; down_pointer_cast(const ::boost::shared_ptr&lt;From&gt;&amp; f) {
  if (false) {
    implicit_cast&lt;From*, To*&gt;(0);
  }
 
#ifndef NDEBUG
  assert(f == NULL || dynamic_cast&lt;To*&gt;(get_pointer(f)) != NULL);
#endif
  return ::boost::static_pointer_cast&lt;To&gt;(f);
}*/
 
namespace net
{
 
// All client visible callbacks go here.
/*
class Buffer;
*/
class TcpConnection;
typedef boost::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;
 
typedef boost::function&lt;void()&gt; TimerCallback;
 
typedef boost::function&lt;void (const TcpConnectionPtr&amp;)&gt; ConnectionCallback;
/*typedef boost::function&lt;void (const TcpConnectionPtr&amp;)&gt; CloseCallback;
typedef boost::function&lt;void (const TcpConnectionPtr&amp;)&gt; WriteCompleteCallback;
typedef boost::function&lt;void (const TcpConnectionPtr&amp;, size_t)&gt; HighWaterMarkCallback;
 
// the data has been read to (buf, len)
typedef boost::function&lt;void (const TcpConnectionPtr&amp;,
                              Buffer*,
                              Timestamp)&gt; MessageCallback;
 
void defaultConnectionCallback(const TcpConnectionPtr&amp; conn);
void defaultMessageCallback(const TcpConnectionPtr&amp; conn,
                            Buffer* buffer,
                            Timestamp receiveTime);
                            */
typedef boost::function&lt;void (const TcpConnectionPtr&amp;,
                              const char* data,
                              ssize_t len)&gt; MessageCallback;
 
}
}
 
#endif  // MUDUO_NET_CALLBACKS_H
</code></pre>

<h3 id="测试程序1">测试程序1</h3>

<pre><code class="language-c++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;stdio.h&gt;
 
/*
 
这个程序主要用来测试TcpServer、TcpConnection
由于这里的TcpServer还没有实现关闭的事件处理，所以当对等放关闭时，服务器会一直处于高电平状态，
也就是说会一直触发
**/
using namespace muduo;
using namespace muduo::net;
 
void onConnection(const TcpConnectionPtr&amp; conn)
{
  if (conn-&gt;connected())
  {
    printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
           conn-&gt;name().c_str(),
           conn-&gt;peerAddress().toIpPort().c_str());
  }
  else
  {
    printf(&quot;onConnection(): connection [%s] is down\n&quot;,
           conn-&gt;name().c_str());
  }
}
 
void onMessage(const TcpConnectionPtr&amp; conn,
               const char* data,
               ssize_t len)
{
  printf(&quot;onMessage(): received %zd bytes from connection [%s]\n&quot;,
         len, conn-&gt;name().c_str());
}
 
int main()
{
  printf(&quot;main(): pid = %d\n&quot;, getpid());
 
  InetAddress listenAddr(8888);
  EventLoop loop;
 
  TcpServer server(&amp;loop, listenAddr, &quot;TestServer&quot;);
  server.setConnectionCallback(onConnection);
  server.setMessageCallback(onMessage);
  server.start();
 
  loop.loop();
}
</code></pre>

<h3 id="程序输出">程序输出:</h3>

<p>客户端</p>

<pre><code class="language-c++">aaahuiahsdui crosoft Telnet Client
 
????????haracter is 'CTRL+]'
sadasd
 
asduhasuidhuiahsdiahsdjksdjfhsdiohahsoidoasudguagsdhjgashjdgajhksd
as
d
a
s
d
sad
 
Microsoft Telnet&gt; quit
 
C:\Users\LaoHan&gt;
</code></pre>

<h3 id="服务器端">服务器端</h3>

<pre><code class="language-c++">^Cubuntu@ubuntu-virtual-machine:~/pro/33/jmuduo$ ../build/debug/bin/reactor_test08
main(): pid = 6066
20131023 01:08:39.593827Z  6066 TRACE updateChannel fd = 4 events = 3 - EPollPoller.cc:104
20131023 01:08:39.594123Z  6066 TRACE EventLoop EventLoop created 0xBFBEBEDC in thread 6066 - EventLoop.cc:62
20131023 01:08:39.594172Z  6066 TRACE updateChannel fd = 5 events = 3 - EPollPoller.cc:104
20131023 01:08:39.594331Z  6066 TRACE updateChannel fd = 6 events = 3 - EPollPoller.cc:104
20131023 01:08:39.594387Z  6066 TRACE loop EventLoop 0xBFBEBEDC start looping - EventLoop.cc:94
20131023 01:08:43.065719Z  6066 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:43.066560Z  6066 TRACE printActiveChannels {6: IN }  - EventLoop.cc:257
20131023 01:08:43.066665Z  6066 INFO  TcpServer::newConnection [TestServer] - new connection [TestServer:0.0.0.0:8888#1] from 172.21.95.221:50007 - TcpServer.cc:74
20131023 01:08:43.066762Z  6066 DEBUG TcpConnection TcpConnection::ctor[TestServer:0.0.0.0:8888#1] at 0x9D80468 fd=8 - TcpConnection.cc:56
20131023 01:08:43.066802Z  6066 TRACE updateChannel fd = 8 events = 3 - EPollPoller.cc:104
onConnection(): new connection [TestServer:0.0.0.0:8888#1] from 172.21.95.221:50007
20131023 01:08:43.845782Z  6066 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:43.845853Z  6066 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 1 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:44.122627Z  6066 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:44.122695Z  6066 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 1 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:44.306479Z  6066 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:44.306545Z  6066 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 1 bytes from connection [TestServer:0.0.0.0:8888#1]
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429136Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429156Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429186Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429205Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429235Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429253Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429283Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429302Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429332Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429351Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429381Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429399Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429447Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429466Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429497Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 01:08:23.429515Z  6063 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257
onMessage(): received 0 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 01:08:23.429545Z  6063 TRACE poll 1 events happended - EPollPoller.cc:65
</code></pre>

<h3 id="测试程序2">测试程序2</h3>

<pre><code class="language-c++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class TestServer
{
 public:
  TestServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
    : loop_(loop),
      server_(loop, listenAddr, &quot;TestServer&quot;)
  {
    server_.setConnectionCallback(
        boost::bind(&amp;TestServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;TestServer::onMessage, this, _1, _2, _3));
  }
 
  void start()
  {
      server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    if (conn-&gt;connected())
    {
      printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
             conn-&gt;name().c_str(),
             conn-&gt;peerAddress().toIpPort().c_str());
    }
    else
    {
      printf(&quot;onConnection(): connection [%s] is down\n&quot;,
             conn-&gt;name().c_str());
    }
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn,
                   const char* data,
                   ssize_t len)
  {
    printf(&quot;onMessage(): received %zd bytes from connection [%s]\n&quot;,
           len, conn-&gt;name().c_str());
  }
 
  EventLoop* loop_;
  TcpServer server_;
};
int main()
{
  printf(&quot;main(): pid = %d\n&quot;, getpid());
 
  InetAddress listenAddr(8888);
  EventLoop loop;
 
  TestServer server(&amp;loop, listenAddr);
  server.start();
 
  loop.loop();
}
</code></pre>

<h2 id="35-1-multiple-reactors">[35-1] multiple reactors</h2>

<p><center> <figure><img src="/images/ring.svg" data-sizes="auto" data-src="http://laohanlinux.github.io/images/img/blog/muduo-base-library-2/multipilereactors.png" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure> </center></p>

<ul>
<li><code>muduo</code>库如何支持多线程</li>
<li><code>EventLoopThread</code>（<code>IO</code>线程类）</li>
<li><code>EventLoopThreadPool</code>（<code>IO</code>线程池类）</li>
<li><code>IO</code>线程池的功能是开启若干个<code>IO</code>线程，并让这些<code>IO</code>线程处于事件循环的状态</li>
</ul>

<p>下面的这些代码可能和前面给出的源代码有些不一样，阅读的同学请注意了</p>

<h3 id="eventloopthreadpool-头文件"><code>EventLoopThreadPool</code>头文件</h3>

<p>eventloopthreadpool.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is an internal header file, you should not include this.
 
#ifndef MUDUO_NET_EVENTLOOPTHREADPOOL_H
#define MUDUO_NET_EVENTLOOPTHREADPOOL_H
 
#include &lt;muduo/base/Condition.h&gt;
#include &lt;muduo/base/Mutex.h&gt;
 
#include &lt;vector&gt;
#include &lt;boost/function.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/ptr_container/ptr_vector.hpp&gt;
 
namespace muduo
{
 
namespace net
{
 
class EventLoop;
class EventLoopThread;
 
class EventLoopThreadPool : boost::noncopyable
{
 public:
  typedef boost::function&lt;void(EventLoop*)&gt; ThreadInitCallback;
 
  EventLoopThreadPool(EventLoop* baseLoop);
  ~EventLoopThreadPool();
  void setThreadNum(int numThreads) { numThreads_ = numThreads; }
  void start(const ThreadInitCallback&amp; cb = ThreadInitCallback());
  EventLoop* getNextLoop();
 
 private:
 
  EventLoop* baseLoop_; // 与Acceptor所属EventLoop相同
  bool started_;        /*是否启动*/
  int numThreads_;      // 线程数
  int next_;            // 新连接到来，所选择的EventLoop对象下标
  boost::ptr_vector&lt;EventLoopThread&gt; threads_;        // IO线程列表
  std::vector&lt;EventLoop*&gt; loops_;                 // EventLoop列表
};
 
}
}
 
#endif  // MUDUO_NET_EVENTLOOPTHREADPOOL_H
</code></pre>

<h3 id="eventloopthreadpool源文件">EventLoopThreadPool源文件</h3>

<p>eventloopthreadpool.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
 
#include &lt;muduo/net/EventLoopThreadPool.h&gt;
 
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/EventLoopThread.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
using namespace muduo;
using namespace muduo::net;
 
 
EventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop)
  : baseLoop_(baseLoop),  // 与Acceptor所属EventLoop相同
    started_(false),
    numThreads_(0),
    next_(0)
{
}
 
EventLoopThreadPool::~EventLoopThreadPool()
{
  // Don't delete loop, it's stack variable
}
/*每个线程初始化时的回调函数cb*/
void EventLoopThreadPool::start(const ThreadInitCallback&amp; cb)
{
  assert(!started_);
  baseLoop_-&gt;assertInLoopThread();
 
  started_ = true;
 
  for (int i = 0; i &lt; numThreads_; ++i)
  {
    EventLoopThread* t = new EventLoopThread(cb);
    threads_.push_back(t);
    loops_.push_back(t-&gt;startLoop());    // 启动EventLoopThread线程，在进入事件循环之前，会调用cb
  }
  if (numThreads_ == 0 &amp;&amp; cb)
  {
    // 只有一个EventLoop，在这个EventLoop进入事件循环之前，调用cb
    cb(baseLoop_);
  }
}
 
EventLoop* EventLoopThreadPool::getNextLoop()
{
  baseLoop_-&gt;assertInLoopThread();
  EventLoop* loop = baseLoop_;
 
  // 如果loops_为空，则loop指向baseLoop_
  // 如果不为空，按照round-robin（RR，轮叫）的调度方式选择一个EventLoop
  if (!loops_.empty())
  {
    // round-robin
    loop = loops_[next_];
    ++next_;
    if (implicit_cast&lt;size_t&gt;(next_) &gt;= loops_.size())
    {
      next_ = 0;
    }
  }
  return loop;
}
</code></pre>

<h3 id="tcpserver头文件-1">TcpServer头文件</h3>

<p>TcpServer.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_TCPSERVER_H
#define MUDUO_NET_TCPSERVER_H
 
#include &lt;muduo/base/Types.h&gt;
#include &lt;muduo/net/TcpConnection.h&gt;
 
#include &lt;map&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class Acceptor;
class EventLoop;
class EventLoopThreadPool;
 
///
/// TCP server, supports single-threaded and thread-pool models.
///
/// This is an interface class, so don't expose too much details.
class TcpServer : boost::noncopyable
{
 public:
  typedef boost::function&lt;void(EventLoop*)&gt; ThreadInitCallback;
 
  //TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);
  TcpServer(EventLoop* loop,
            const InetAddress&amp; listenAddr,
            const string&amp; nameArg);
  ~TcpServer();  // force out-line dtor, for scoped_ptr members.
 
  const string&amp; hostport() const { return hostport_; }
  const string&amp; name() const { return name_; }
 
  /// Set the number of threads for handling input.
  ///
  /// Always accepts new connection in loop's thread.
  /// Must be called before @c start
  /// @param numThreads
  /// - 0 means all I/O in loop's thread, no thread will created.
  ///   this is the default value.
  /// - 1 means all I/O in another thread.
  /// - N means a thread pool with N threads, new connections
  ///   are assigned on a round-robin basis.
  void setThreadNum(int numThreads);
  void setThreadInitCallback(const ThreadInitCallback&amp; cb)
  { threadInitCallback_ = cb; }
 
  /// Starts the server if it's not listenning.
  ///
  /// It's harmless to call it multiple times.
  /// Thread safe.
  void start();
 
  /// Set connection callback.
  /// Not thread safe.
  // 设置连接到来或者连接关闭回调函数
  void setConnectionCallback(const ConnectionCallback&amp; cb)
  { connectionCallback_ = cb; }
 
  /// Set message callback.
  /// Not thread safe.
  // 设置消息到来回调函数
  void setMessageCallback(const MessageCallback&amp; cb)
  { messageCallback_ = cb; }
 
 
 private:
  /// Not thread safe, but in loop
  void newConnection(int sockfd, const InetAddress&amp; peerAddr);
  /// Thread safe.
  void removeConnection(const TcpConnectionPtr&amp; conn);
  /// Not thread safe, but in loop
  void removeConnectionInLoop(const TcpConnectionPtr&amp; conn);
 
  typedef std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;
 
  EventLoop* loop_;  // the acceptor loop
  const string hostport_;       // 服务端口
  const string name_;           // 服务名
  boost::scoped_ptr&lt;Acceptor&gt; acceptor_; // avoid revealing Acceptor
  boost::scoped_ptr&lt;EventLoopThreadPool&gt; threadPool_; //线程池
  ConnectionCallback connectionCallback_;
  MessageCallback messageCallback_;
  ThreadInitCallback threadInitCallback_;   // IO线程池中的线程在进入事件循环前，会回调用此函数
  bool started_;
  // always in loop thread
  int nextConnId_;              // 下一个连接ID
  ConnectionMap connections_;   // 连接列表
};
 
}
}
 
#endif  // MUDUO_NET_TCPSERVER_H
</code></pre>

<h3 id="tcpserver源文件-1">TcpServer源文件</h3>

<p>TcpServer.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
 
#include &lt;muduo/net/TcpServer.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Acceptor.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/EventLoopThreadPool.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;  // snprintf
 
using namespace muduo;
using namespace muduo::net;
 
TcpServer::TcpServer(EventLoop* loop, /*这是main reactor*/
                     const InetAddress&amp; listenAddr,
                     const string&amp; nameArg)
  : loop_(CHECK_NOTNULL(loop)),
    hostport_(listenAddr.toIpPort()),
    name_(nameArg),
    acceptor_(new Acceptor(loop, listenAddr)),
    threadPool_(new EventLoopThreadPool(loop)),
    /*connectionCallback_(defaultConnectionCallback),
    messageCallback_(defaultMessageCallback),*/
    started_(false),
    nextConnId_(1)
{
  // Acceptor::handleRead函数中会回调用TcpServer::newConnection
  // _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)
  acceptor_-&gt;setNewConnectionCallback(
      boost::bind(&amp;TcpServer::newConnection, this, _1, _2));
}
 
TcpServer::~TcpServer()
{
  loop_-&gt;assertInLoopThread();
  LOG_TRACE &lt;&lt; &quot;TcpServer::~TcpServer [&quot; &lt;&lt; name_ &lt;&lt; &quot;] destructing&quot;;
 
  for (ConnectionMap::iterator it(connections_.begin());
      it != connections_.end(); ++it)
  {
    TcpConnectionPtr conn = it-&gt;second;
    it-&gt;second.reset();      // 释放当前所控制的对象，引用计数减一
    conn-&gt;getLoop()-&gt;runInLoop(
      boost::bind(&amp;TcpConnection::connectDestroyed, conn));
    conn.reset();           // 释放当前所控制的对象，引用计数减一
  }
}
 
void TcpServer::setThreadNum(int numThreads)
{
  /*numThreads不包含main reactor thread*/
  assert(0 &lt;= numThreads);
  threadPool_-&gt;setThreadNum(numThreads);
}
 
// 该函数多次调用是无害的
// 该函数可以跨线程调用
void TcpServer::start()
{
  if (!started_)
  {
    started_ = true;
    /*启动线程池*/
    threadPool_-&gt;start(threadInitCallback_);
  }
 
  if (!acceptor_-&gt;listenning())
  {
    // get_pointer返回原生指针
    loop_-&gt;runInLoop(
        boost::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));
  }
}
 
void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)
{
  loop_-&gt;assertInLoopThread();
  // 按照轮叫的方式选择一个EventLoop
  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();
  char buf[32];
  snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, hostport_.c_str(), nextConnId_);
  ++nextConnId_;
  string connName = name_ + buf;
 
  LOG_INFO &lt;&lt; &quot;TcpServer::newConnection [&quot; &lt;&lt; name_
           &lt;&lt; &quot;] - new connection [&quot; &lt;&lt; connName
           &lt;&lt; &quot;] from &quot; &lt;&lt; peerAddr.toIpPort();
  InetAddress localAddr(sockets::getLocalAddr(sockfd));
  // FIXME poll with zero timeout to double confirm the new connection
  // FIXME use make_shared if necessary
  /*TcpConnectionPtr conn(new TcpConnection(loop_,
                                          connName,
                                          sockfd,
                                          localAddr,
                                          peerAddr));*/
 
  TcpConnectionPtr conn(new TcpConnection(ioLoop,
                                          connName,
                                          sockfd,
                                          localAddr,
                                          peerAddr));
 
  LOG_TRACE &lt;&lt; &quot;[1] usecount=&quot; &lt;&lt; conn.use_count();
  connections_[connName] = conn;
  LOG_TRACE &lt;&lt; &quot;[2] usecount=&quot; &lt;&lt; conn.use_count();
  conn-&gt;setConnectionCallback(connectionCallback_);
  conn-&gt;setMessageCallback(messageCallback_);
 
  conn-&gt;setCloseCallback(
      boost::bind(&amp;TcpServer::removeConnection, this, _1));
 
  // conn-&gt;connectEstablished(); 这个表示直接在当前线程中调用
  ioLoop-&gt;runInLoop(boost::bind(&amp;TcpConnection::connectEstablished, conn));
  LOG_TRACE &lt;&lt; &quot;[5] usecount=&quot; &lt;&lt; conn.use_count();
 
}
 
void TcpServer::removeConnection(const TcpConnectionPtr&amp; conn)
{
    /*
  loop_-&gt;assertInLoopThread();
  LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_
           &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();
 
 
  LOG_TRACE &lt;&lt; &quot;[8] usecount=&quot; &lt;&lt; conn.use_count();
  size_t n = connections_.erase(conn-&gt;name());
  LOG_TRACE &lt;&lt; &quot;[9] usecount=&quot; &lt;&lt; conn.use_count();
 
  (void)n;
  assert(n == 1);
 
  loop_-&gt;queueInLoop(
      boost::bind(&amp;TcpConnection::connectDestroyed, conn));
  LOG_TRACE &lt;&lt; &quot;[10] usecount=&quot; &lt;&lt; conn.use_count();
  */
 
  loop_-&gt;runInLoop(boost::bind(&amp;TcpServer::removeConnectionInLoop, this, conn));
 
}
 
void TcpServer::removeConnectionInLoop(const TcpConnectionPtr&amp; conn)
{
  loop_-&gt;assertInLoopThread();
  LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_
           &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();
 
 
  LOG_TRACE &lt;&lt; &quot;[8] usecount=&quot; &lt;&lt; conn.use_count();
  size_t n = connections_.erase(conn-&gt;name());
  LOG_TRACE &lt;&lt; &quot;[9] usecount=&quot; &lt;&lt; conn.use_count();
 
  (void)n;
  assert(n == 1);
 
  EventLoop* ioLoop = conn-&gt;getLoop();
  ioLoop-&gt;queueInLoop(
      boost::bind(&amp;TcpConnection::connectDestroyed, conn));
 
  //loop_-&gt;queueInLoop(
  //    boost::bind(&amp;TcpConnection::connectDestroyed, conn));
  LOG_TRACE &lt;&lt; &quot;[10] usecount=&quot; &lt;&lt; conn.use_count(); 
}
</code></pre>

<h3 id="测试程序">测试程序</h3>

<pre><code class="language-c++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class TestServer
{
 public:
  TestServer(EventLoop* loop,
             const InetAddress&amp; listenAddr, int numThreads)
    : loop_(loop),
      server_(loop, listenAddr, &quot;TestServer&quot;),
      numThreads_(numThreads)
  {
    server_.setConnectionCallback(
        boost::bind(&amp;TestServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;TestServer::onMessage, this, _1, _2, _3));
    server_.setThreadNum(numThreads);
  }
 
  void start()
  {
      server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    if (conn-&gt;connected())
    {
      printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
             conn-&gt;name().c_str(),
             conn-&gt;peerAddress().toIpPort().c_str());
    }
    else
    {
      printf(&quot;onConnection(): connection [%s] is down\n&quot;,
             conn-&gt;name().c_str());
    }
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn,
                   const char* data,
                   ssize_t len)
  {
    printf(&quot;onMessage(): received %zd bytes from connection [%s]\n&quot;,
           len, conn-&gt;name().c_str());
  }
 
  EventLoop* loop_;
  TcpServer server_;
  int numThreads_;
};
 
 
int main()
{
  printf(&quot;main(): pid = %d\n&quot;, getpid());
 
  InetAddress listenAddr(8888);
  EventLoop loop;
 
  TestServer server(&amp;loop, listenAddr,4);
  server.start();
 
  loop.loop();
}

   return n;
}
</code></pre>

<h2 id="35-2-文件描述符的分析">[35-2] 文件描述符的分析</h2>

<h3 id="code">code</h3>

<pre><code class="language-c++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class TestServer
{
 public:
  TestServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
    : loop_(loop),
      server_(loop, listenAddr, &quot;TestServer&quot;)
  {
    server_.setConnectionCallback(
        boost::bind(&amp;TestServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;TestServer::onMessage, this, _1, _2, _3));
  }
 
  void start()
  {
      server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    if (conn-&gt;connected())
    {
      printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
             conn-&gt;name().c_str(),
             conn-&gt;peerAddress().toIpPort().c_str());
    }
    else
    {
      printf(&quot;onConnection(): connection [%s] is down\n&quot;,
             conn-&gt;name().c_str());
    }
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn,
                   const char* data,
                   ssize_t len)
  {
    printf(&quot;onMessage(): received %zd bytes from connection [%s]\n&quot;,
           len, conn-&gt;name().c_str());
  }
 
  EventLoop* loop_;
  TcpServer server_;
};
 
 
int main()
{
  printf(&quot;main(): pid = %d\n&quot;, getpid());
 
  InetAddress listenAddr(8888);
  EventLoop loop;
 
  TestServer server(&amp;loop, listenAddr);
  server.start();
 
  loop.loop();
}
</code></pre>

<h3 id="分析结果">分析结果</h3>

<pre><code class="language-c++">0 ， 1  ，2 进程默认打开
3 EpollerFd
4 timerFd
5 wakeupFd
6 listenFd
7 idleFd
 
ubuntu@ubuntu-virtual-machine:~/pro/35$ ./build/debug/bin/reactor_test09
main(): pid = 10797
20131023 08:05:04.423104Z 10797 TRACE updateChannel fd = 4 events = 3 - EPollPoller.cc:104
20131023 08:05:04.423413Z 10797 TRACE EventLoop EventLoop created 0xBF97AAB4 in thread 10797 - EventLoop.cc:62
20131023 08:05:04.423489Z 10797 TRACE updateChannel fd = 5 events = 3 - EPollPoller.cc:104
20131023 08:05:04.423883Z 10797 TRACE updateChannel fd = 6 events = 3 - EPollPoller.cc:104
20131023 08:05:04.423968Z 10797 TRACE loop EventLoop 0xBF97AAB4 start looping - EventLoop.cc:94
20131023 08:05:13.376959Z 10797 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 08:05:13.377558Z 10797 TRACE printActiveChannels {6: IN }  - EventLoop.cc:257-----》》有连接到来
20131023 08:05:13.377681Z 10797 INFO  TcpServer::newConnection [TestServer] - new connection [TestServer:0.0.0.0:8888#1] from 127.0.0.1:57756 - TcpServer.cc:93
20131023 08:05:13.377719Z 10797 DEBUG TcpConnection TcpConnection::ctor[TestServer:0.0.0.0:8888#1] at 0x8BB3490 fd=8 - TcpConnection.cc:62-------》》已连接的套接字
20131023 08:05:13.377746Z 10797 TRACE newConnection [1] usecount=1 - TcpServer.cc:111
20131023 08:05:13.377772Z 10797 TRACE newConnection [2] usecount=2 - TcpServer.cc:113
20131023 08:05:13.377819Z 10797 TRACE connectEstablished [3] usecount=6 - TcpConnection.cc:78
20131023 08:05:13.377846Z 10797 TRACE updateChannel fd = 8 events = 3 - EPollPoller.cc:104
onConnection(): new connection [TestServer:0.0.0.0:8888#1] from 127.0.0.1:57756
20131023 08:05:13.377902Z 10797 TRACE connectEstablished [4] usecount=6 - TcpConnection.cc:83
20131023 08:05:13.377915Z 10797 TRACE newConnection [5] usecount=2 - TcpServer.cc:122
20131023 08:05:23.388224Z 10797 TRACE poll  nothing happended - EPollPoller.cc:74
20131023 08:05:32.910851Z 10797 TRACE poll 1 events happended - EPollPoller.cc:65
20131023 08:05:32.910969Z 10797 TRACE printActiveChannels {8: IN }  - EventLoop.cc:257-----&gt;&gt;已连接的套接字有可读事件
20131023 08:05:32.910990Z 10797 TRACE handleEvent [6] usecount=2 - Channel.cc:67
onMessage(): received 5 bytes from connection [TestServer:0.0.0.0:8888#1]
20131023 08:05:32.911066Z 10797 TRACE handleEvent [12] usecount=2 - Channel.cc:69
</code></pre>

<h2 id="36-1-buffer">[36-1] BUFFER</h2>

<pre><code class="language-c++">1. 应用层缓冲区`Buffer`设计
2. 为什么需要有应用层缓冲区（详见`MuduoManual.pdf  P76`）
3. `Buffer`结构
4. `epoll`使用`LT`模式的原因
5. 与`poll`兼容
6. `LT`模式不会发生漏掉事件的`BUG`，但`POLLOUT`事件不能一开始就关注，否则会出现`busy loop`，而应该在`write`无法完全写入内核缓冲区的时候才关注，将未写入内核缓冲区的数据添加到应用层`output buffer`，直到应用层`output buffer`写完，停止关注`POLLOUT`事件。读写的时候不必等候`EAGAIN`，可以节省系统调用次数，降低延迟。（注：如果用`ET`模式，读的时候读到`EAGAIN`,写的时候直到`output buffer`写完或者`EAGAIN`）
</code></pre>

<h3 id="buffer头文件">BUFFER头文件</h3>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
/*
接收到数据，存至input buffer，通知上层的应用程序，OnMessage(Buffer *buf)回调，根据应用层协议
判断是否一个完整的包，codec，如果不是一条完整的消息，不会取走数据，也不会进行相应的处理，
如果是一条完整的信息，将取走这条信息，并进行相应的处理
 
对方发送了两条消息，50,350
接收方第一次接收了200，第二次接收了200
 
从socket读了 200 个字节，写到buffer中
从buffer中取回50 个字节
又从socket读了200个字节，写到buffer中
从buffer中取回350个字节，写到buffer中
从buffer中取回350个字节
 
*/
#ifndef MUDUO_NET_BUFFER_H
#define MUDUO_NET_BUFFER_H
 
#include &lt;muduo/base/copyable.h&gt;
#include &lt;muduo/base/StringPiece.h&gt;
#include &lt;muduo/base/Types.h&gt;
 
#include &lt;muduo/net/Endian.h&gt;
 
#include &lt;algorithm&gt;
#include &lt;vector&gt;
 
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
//#include &lt;unistd.h&gt;  // ssize_t
 
namespace muduo
{
namespace net
{
 
/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer
///
/// @code
/// +-------------------+------------------+------------------+
/// | prependable bytes |  readable bytes  |  writable bytes  |
/// |                   |     (CONTENT)    |                  |
/// +-------------------+------------------+------------------+
/// |                   |                  |                  |
/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size
/// @endcode
class Buffer : public muduo::copyable
{
 public:
  static const size_t kCheapPrepend = 8;
  static const size_t kInitialSize = 1024;
 
  Buffer()
  /*缓冲区的大小*/
    : buffer_(kCheapPrepend + kInitialSize),
    /*可读的开始位置*/
      readerIndex_(kCheapPrepend),
    /*可写的开始位置*/
      writerIndex_(kCheapPrepend)
  {
    assert(readableBytes() == 0);
    assert(writableBytes() == kInitialSize);
    assert(prependableBytes() == kCheapPrepend);
  }
 
  // default copy-ctor(拷贝构造函数), dtor and assignment are fine
 
  void swap(Buffer&amp; rhs)
  {
    buffer_.swap(rhs.buffer_);
    std::swap(readerIndex_, rhs.readerIndex_);
    std::swap(writerIndex_, rhs.writerIndex_);
  }
    /*可读的字节数*/
  size_t readableBytes() const
  { return writerIndex_ - readerIndex_; }
    /*可写的字节数*/
  size_t writableBytes() const
  { return buffer_.size() - writerIndex_; }
    /*可预留的空间*/
  size_t prependableBytes() const
  { return readerIndex_; }
    /*可读位置指针*/
  const char* peek() const
  { return begin() + readerIndex_; }
 
  const char* findCRLF() const
  {
    const char* crlf = std::search(peek(), beginWrite(), kCRLF, kCRLF+2);
    return crlf == beginWrite() ? NULL : crlf;
  }
 
  const char* findCRLF(const char* start) const
  {
    assert(peek() &lt;= start);
    assert(start &lt;= beginWrite());
    const char* crlf = std::search(start, beginWrite(), kCRLF, kCRLF+2);
    return crlf == beginWrite() ? NULL : crlf;
  }
 
  // retrieve returns void, to prevent
  // string str(retrieve(readableBytes()), readableBytes());
  // the evaluation of two functions are unspecified
  /*取回数据*/
  void retrieve(size_t len)
  {
    assert(len &lt;= readableBytes());
    if (len &lt; readableBytes())
    {
      readerIndex_ += len;
    }
    else
    {
      retrieveAll();
    }
  }
  /*取回到指定位置的数据*/
  void retrieveUntil(const char* end)
  {
    assert(peek() &lt;= end);
    assert(end &lt;= beginWrite());
    retrieve(end - peek());
  }
  /*取回一个整数*/
  void retrieveInt32()
  {
    retrieve(sizeof(int32_t));
  }
  /*取回两个字节*/
  void retrieveInt16()
  {
    retrieve(sizeof(int16_t));
  }
  /*取回一个字节*/
  void retrieveInt8()
  {
    retrieve(sizeof(int8_t));
  }
  /*取回全部数据*/
  void retrieveAll()
  {
    readerIndex_ = kCheapPrepend;
    writerIndex_ = kCheapPrepend;
  }
 
  string retrieveAllAsString()
  {
    return retrieveAsString(readableBytes());;
  }
 
  string retrieveAsString(size_t len)
  {
    assert(len &lt;= readableBytes());
    string result(peek(), len);
    retrieve(len);
    return result;
  }
 
  StringPiece toStringPiece() const
  {
    return StringPiece(peek(), static_cast&lt;int&gt;(readableBytes()));
  }
  /*追加数据*/
  void append(const StringPiece&amp; str)
  {
    append(str.data(), str.size());
  }
 
  void append(const char* /*restrict*/ data, size_t len)
  {
    ensureWritableBytes(len);
    std::copy(data, data+len, beginWrite());
    hasWritten(len);
  }
 
  void append(const void* /*restrict*/ data, size_t len)
  {
    append(static_cast&lt;const char*&gt;(data), len);
  }
 
  // 确保缓冲区可写空间&gt;=len，如果不足则扩充
  void ensureWritableBytes(size_t len)
  {
    if (writableBytes() &lt; len)
    {
      makeSpace(len);
    }
    assert(writableBytes() &gt;= len);
  }
  /*可写位置的指针*/
  char* beginWrite()
  { return begin() + writerIndex_; }
 
  const char* beginWrite() const
  { return begin() + writerIndex_; }
 
  void hasWritten(size_t len)
  { writerIndex_ += len; }
 
  ///
  /// Append int32_t using network endian
  /// 使用网络字节序追加到buffer
  void appendInt32(int32_t x)
  {
    int32_t be32 = sockets::hostToNetwork32(x);
    append(&amp;be32, sizeof be32);
  }
 
  void appendInt16(int16_t x)
  {
    int16_t be16 = sockets::hostToNetwork16(x);
    append(&amp;be16, sizeof be16);
  }
 
  void appendInt8(int8_t x)
  {
    append(&amp;x, sizeof x);
  }
 
  ///
  /// Read int32_t from network endian
  ///
  /// Require: buf-&gt;readableBytes() &gt;= sizeof(int32_t)
  int32_t readInt32()
  {
    int32_t result = peekInt32();
    retrieveInt32();
    return result;
  }
 
  int16_t readInt16()
  {
    int16_t result = peekInt16();
    retrieveInt16();
    return result;
  }
 
  int8_t readInt8()
  {
    int8_t result = peekInt8();
    retrieveInt8();
    return result;
  }
 
  ///
  /// Peek int32_t from network endian
  ///
  /// Require: buf-&gt;readableBytes() &gt;= sizeof(int32_t)
  int32_t peekInt32() const
  {
    assert(readableBytes() &gt;= sizeof(int32_t));
    int32_t be32 = 0;
    ::memcpy(&amp;be32, peek(), sizeof be32);
    return sockets::networkToHost32(be32);
  }
 
  int16_t peekInt16() const
  {
    assert(readableBytes() &gt;= sizeof(int16_t));
    int16_t be16 = 0;
    ::memcpy(&amp;be16, peek(), sizeof be16);
    return sockets::networkToHost16(be16);
  }
 
  int8_t peekInt8() const
  {
    assert(readableBytes() &gt;= sizeof(int8_t));
    int8_t x = *peek();
    return x;
  }
 
  ///
  /// Prepend int32_t using network endian
  ///
  void prependInt32(int32_t x)
  {
    int32_t be32 = sockets::hostToNetwork32(x);
    prepend(&amp;be32, sizeof be32);
  }
 
  void prependInt16(int16_t x)
  {
    int16_t be16 = sockets::hostToNetwork16(x);
    prepend(&amp;be16, sizeof be16);
  }
 
  void prependInt8(int8_t x)
  {
    prepend(&amp;x, sizeof x);
  }
 
  void prepend(const void* /*restrict*/ data, size_t len)
  {
    assert(len &lt;= prependableBytes());
    readerIndex_ -= len;
    const char* d = static_cast&lt;const char*&gt;(data);
    std::copy(d, d+len, begin()+readerIndex_);
  }
 
  // 收缩，保留reserve个字节
  void shrink(size_t reserve)
  {
    // FIXME: use vector::shrink_to_fit() in C++ 11 if possible.
    Buffer other;
    other.ensureWritableBytes(readableBytes()+reserve);
    other.append(toStringPiece());
    swap(other);
  }
 
  /// Read data directly into buffer.
  ///
  /// It may implement with readv(2)
  /// @return result of read(2), @c errno is saved
  ssize_t readFd(int fd, int* savedErrno);
 
 private:
 
  char* begin()
  { return &amp;*buffer_.begin(); }
 
  const char* begin() const
  { return &amp;*buffer_.begin(); }
 
  void makeSpace(size_t len)
  {
    if (writableBytes() + prependableBytes() &lt; len + kCheapPrepend)
    {
      // FIXME: move readable data
      buffer_.resize(writerIndex_+len);
    }
    else
    {
      // move readable data to the front, make space inside buffer
      assert(kCheapPrepend &lt; readerIndex_);
      size_t readable = readableBytes();
      std::copy(begin()+readerIndex_,
                begin()+writerIndex_,
                begin()+kCheapPrepend);
      readerIndex_ = kCheapPrepend;
      writerIndex_ = readerIndex_ + readable;
      assert(readable == readableBytes());
    }
  }
 
 private:
  std::vector&lt;char&gt; buffer_;  // vector用于替代固定大小数组
  size_t readerIndex_;          // 读位置
  size_t writerIndex_;          // 写位置
 
  static const char kCRLF[];    // &quot;\r\n&quot;
};
 
}
}
#endif  // MUDUO_NET_BUFFER_H
</code></pre>

<h3 id="buffer源文件">BUFFER源文件</h3>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
#include &lt;muduo/net/Buffer.h&gt;
 
#include &lt;muduo/net/SocketsOps.h&gt;
 
#include &lt;errno.h&gt;
#include &lt;sys/uio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
const char Buffer::kCRLF[] = &quot;\r\n&quot;;
 
const size_t Buffer::kCheapPrepend;
const size_t Buffer::kInitialSize;
 
// 结合栈上的空间，避免内存使用过大，提高内存使用率
// 如果有5K个连接，每个连接就分配64K+64K的缓冲区的话，将占用640M内存，
// 而大多数时候，这些缓冲区的使用率很低
ssize_t Buffer::readFd(int fd, int* savedErrno)
{
  // saved an ioctl()/FIONREAD call to tell how much to read
  // 节省一次ioctl系统调用（获取有多少可读数据）
  char extrabuf[65536];
  struct iovec vec[2];
  const size_t writable = writableBytes();
  // 第一块缓冲区
  vec[0].iov_base = begin()+writerIndex_;
  vec[0].iov_len = writable;
  // 第二块缓冲区
  vec[1].iov_base = extrabuf;
  vec[1].iov_len = sizeof extrabuf;
  const ssize_t n = sockets::readv(fd, vec, 2);
  if (n &lt; 0)
  {
    *savedErrno = errno;
  }
  else if (implicit_cast&lt;size_t&gt;(n) &lt;= writable)   //第一块缓冲区足够容纳
  {
    writerIndex_ += n;
  }
  else      // 当前缓冲区，不够容纳，因而数据被接收到了第二块缓冲区extrabuf，将其append至buffer
  {
    writerIndex_ = buffer_.size();
    append(extrabuf, n - writable);
  }
  // if (n == writable + sizeof extrabuf)
  // {
  //   goto line_30;
  // }
  return n;
}
</code></pre>

<h2 id="37-buffer">[37] BUFFER</h2>

<pre><code class="language-c++">应用程序想关闭连接，但是可能正处于发送数据的过程中，output buffer中有数据还没有发送完,不能直接调用`close`, `conn-&gt;send(buff)`==&gt;`conn-&gt;shutdown()`==&gt;`POLLOUT`事件.
关闭写的这一半: 连接状态更改为`kDisconnection`，并没有关闭连接
服务器主动断开与客户端的连接, 这意味着 客户端 `read`返回`0`, `close(conn)` ==&gt; `POLLHUP|POLLIN`
如果是客户端主动关闭连接，那么服务器端只返回`POLLIN`,如果是服务器端主动关闭，然后客户端再关闭，那么服务器端返回`POLLIN`和`POLLHUP`事件
</code></pre>

<h3 id="测试程序-1">测试程序</h3>

<p>服务器</p>

<pre><code class="language-c++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class TestServer
{
 public:
  TestServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
    : loop_(loop),
      server_(loop, listenAddr, &quot;TestServer&quot;)
  {
    server_.setConnectionCallback(
        boost::bind(&amp;TestServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;TestServer::onMessage, this, _1, _2, _3));
 
    message1_.resize(100);
    message2_.resize(200);
    std::fill(message1_.begin(), message1_.end(), 'A');
    std::fill(message2_.begin(), message2_.end(), 'B');
  }
 
  void start()
  {
      server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    if (conn-&gt;connected())
    {
      printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
             conn-&gt;name().c_str(),
             conn-&gt;peerAddress().toIpPort().c_str());
      conn-&gt;send(message1_);
      conn-&gt;send(message2_);
      conn-&gt;shutdown();
    }
    else
    {
      printf(&quot;onConnection(): connection [%s] is down\n&quot;,
             conn-&gt;name().c_str());
    }
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn,
                 Buffer* buf,
                 Timestamp receiveTime)
  {
    muduo::string msg(buf-&gt;retrieveAllAsString());
    printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,
           msg.size(),
           conn-&gt;name().c_str(),
           receiveTime.toFormattedString().c_str());
 
    conn-&gt;send(msg);
  }
 
  EventLoop* loop_;
  TcpServer server_;
 
  muduo::string message1_;
  muduo::string message2_;
};
 
 
int main()
{
  printf(&quot;main(): pid = %d\n&quot;, getpid());
 
  InetAddress listenAddr(8888);
  EventLoop loop;
 
  TestServer server(&amp;loop, listenAddr);
  server.start();
 
  loop.loop();
}
</code></pre>

<h3 id="客户端">客户端</h3>

<pre><code class="language-c++">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
 
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
 //该程序可能出现粘包问题
#define ERR_EXIT(m) \
        do \
        { \
                perror(m); \
                exit(EXIT_FAILURE); \
        } while(0)
 
int main(void)
{
    int sock;
    if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0)
        ERR_EXIT(&quot;socket&quot;);
 
    struct sockaddr_in servaddr;
    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(8888);
    servaddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
 
    if (connect(sock, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0)
        ERR_EXIT(&quot;connect&quot;);
 
    char buf[1024] ={0};
    while (1)
    {
        int ret = read(sock, buf, sizeof(buf));
        printf(&quot;ret=%d\n&quot;, ret);
        if (ret == 0)
            break;
 
        fputs(buf, stdout);
        fflush(stdout);
        memset(buf, 0, sizeof(buf));
    }
 
    sleep(10);
    close(sock);
 
    return 0;
}

</code></pre>

<h3 id="程序输出-1">程序输出</h3>

<p>服务器：</p>

<pre><code class="language-c++">ubuntu@ubuntu-virtual-machine:~/pro/37$ ./build/debug/bin/reactor_test12
main(): pid = 8683
20131024 07:19:37.457271Z  8683 TRACE updateChannel fd = 4 events = 3 - EPollPoller.cc:104
20131024 07:19:37.457470Z  8683 TRACE EventLoop EventLoop created 0xBFDDAB44 in thread 8683 - EventLoop.cc:62
20131024 07:19:37.457485Z  8683 TRACE updateChannel fd = 5 events = 3 - EPollPoller.cc:104
20131024 07:19:37.457645Z  8683 TRACE updateChannel fd = 6 events = 3 - EPollPoller.cc:104
20131024 07:19:37.457661Z  8683 TRACE loop EventLoop 0xBFDDAB44 start looping - EventLoop.cc:94
20131024 07:19:47.468016Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:19:57.478500Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:20:07.488977Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:20:17.499503Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:20:27.509985Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:20:37.520451Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:20:47.528439Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:20:57.538942Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:21:01.262358Z  8683 TRACE poll 1 events happended - EPollPoller.cc:65
20131024 07:21:01.262792Z  8683 TRACE printActiveChannels {6: IN }  - EventLoop.cc:257
20131024 07:21:01.262820Z  8683 TRACE handleEventWithGuard 2222222222222222POLLIN22222222222222222222 - Channel.cc:89
20131024 07:21:01.262881Z  8683 INFO  TcpServer::newConnection [TestServer] - new connection [TestServer:0.0.0.0:8888#1] from 127.0.0.1:56659 - TcpServer.cc:93
20131024 07:21:01.262916Z  8683 DEBUG TcpConnection TcpConnection::ctor[TestServer:0.0.0.0:8888#1] at 0x96C65D0 fd=8 - TcpConnection.cc:62
20131024 07:21:01.262934Z  8683 TRACE newConnection [1] usecount=1 - TcpServer.cc:111
20131024 07:21:01.262961Z  8683 TRACE newConnection [2] usecount=2 - TcpServer.cc:113
20131024 07:21:01.262981Z  8683 TRACE connectEstablished [3] usecount=6 - TcpConnection.cc:231
20131024 07:21:01.262998Z  8683 TRACE updateChannel fd = 8 events = 3 - EPollPoller.cc:104
onConnection(): new connection [TestServer:0.0.0.0:8888#1] from 127.0.0.1:56659
20131024 07:21:01.263363Z  8683 TRACE connectEstablished [4] usecount=6 - TcpConnection.cc:236
20131024 07:21:01.263378Z  8683 TRACE newConnection [5] usecount=2 - TcpServer.cc:122
20131024 07:21:11.265287Z  8683 TRACE poll 1 events happended - EPollPoller.cc:65
20131024 07:21:11.265469Z  8683 TRACE printActiveChannels {8: IN HUP }  - EventLoop.cc:257
20131024 07:21:11.265483Z  8683 TRACE handleEvent [6] usecount=2 - Channel.cc:67
20131024 07:21:11.265491Z  8683 TRACE handleEventWithGuard 1111111111111111POLLHUP1111111111111111111 - Channel.cc:85
20131024 07:21:11.265498Z  8683 TRACE handleEventWithGuard 2222222222222222POLLIN22222222222222222222 - Channel.cc:89
20131024 07:21:11.265556Z  8683 TRACE handleClose fd = 8 state = 3 - TcpConnection.cc:297
20131024 07:21:11.265567Z  8683 TRACE updateChannel fd = 8 events = 0 - EPollPoller.cc:104
onConnection(): connection [TestServer:0.0.0.0:8888#1] is down
20131024 07:21:11.265588Z  8683 TRACE handleClose [7] usecount=3 - TcpConnection.cc:305
20131024 07:21:11.265604Z  8683 INFO  TcpServer::removeConnectionInLoop [TestServer] - connection TestServer:0.0.0.0:8888#1 - TcpServer.cc:153
20131024 07:21:11.265611Z  8683 TRACE removeConnectionInLoop [8] usecount=6 - TcpServer.cc:157
20131024 07:21:11.265626Z  8683 TRACE removeConnectionInLoop [9] usecount=5 - TcpServer.cc:159
20131024 07:21:11.265639Z  8683 TRACE removeConnectionInLoop [10] usecount=6 - TcpServer.cc:170
20131024 07:21:11.265646Z  8683 TRACE handleClose [11] usecount=3 - TcpConnection.cc:308
20131024 07:21:11.265652Z  8683 TRACE handleEvent [12] usecount=2 - Channel.cc:69
20131024 07:21:11.265659Z  8683 TRACE removeChannel fd = 8 - EPollPoller.cc:147
20131024 07:21:11.265682Z  8683 DEBUG ~TcpConnection TcpConnection::dtor[TestServer:0.0.0.0:8888#1] at 0x96C65D0 fd=8 - TcpConnection.cc:69
20131024 07:21:21.275816Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:21:31.285830Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
20131024 07:21:41.296314Z  8683 TRACE poll  nothing happended - EPollPoller.cc:74
^C
ubuntu@ubuntu-virtual-machine:~/pro/37$
</code></pre>

<p>客户端：</p>

<pre><code class="language-c++">ubuntu@ubuntu-virtual-machine:~/pro/37$ ./a.out
ret=300
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBret=0
</code></pre>

<h2 id="38-完善tcpconnection">[38] 完善TcpConnection</h2>

<p>完善<code>TcpConnection</code>
<code>WriteCompleteCallback</code>含义
<code>HighWaterMarkCallback</code>含义
<code>boost::any context_</code>
<code>signal(SIGPIPE, SIG_IGN)</code> // 请看<code>channel class</code>
可变类型解决方案
<code>void*.</code> 这种方法不是类型安全的
<code>boost::any</code>
<code>boost::any</code>
任意类型的类型安全存储以及安全的取回
在标准库容器中存放不同类型的方法，比如说<code>vector&lt;boost::any&gt;</code>
<code>TcpConnection</code> 完整的头文件</p>

<p>TcpConnection.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_TCPCONNECTION_H
#define MUDUO_NET_TCPCONNECTION_H
 
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/base/StringPiece.h&gt;
#include &lt;muduo/base/Types.h&gt;
#include &lt;muduo/net/Callbacks.h&gt;
#include &lt;muduo/net/Buffer.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/any.hpp&gt;
#include &lt;boost/enable_shared_from_this.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class Channel;
class EventLoop;
class Socket;
 
///
/// TCP connection, for both client and server usage.
///
/// This is an interface class, so don't expose too much details.
class TcpConnection : boost::noncopyable,
                      public boost::enable_shared_from_this&lt;TcpConnection&gt;
{
 public:
  /// Constructs a TcpConnection with a connected sockfd
  ///
  /// User should not create this object.
  TcpConnection(EventLoop* loop,
                const string&amp; name,
                int sockfd,
                const InetAddress&amp; localAddr,
                const InetAddress&amp; peerAddr);
  ~TcpConnection();
 
  EventLoop* getLoop() const { return loop_; }
  const string&amp; name() const { return name_; }
  const InetAddress&amp; localAddress() { return localAddr_; }
  const InetAddress&amp; peerAddress() { return peerAddr_; }
  bool connected() const { return state_ == kConnected; }
 
  // void send(string&amp;&amp; message); // C++11
  void send(const void* message, size_t len);
  void send(const StringPiece&amp; message);
  // void send(Buffer&amp;&amp; message); // C++11
  void send(Buffer* message);  // this one will swap data
  void shutdown(); // NOT thread safe, no simultaneous calling
  void setTcpNoDelay(bool on);
 
  void setContext(const boost::any&amp; context)
  { context_ = context; }
 
  const boost::any&amp; getContext() const
  { return context_; }
 
  boost::any* getMutableContext()
  { return &amp;context_; }
 
  void setConnectionCallback(const ConnectionCallback&amp; cb)
  { connectionCallback_ = cb; }
 
  void setMessageCallback(const MessageCallback&amp; cb)
  { messageCallback_ = cb; }
 
  void setWriteCompleteCallback(const WriteCompleteCallback&amp; cb)
  { writeCompleteCallback_ = cb; }
 
  void setHighWaterMarkCallback(const HighWaterMarkCallback&amp; cb, size_t highWaterMark)
  { highWaterMarkCallback_ = cb; highWaterMark_ = highWaterMark; }
 
  Buffer* inputBuffer()
  { return &amp;inputBuffer_; }
 
  /// Internal use only.
  void setCloseCallback(const CloseCallback&amp; cb)
  { closeCallback_ = cb; }
 
  // called when TcpServer accepts a new connection
  void connectEstablished();   // should be called only once
  // called when TcpServer has removed me from its map
  void connectDestroyed();  // should be called only once
 
 private:
  enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting };
  void handleRead(Timestamp receiveTime);
  void handleWrite();
  void handleClose();
  void handleError();
  void sendInLoop(const StringPiece&amp; message);
  void sendInLoop(const void* message, size_t len);
  void shutdownInLoop();
  void setState(StateE s) { state_ = s; }
 
  EventLoop* loop_;         // 所属EventLoop
  string name_;             // 连接名
  StateE state_;  // FIXME: use atomic variable
  // we don't expose those classes to client.
  boost::scoped_ptr&lt;Socket&gt; socket_;
  boost::scoped_ptr&lt;Channel&gt; channel_;
  InetAddress localAddr_;
  InetAddress peerAddr_;
  ConnectionCallback connectionCallback_;
  MessageCallback messageCallback_;
  WriteCompleteCallback writeCompleteCallback_;     // 数据发送完毕回调函数，即所有的用户数据都已拷贝到内核缓冲区时回调该函数
                                                    // outputBuffer_被清空也会回调该函数，可以理解为低水位标回调函数
  HighWaterMarkCallback highWaterMarkCallback_;     // 高水位标回调函数
  CloseCallback closeCallback_;
  size_t highWaterMark_;        // 高水位标
  Buffer inputBuffer_;          // 应用层接收缓冲区
  Buffer outputBuffer_;         // 应用层发送缓冲区
  boost::any context_;          // 绑定一个未知类型的上下文对象
};
 
typedef boost::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;
 
}
}
 
#endif  // MUDUO_NET_TCPCONNECTION_H
</code></pre>

<h3 id="tcpconnection-完整的源文件">TcpConnection 完整的源文件</h3>

<p>TcpConnection.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
 
#include &lt;muduo/net/TcpConnection.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Channel.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/Socket.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
void muduo::net::defaultConnectionCallback(const TcpConnectionPtr&amp; conn)
{
  LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
            &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;
            &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
}
 
void muduo::net::defaultMessageCallback(const TcpConnectionPtr&amp;,
                                        Buffer* buf,
                                        Timestamp)
{
  buf-&gt;retrieveAll();
}
 
TcpConnection::TcpConnection(EventLoop* loop,
                             const string&amp; nameArg,
                             int sockfd,
                             const InetAddress&amp; localAddr,
                             const InetAddress&amp; peerAddr)
  : loop_(CHECK_NOTNULL(loop)),
    name_(nameArg),
    state_(kConnecting),
    socket_(new Socket(sockfd)),
    channel_(new Channel(loop, sockfd)),
    localAddr_(localAddr),
    peerAddr_(peerAddr),
    highWaterMark_(64*1024*1024)
{
  // 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间
  channel_-&gt;setReadCallback(
      boost::bind(&amp;TcpConnection::handleRead, this, _1));
  // 通道可写事件到来的时候，回调TcpConnection::handleWrite
  channel_-&gt;setWriteCallback(
      boost::bind(&amp;TcpConnection::handleWrite, this));
  // 连接关闭，回调TcpConnection::handleClose
  channel_-&gt;setCloseCallback(
      boost::bind(&amp;TcpConnection::handleClose, this));
  // 发生错误，回调TcpConnection::handleError
  channel_-&gt;setErrorCallback(
      boost::bind(&amp;TcpConnection::handleError, this));
  LOG_DEBUG &lt;&lt; &quot;TcpConnection::ctor[&quot; &lt;&lt;  name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this
            &lt;&lt; &quot; fd=&quot; &lt;&lt; sockfd;
  socket_-&gt;setKeepAlive(true);
}
 
TcpConnection::~TcpConnection()
{
  LOG_DEBUG &lt;&lt; &quot;TcpConnection::dtor[&quot; &lt;&lt;  name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this
            &lt;&lt; &quot; fd=&quot; &lt;&lt; channel_-&gt;fd();
}
 
// 线程安全，可以跨线程调用
void TcpConnection::send(const void* data, size_t len)
{
  if (state_ == kConnected)
  {
    if (loop_-&gt;isInLoopThread())
    {
      sendInLoop(data, len);
    }
    else
    {
      string message(static_cast&lt;const char*&gt;(data), len);
      loop_-&gt;runInLoop(
          boost::bind(&amp;TcpConnection::sendInLoop,
                      this,
                      message));
    }
  }
}
 
// 线程安全，可以跨线程调用
void TcpConnection::send(const StringPiece&amp; message)
{
  if (state_ == kConnected)
  {
    if (loop_-&gt;isInLoopThread())
    {
      sendInLoop(message);
    }
    else
    {
      loop_-&gt;runInLoop(
          boost::bind(&amp;TcpConnection::sendInLoop,
                      this,
                      message.as_string()));
                    //std::forward&lt;string&gt;(message)));
    }
  }
}
 
// 线程安全，可以跨线程调用
void TcpConnection::send(Buffer* buf)
{
  if (state_ == kConnected)
  {
    if (loop_-&gt;isInLoopThread())
    {
      sendInLoop(buf-&gt;peek(), buf-&gt;readableBytes());
      buf-&gt;retrieveAll();
    }
    else
    {
      loop_-&gt;runInLoop(
          boost::bind(&amp;TcpConnection::sendInLoop,
                      this,
                      buf-&gt;retrieveAllAsString()));
                    //std::forward&lt;string&gt;(message)));
    }
  }
}
 
void TcpConnection::sendInLoop(const StringPiece&amp; message)
{
  sendInLoop(message.data(), message.size());
}
 
void TcpConnection::sendInLoop(const void* data, size_t len)
{
  /*
  loop_-&gt;assertInLoopThread();
  sockets::write(channel_-&gt;fd(), data, len);
  */
 
  loop_-&gt;assertInLoopThread();
  ssize_t nwrote = 0;
  size_t remaining = len;
  bool error = false;
  if (state_ == kDisconnected)
  {
    LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;
    return;
  }
  // if no thing in output queue, try writing directly
  // 通道没有关注可写事件并且发送缓冲区没有数据，直接write
  if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)
  {
    nwrote = sockets::write(channel_-&gt;fd(), data, len);
    if (nwrote &gt;= 0)
    {
      remaining = len - nwrote;
      // 写完了，回调writeCompleteCallback_
      if (remaining == 0 &amp;&amp; writeCompleteCallback_)
      {
        loop_-&gt;queueInLoop(boost::bind(writeCompleteCallback_, shared_from_this()));
      }
    }
    else // nwrote &lt; 0
    {
      nwrote = 0;
      if (errno != EWOULDBLOCK)
      {
        LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;
        if (errno == EPIPE) // FIXME: any others?
        {
          error = true;
        }
      }
    }
  }
 
  assert(remaining &lt;= len);
  // 没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中）
  if (!error &amp;&amp; remaining &gt; 0)
  {
    LOG_TRACE &lt;&lt; &quot;I am going to write more data&quot;;
    size_t oldLen = outputBuffer_.readableBytes();
    // 如果超过highWaterMark_（高水位标），回调highWaterMarkCallback_
    //即使oldLen + remaining &gt;= highWaterMark_ ，remain的数据也是可以存放到buffer中的，因为buffer
    //自动伸缩的
    if (oldLen + remaining &gt;= highWaterMark_
        &amp;&amp; oldLen &lt; highWaterMark_
        &amp;&amp; highWaterMarkCallback_)
    {
      loop_-&gt;queueInLoop(boost::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));
    }
    outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote, remaining);
    if (!channel_-&gt;isWriting())
    {
      channel_-&gt;enableWriting();     // 关注POLLOUT事件
    }
  }
}
 
void TcpConnection::shutdown()
{
  // FIXME: use compare and swap
  if (state_ == kConnected)
  {
    setState(kDisconnecting);
    // FIXME: shared_from_this()?
    loop_-&gt;runInLoop(boost::bind(&amp;TcpConnection::shutdownInLoop, this));
  }
}
 
void TcpConnection::shutdownInLoop()
{
  loop_-&gt;assertInLoopThread();
  if (!channel_-&gt;isWriting())
  {
    // we are not writing
    socket_-&gt;shutdownWrite();
  }
}
 
void TcpConnection::setTcpNoDelay(bool on)
{
  socket_-&gt;setTcpNoDelay(on);
}
 
void TcpConnection::connectEstablished()
{
  loop_-&gt;assertInLoopThread();
  assert(state_ == kConnecting);
  setState(kConnected);
  LOG_TRACE &lt;&lt; &quot;[3] usecount=&quot; &lt;&lt; shared_from_this().use_count();
  channel_-&gt;tie(shared_from_this());
  channel_-&gt;enableReading(); // TcpConnection所对应的通道加入到Poller关注
 
  connectionCallback_(shared_from_this());
  LOG_TRACE &lt;&lt; &quot;[4] usecount=&quot; &lt;&lt; shared_from_this().use_count();
}
 
void TcpConnection::connectDestroyed()
{
  loop_-&gt;assertInLoopThread();
  if (state_ == kConnected)
  {
    setState(kDisconnected);
    channel_-&gt;disableAll();
 
    connectionCallback_(shared_from_this());
  }
  channel_-&gt;remove();
}
 
void TcpConnection::handleRead(Timestamp receiveTime)
{
  /*
  loop_-&gt;assertInLoopThread();
  int savedErrno = 0;
  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);
  if (n &gt; 0)
  {
    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
  }
  else if (n == 0)
  {
    handleClose();
  }
  else
  {
    errno = savedErrno;
    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
    handleError();
  }
  */
 
  /*
  loop_-&gt;assertInLoopThread();
  int savedErrno = 0;
  char buf[65536];
  ssize_t n = ::read(channel_-&gt;fd(), buf, sizeof buf);
  if (n &gt; 0)
  {
    messageCallback_(shared_from_this(), buf, n);
  }
  else if (n == 0)
  {
    handleClose();
  }
  else
  {
    errno = savedErrno;
    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
    handleError();
  }
  */
  loop_-&gt;assertInLoopThread();
  int savedErrno = 0;
  /*一次性读完内核缓冲区的数据，这可以防止busy loop*/
  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);
  if (n &gt; 0)
  {
    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
  }
  else if (n == 0)
  {
    //读到文件eof ，就是对等方已经关闭连接
    handleClose();
  }
  else
  {
    errno = savedErrno;
    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
    handleError();
  }
}
 
// 内核发送缓冲区有空间了，回调该函数
void TcpConnection::handleWrite()
{
  loop_-&gt;assertInLoopThread();
  /*通道有关注write事件 */
  if (channel_-&gt;isWriting())
  {
    /*写数据到内核中*/
    ssize_t n = sockets::write(channel_-&gt;fd(),
                               outputBuffer_.peek(),
                               outputBuffer_.readableBytes());
    if (n &gt; 0)
    {
      outputBuffer_.retrieve(n);
      if (outputBuffer_.readableBytes() == 0)    // 发送缓冲区已清空
      {
        channel_-&gt;disableWriting();      // 停止关注POLLOUT事件，以免出现busy loop
        if (writeCompleteCallback_)     // 回调writeCompleteCallback_
        {
          // 应用层发送缓冲区被清空，就回调用writeCompleteCallback_
          loop_-&gt;queueInLoop(boost::bind(writeCompleteCallback_, shared_from_this()));
        }
        /*如果状态码是kDisconnecting ，说明应用层已经发起shutdown命令了，这是最后一个数据包，
        所以发完就可以关闭了。
        请参照void TcpConnection::shutdownInLoop()
        */
        if (state_ == kDisconnecting)   // 发送缓冲区已清空并且连接状态是kDisconnecting, 要关闭连接
        {
          shutdownInLoop();     // 关闭连接
        }
      }
      else
      {
        LOG_TRACE &lt;&lt; &quot;I am going to write more data&quot;;
      }
    }
    else
    {
      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;
      // if (state_ == kDisconnecting)
      // {
      //   shutdownInLoop();
      // }
    }
  }
  else
  {
    LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()
              &lt;&lt; &quot; is down, no more writing&quot;;
  }
}
 
void TcpConnection::handleClose()
{
  loop_-&gt;assertInLoopThread();
  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel_-&gt;fd() &lt;&lt; &quot; state = &quot; &lt;&lt; state_;
  assert(state_ == kConnected || state_ == kDisconnecting);
  // we don't close fd, leave it to dtor, so we can find leaks easily.
  setState(kDisconnected);
  channel_-&gt;disableAll();
 
  TcpConnectionPtr guardThis(shared_from_this());
  connectionCallback_(guardThis);       // 这一行，可以不调用
  LOG_TRACE &lt;&lt; &quot;[7] usecount=&quot; &lt;&lt; guardThis.use_count();
  // must be the last line
  closeCallback_(guardThis);    // 调用TcpServer::removeConnection
  LOG_TRACE &lt;&lt; &quot;[11] usecount=&quot; &lt;&lt; guardThis.use_count();
}
 
void TcpConnection::handleError()
{
  int err = sockets::getSocketError(channel_-&gt;fd());
  LOG_ERROR &lt;&lt; &quot;TcpConnection::handleError [&quot; &lt;&lt; name_
            &lt;&lt; &quot;] - SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);
}
</code></pre>

<h3 id="测试程序-2">测试程序</h3>

<pre><code class="language-c++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;
/*
程序说明：
  客户端请求连接-------》服务器马上发送一堆数据
 
*/
using namespace muduo;
using namespace muduo::net;
 
class TestServer
{
 public:
  TestServer(EventLoop* loop,
             const InetAddress&amp; listenAddr)
    : loop_(loop),
      server_(loop, listenAddr, &quot;TestServer&quot;)
  {
    server_.setConnectionCallback(
        boost::bind(&amp;TestServer::onConnection, this, _1));
    server_.setMessageCallback(
        boost::bind(&amp;TestServer::onMessage, this, _1, _2, _3));
    server_.setWriteCompleteCallback(
      boost::bind(&amp;TestServer::onWriteComplete, this, _1));
 
    // 这是一个数据生成协议
    string line;
    for (int i = 33; i &lt; 127; ++i)
    {
      line.push_back(char(i));
    }
    line += line;
 
    for (size_t i = 0; i &lt; 127-33; ++i)
    {
      message_ += line.substr(i, 72) + '\n';
    }
  }
 
  void start()
  {
      server_.start();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    if (conn-&gt;connected())
    {
      printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
             conn-&gt;name().c_str(),
             conn-&gt;peerAddress().toIpPort().c_str());
 
      conn-&gt;setTcpNoDelay(true);
      /*连接到来直接发送数据*/
      conn-&gt;send(message_);
    }
    else
    {
      printf(&quot;onConnection(): connection [%s] is down\n&quot;,
             conn-&gt;name().c_str());
    }
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn,
                 Buffer* buf,
                 Timestamp receiveTime)
  {
    muduo::string msg(buf-&gt;retrieveAllAsString());
    printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,
           msg.size(),
           conn-&gt;name().c_str(),
           receiveTime.toFormattedString().c_str());
 
    conn-&gt;send(msg);
  }
 
  void onWriteComplete(const TcpConnectionPtr&amp; conn)
  { /*可写事件，在发送*/
    conn-&gt;send(message_);
  }
 
  EventLoop* loop_;
  TcpServer server_;
 
  muduo::string message_;
};
 
 
int main()
{
  printf(&quot;main(): pid = %d\n&quot;, getpid());
 
  InetAddress listenAddr(8888);
  EventLoop loop;
 
  TestServer server(&amp;loop, listenAddr);
  server.start();
 
  loop.loop();
}
</code></pre>

<h2 id="39-tcpclient和connector">[39] TcpClient和connector</h2>

<ul>
<li><code>muduo</code>库对编写<code>tcp</code>(主动发起连接<code>TcpClient</code>)</li>
<li>客户端程序的支持<code>Connector</code>(包含了一个<code>Connector</code>对象)</li>
</ul>

<h3 id="测试程序-3">测试程序</h3>

<ul>
<li>Reactor_test11.cc    
// echo server</li>
<li>TcpClient_test.cc    
// echo client</li>
</ul>

<h3 id="tcpclient-头文件">TcpClient 头文件</h3>

<p>TcpClient.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_TCPCLIENT_H
#define MUDUO_NET_TCPCLIENT_H
 
#include &lt;boost/noncopyable.hpp&gt;
 
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/net/TcpConnection.h&gt;
 
namespace muduo
{
namespace net
{
 
class Connector;
typedef boost::shared_ptr&lt;Connector&gt; ConnectorPtr;
 
class TcpClient : boost::noncopyable
{
 public:
  // TcpClient(EventLoop* loop);
  // TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);
  TcpClient(EventLoop* loop,
            const InetAddress&amp; serverAddr,
            const string&amp; name);
  ~TcpClient();  // force out-line dtor, for scoped_ptr members.
 
  void connect();
  void disconnect();
  void stop();
 
  TcpConnectionPtr connection() const
  {
    MutexLockGuard lock(mutex_);
    return connection_;
  }
 
  bool retry() const;
  void enableRetry() { retry_ = true; }
 
  /// Set connection callback.
  /// Not thread safe.
  void setConnectionCallback(const ConnectionCallback&amp; cb)
  { connectionCallback_ = cb; }
 
  /// Set message callback.
  /// Not thread safe.
  void setMessageCallback(const MessageCallback&amp; cb)
  { messageCallback_ = cb; }
 
  /// Set write complete callback.
  /// Not thread safe.
  void setWriteCompleteCallback(const WriteCompleteCallback&amp; cb)
  { writeCompleteCallback_ = cb; }
 
 private:
  /// Not thread safe, but in loop
  void newConnection(int sockfd);
  /// Not thread safe, but in loop
  void removeConnection(const TcpConnectionPtr&amp; conn);
 
  EventLoop* loop_;
  ConnectorPtr connector_;  // 用于主动发起连接
  const string name_;       // 名称
  ConnectionCallback connectionCallback_;       // 连接建立回调函数
  MessageCallback messageCallback_;             // 消息到来回调函数
  WriteCompleteCallback writeCompleteCallback_; // 数据发送完毕回调函数
  bool retry_;   // 重连，是指连接建立之后又断开的时候是否重连，
                //这个跟connector里面的retry是不一样的，connector里面的retry表示连接不成功时是否要重连
  bool connect_; // atomic 是否发起连接
  // always in loop thread
  int nextConnId_;          // name_ + nextConnId_用于标识一个连接
  mutable MutexLock mutex_;
  TcpConnectionPtr connection_; // Connector连接成功以后，得到一个TcpConnection
};
 
}
}
 
#endif  // MUDUO_NET_TCPCLIENT_H
</code></pre>

<h3 id="tcpclient-源文件">TcpClient 源文件</h3>

<p>TcpClient.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
 
#include &lt;muduo/net/TcpClient.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Connector.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;  // snprintf
 
using namespace muduo;
using namespace muduo::net;
 
// TcpClient::TcpClient(EventLoop* loop)
//   : loop_(loop)
// {
// }
 
// TcpClient::TcpClient(EventLoop* loop, const string&amp; host, uint16_t port)
//   : loop_(CHECK_NOTNULL(loop)),
//     serverAddr_(host, port)
// {
// }
 
namespace muduo
{
namespace net
{
namespace detail
{
 
void removeConnection(EventLoop* loop, const TcpConnectionPtr&amp; conn)
{
  loop-&gt;queueInLoop(boost::bind(&amp;TcpConnection::connectDestroyed, conn));
}
 
void removeConnector(const ConnectorPtr&amp; connector)
{
  //connector-&gt;
}
 
}
}
}
 
TcpClient::TcpClient(EventLoop* loop,
                     const InetAddress&amp; serverAddr,
                     const string&amp; name)
  : loop_(CHECK_NOTNULL(loop)),
    connector_(new Connector(loop, serverAddr)),
    name_(name),
    connectionCallback_(defaultConnectionCallback),
    messageCallback_(defaultMessageCallback),
    retry_(false),
    connect_(true),
    nextConnId_(1)
{
  // 设置连接成功回调函数
  connector_-&gt;setNewConnectionCallback(
      boost::bind(&amp;TcpClient::newConnection, this, _1));
  // FIXME setConnectFailedCallback
  LOG_INFO &lt;&lt; &quot;TcpClient::TcpClient[&quot; &lt;&lt; name_
           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);
}
 
TcpClient::~TcpClient()
{
  LOG_INFO &lt;&lt; &quot;TcpClient::~TcpClient[&quot; &lt;&lt; name_
           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);
  TcpConnectionPtr conn;
  {
    MutexLockGuard lock(mutex_);
    conn = connection_;
  }
  if (conn)
  {
    // FIXME: not 100% safe, if we are in different thread
 
    // 重新设置TcpConnection中的closeCallback_为detail::removeConnection
    //这里不用TcpClient::removeConnection的原因是 TcpClient::removeConnection 有重连功能,
    //这里已经不需要重连了，直接调用detail::removeConnection就行了
    CloseCallback cb = boost::bind(&amp;detail::removeConnection, loop_, _1);
    loop_-&gt;runInLoop(
        boost::bind(&amp;TcpConnection::setCloseCallback, conn, cb));
  }
  else
  {
    // 这种情况，说明connector处于未连接状态，将connector_停止
    connector_-&gt;stop();
    // FIXME: HACK
    loop_-&gt;runAfter(1, boost::bind(&amp;detail::removeConnector, connector_));
  }
}
 
void TcpClient::connect()
{
  // FIXME: check state
  LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - connecting to &quot;
           &lt;&lt; connector_-&gt;serverAddress().toIpPort();
  connect_ = true;
  connector_-&gt;start();   // 发起连接
}
 
// 用于连接已建立的情况下，关闭连接
void TcpClient::disconnect()
{
  connect_ = false;
 
  {
    MutexLockGuard lock(mutex_);
    if (connection_)
    {
      connection_-&gt;shutdown();
    }
  }
}
 
// 停止connector_ ,连接尚未成功时进行断开
void TcpClient::stop()
{
  connect_ = false;
  connector_-&gt;stop();
}
 
//有新的连接到来
void TcpClient::newConnection(int sockfd)
{
  loop_-&gt;assertInLoopThread();
  InetAddress peerAddr(sockets::getPeerAddr(sockfd));
  char buf[32];
  snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, peerAddr.toIpPort().c_str(), nextConnId_);
  ++nextConnId_;
  string connName = name_ + buf;
 
  InetAddress localAddr(sockets::getLocalAddr(sockfd));
  // FIXME poll with zero timeout to double confirm the new connection
  // FIXME use make_shared if necessary
  TcpConnectionPtr conn(new TcpConnection(loop_,
                                          connName,
                                          sockfd,
                                          localAddr,
                                          peerAddr));
 
  conn-&gt;setConnectionCallback(connectionCallback_);
  conn-&gt;setMessageCallback(messageCallback_);
  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);
  conn-&gt;setCloseCallback(
      boost::bind(&amp;TcpClient::removeConnection, this, _1)); // FIXME: unsafe
  {
    MutexLockGuard lock(mutex_);
    connection_ = conn;     // 保存TcpConnection
  }
  conn-&gt;connectEstablished();        // 这里回调connectionCallback_
}
 
/*移除connector*/
void TcpClient::removeConnection(const TcpConnectionPtr&amp; conn)
{
  loop_-&gt;assertInLoopThread();
  assert(loop_ == conn-&gt;getLoop());
 
  {
    MutexLockGuard lock(mutex_);
    assert(connection_ == conn);
    connection_.reset();
  }
  /*放到IO线程中销毁*/
  loop_-&gt;queueInLoop(boost::bind(&amp;TcpConnection::connectDestroyed, conn));
  //如果需要重连，则重新连接
  if (retry_ &amp;&amp; connect_)
  {
    LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - Reconnecting to &quot;
             &lt;&lt; connector_-&gt;serverAddress().toIpPort();
    // 这里的重连是指连接建立成功之后被断开的重连
    connector_-&gt;restart();
  }
}
</code></pre>

<h3 id="connector-头文件">Connector 头文件</h3>

<p>Connector.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is an internal header file, you should not include this.
 
#ifndef MUDUO_NET_CONNECTOR_H
#define MUDUO_NET_CONNECTOR_H
 
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/enable_shared_from_this.hpp&gt;
#include &lt;boost/function.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class Channel;
class EventLoop;
 
// 主动发起连接，带有自动重连功能
class Connector : boost::noncopyable,
                  public boost::enable_shared_from_this&lt;Connector&gt;
{
 public:
  typedef boost::function&lt;void (int sockfd)&gt; NewConnectionCallback;
 
  Connector(EventLoop* loop, const InetAddress&amp; serverAddr);
  ~Connector();
  /*设置连接成功后的回调函数*/
  void setNewConnectionCallback(const NewConnectionCallback&amp; cb)
  { newConnectionCallback_ = cb; }
 
  void start();  // can be called in any thread
  void restart();  // must be called in loop thread
  void stop();  // can be called in any thread
//服务器IP地址
  const InetAddress&amp; serverAddress() const { return serverAddr_; }
 
 private:
  enum States { kDisconnected/*断开状态*/, kConnecting/*正在连接中*/, kConnected/*已连接*/ };
  static const int kMaxRetryDelayMs = 30*1000;          // 30秒，最大重连延迟时间
  static const int kInitRetryDelayMs = 500;             // 0.5秒，初始状态，连接不上，0.5秒后重连
 
  void setState(States s) { state_ = s; }
  void startInLoop();
  void stopInLoop();
  void connect();
  void connecting(int sockfd);
  void handleWrite();
  void handleError();
  void retry(int sockfd);
  int removeAndResetChannel();
  void resetChannel();
 
  EventLoop* loop_;         // 所属EventLoop
  InetAddress serverAddr_;  // 服务器端地址
  bool connect_; // atomic是否连接
  States state_;  // FIXME: use atomic variable
  boost::scoped_ptr&lt;Channel&gt; channel_;    // Connector所对应的Channel
  NewConnectionCallback newConnectionCallback_;     // 连接成功回调函数，
  int retryDelayMs_;        // 重连延迟时间（单位：毫秒）
};
 
}
}
 
#endif  // MUDUO_NET_CONNECTOR_H
</code></pre>

<h3 id="connector-源文件">Connector 源文件</h3>

<p>Connector.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
 
#include &lt;muduo/net/Connector.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Channel.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;errno.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
const int Connector::kMaxRetryDelayMs;
 
Connector::Connector(EventLoop* loop, const InetAddress&amp; serverAddr)
  : loop_(loop),
    serverAddr_(serverAddr),
    connect_(false),
    state_(kDisconnected),
    retryDelayMs_(kInitRetryDelayMs)
{
  LOG_DEBUG &lt;&lt; &quot;ctor[&quot; &lt;&lt; this &lt;&lt; &quot;]&quot;;
}
 
Connector::~Connector()
{
  LOG_DEBUG &lt;&lt; &quot;dtor[&quot; &lt;&lt; this &lt;&lt; &quot;]&quot;;
  assert(!channel_);
}
 
// 可以跨线程调用 ，把重新发起的连接函数放到IO线程去，所以是线程
// 安全的
void Connector::start()
{
  connect_ = true;
  loop_-&gt;runInLoop(boost::bind(&amp;Connector::startInLoop, this)); // FIXME: unsafe
}
 
/*重新发起连接*/
void Connector::startInLoop()
{
  loop_-&gt;assertInLoopThread();
  assert(state_ == kDisconnected);
  if (connect_)
  {
    /*如果为true 重新连接，
    如果调用stop 后，那么connect_ = false
    */
    connect();
  }
  else
  {
    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;
  }
}
 
/*让IO线程线程停止连接，这个连接处于*/
void Connector::stop()
{
  connect_ = false;
  loop_-&gt;runInLoop(boost::bind(&amp;Connector::stopInLoop, this)); // FIXME: unsafe
  // FIXME: cancel timer
}
 
void Connector::stopInLoop()
{
  loop_-&gt;assertInLoopThread();
  if (state_ == kConnecting)
  {
    setState(kDisconnected);
    int sockfd = removeAndResetChannel();   // 将通道从poller中移除关注，并将channel置空
    retry(sockfd);      // 这里并非要重连，只是调用sockets::close(sockfd);
  }
}
 
/*发起连接  */
void Connector::connect()
{
  int sockfd = sockets::createNonblockingOrDie();   // 创建非阻塞套接字
  /*进行连接请求*/
  int ret = sockets::connect(sockfd, serverAddr_.getSockAddrInet());
 
  int savedErrno = (ret == 0) ? 0 : errno;
  switch (savedErrno)
  {
    case 0:
    case EINPROGRESS:   // 非阻塞套接字，未连接成功返回码是EINPROGRESS表示正在连接
    case EINTR:
    case EISCONN:           // 连接成功
      connecting(sockfd);
      break;
 
    case EAGAIN:
    case EADDRINUSE:
    case EADDRNOTAVAIL:
    case ECONNREFUSED:
    case ENETUNREACH:
      retry(sockfd);        // 重连
      break;
 
    case EACCES:
    case EPERM:
    case EAFNOSUPPORT:
    case EALREADY:
    case EBADF:
    case EFAULT:
    case ENOTSOCK:
      LOG_SYSERR &lt;&lt; &quot;connect error in Connector::startInLoop &quot; &lt;&lt; savedErrno;
      sockets::close(sockfd);   // 不能重连，关闭sockfd
      break;
 
    default:
      LOG_SYSERR &lt;&lt; &quot;Unexpected error in Connector::startInLoop &quot; &lt;&lt; savedErrno;
      sockets::close(sockfd);
      // connectErrorCallback_();
      break;
  }
}
 
// 不能跨线程调用
void Connector::restart()
{
  loop_-&gt;assertInLoopThread();
  setState(kDisconnected);
  retryDelayMs_ = kInitRetryDelayMs;
  connect_ = true;
  startInLoop();
}
 
void Connector::connecting(int sockfd)
{
  //不管是真正连接还是连接成功了，都把状态设置为kConnecting
  setState(kConnecting);
  assert(!channel_);
  // Channel与sockfd关联
  channel_.reset(new Channel(loop_, sockfd));
  // 设置可写回调函数，主要是为了“正在连接”状态设置的
  channel_-&gt;setWriteCallback(
      boost::bind(&amp;Connector::handleWrite, this)); // FIXME: unsafe
  // 设置错误回调函数
  channel_-&gt;setErrorCallback(
      boost::bind(&amp;Connector::handleError, this)); // FIXME: unsafe
 
  // channel_-&gt;tie(shared_from_this()); is not working,
  // as channel_ is not managed by shared_ptr
 
  channel_-&gt;enableWriting();     // 让Poller关注可写事件，writing一定产生，不管是连接成功还是连接失败，
                                //
}
 
int Connector::removeAndResetChannel()
{
  channel_-&gt;disableAll();
  channel_-&gt;remove();            // 从poller移除关注
  int sockfd = channel_-&gt;fd();
  // Can't reset channel_ here, because we are inside Channel::handleEvent
  // 不能在这里重置channel_，因为正在调用Channel::handleEvent
  loop_-&gt;queueInLoop(boost::bind(&amp;Connector::resetChannel, this)); // FIXME: unsafe
  return sockfd;
}
 
void Connector::resetChannel()
{
  channel_.reset();     // channel_ 置空
}
 
 
void Connector::handleWrite()
{
  LOG_TRACE &lt;&lt; &quot;Connector::handleWrite &quot; &lt;&lt; state_;
  /*由于在Connector::connecting注册可写事件时，“状态” 被设置为kConnecting（不管完不完成连接），
  所以第一次handleWrite时，得把“状态”设置为kConnected*/
  if (state_ == kConnecting)
  {
    /*这里不用再关注可写事件了，这里也是防止busy loop*/
    int sockfd = removeAndResetChannel();   // 从poller中移除关注，并将channel置空
    // socket可写并不意味着连接一定建立成功
    // 还需要用getsockopt(sockfd, SOL_SOCKET, SO_ERROR, ...)再次确认一下。
    int err = sockets::getSocketError(sockfd);
    if (err)        // 有错误
    {
      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - SO_ERROR = &quot;
               &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);
      retry(sockfd);        // 重连
    }
    else if (sockets::isSelfConnect(sockfd))        // 自连接
    {
      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - Self connect&quot;;
      retry(sockfd);        // 重连
    }
    else    // 连接成功
    {
      setState(kConnected);
      if (connect_)
      {
        newConnectionCallback_(sockfd);     // 回调连接成功的回调函数
      }
      else
      {
        sockets::close(sockfd);
      }
    }
  }
  else
  {
    // what happened?
    assert(state_ == kDisconnected);
  }
}
 
/*连接出错的处理函数*/
void Connector::handleError()
{
  LOG_ERROR &lt;&lt; &quot;Connector::handleError&quot;;
  assert(state_ == kConnecting);
 
  int sockfd = removeAndResetChannel();     // 从poller中移除关注，并将channel置空
  int err = sockets::getSocketError(sockfd);
  LOG_TRACE &lt;&lt; &quot;SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);
  retry(sockfd);
}
 
// 采用back-off策略重连，即重连时间逐渐延长，0.5s, 1s, 2s, ...直至30s
void Connector::retry(int sockfd)
{
  sockets::close(sockfd);
  setState(kDisconnected);
  if (connect_)
  {
    LOG_INFO &lt;&lt; &quot;Connector::retry - Retry connecting to &quot; &lt;&lt; serverAddr_.toIpPort()
             &lt;&lt; &quot; in &quot; &lt;&lt; retryDelayMs_ &lt;&lt; &quot; milliseconds. &quot;;
    // 注册一个定时操作，重连
    loop_-&gt;runAfter(retryDelayMs_/1000.0,
                    boost::bind(&amp;Connector::startInLoop, shared_from_this()));
    retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);
  }
  else
  {
    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;
  }
}

</code></pre>

<h3 id="测试程序-4">测试程序</h3>

<pre><code class="language-c++">#include &lt;muduo/net/Channel.h&gt;
#include &lt;muduo/net/TcpClient.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
class TestClient
{
 public:
  TestClient(EventLoop* loop, const InetAddress&amp; listenAddr)
    : loop_(loop),
      client_(loop, listenAddr, &quot;TestClient&quot;),
      stdinChannel_(loop, 0)
  {
    client_.setConnectionCallback(
        boost::bind(&amp;TestClient::onConnection, this, _1));
    client_.setMessageCallback(
        boost::bind(&amp;TestClient::onMessage, this, _1, _2, _3));
    //client_.enableRetry();
    // 标准输入缓冲区中有数据的时候，回调TestClient::handleRead
    stdinChannel_.setReadCallback(boost::bind(&amp;TestClient::handleRead, this));
    stdinChannel_.enableReading();
  }
 
  void connect()
  {
    client_.connect();
  }
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn)
  {
    if (conn-&gt;connected())
    {
      printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
             conn-&gt;name().c_str(),
             conn-&gt;peerAddress().toIpPort().c_str());
    }
    else
    {
      printf(&quot;onConnection(): connection [%s] is down\n&quot;,
             conn-&gt;name().c_str());
    }
  }
 
  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp time)
  {
    string msg(buf-&gt;retrieveAllAsString());
    printf(&quot;onMessage(): recv a message [%s]\n&quot;, msg.c_str());
    LOG_TRACE &lt;&lt; conn-&gt;name() &lt;&lt; &quot; recv &quot; &lt;&lt; msg.size() &lt;&lt; &quot; bytes at &quot; &lt;&lt; time.toFormattedString();
  }
 
  // 标准输入缓冲区中有数据的时候，回调该函数
  void handleRead()
  {
    char buf[1024] = {0};
    fgets(buf, 1024, stdin);
    buf[strlen(buf)-1] = '\0';      // 去除\n
    client_.connection()-&gt;send(buf);
  }
 
  EventLoop* loop_;
  TcpClient client_;
  Channel stdinChannel_;        // 标准输入Channel
};
 
int main(int argc, char* argv[])
{
  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, tid = &quot; &lt;&lt; CurrentThread::tid();
  EventLoop loop;
  InetAddress serverAddr(&quot;127.0.0.1&quot;, 8888);
  TestClient client(&amp;loop, serverAddr);
  client.connect();
  loop.loop();
}
</code></pre>

<h2 id="40-http-简单描述">[40] http 简单描述</h2>

<h3 id="http-request">http request</h3>

<p><code>request line</code> + <code>header</code> + <code>body</code> (<code>header</code>分为普通报头，请求报头与实体报头) <code>header</code>与<code>body</code>之间有一空行(<code>CRLF</code>)</p>

<h4 id="请求方法有">请求方法有</h4>

<p><code>Get</code>, <code>Post</code>, <code>Head</code>, <code>Put</code>, <code>Delete</code>等</p>

<p>协议版本号：<code>1.0</code>, <code>1.1</code></p>

<h4 id="常用请求头">常用请求头</h4>

<ul>
<li>Accept：浏览器可接受的媒体（MIME）类型；</li>
<li>Accept-Language：浏览器所希望的语言种类</li>
<li>Accept-Encoding：浏览器能够解码的编码方法，如gzip，deflate等</li>
<li>User-Agent：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本</li>
<li>Connection：表示是否需要持久连接，Keep-Alive表示长连接，close表示短连接</li>
</ul>

<h3 id="http-response">http response</h3>

<p>status line + header + body （header分为普通报头，响应报头与实体报头）
header与body之间有一空行（CRLF）</p>

<p>状态响应码</p>

<ul>
<li>1XX  提示信息
表示请求已被成功接收，继续处理</li>
<li>2XX  成功
表示请求已被成功接收，理解，接受</li>
<li>3XX  重定向
要完成请求必须进行更进一步的处理</li>
<li>4XX  客户端错误
请求有语法错误或请求无法实现</li>
<li>5XX  服务器端错误
服务器执行一个有效请求失败</li>
</ul>

<h3 id="一个典型的http请求">一个典型的http请求</h3>

<pre><code class="language-c++">GET / HTTP/1.1 (请求行)
Accept: image/jpeg, application/x-ms-application, image/gif, application/xaml+xml, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*(请求头)
Accept-Language: zh-CN(请求头)
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; Tablet PC 2.0)(请求头)
Accept-Encoding: gzip, deflate(请求头)
Host: 192.168.159.188:800(请求头)
Connection: Keep-Alive(请求头)

/*当前是get请求，没有body，如果是post请求的话会有实体*/
</code></pre>

<h3 id="一个典型的http应答">一个典型的http应答</h3>

<pre><code class="language-c++">HTTP/1.1 200 OK(请求行)
Content-Length: 112(头部)
Connection: Keep-Alive(头部)
Content-Type: text/html(头部)
Server: Muduo(头部)

&lt;html&gt;&lt;head&gt;&lt;title&gt;This is title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;Now is 20130611 02:14:31.518462&lt;/body&gt;&lt;/html&gt;(实体)
</code></pre>

<h3 id="muduo-http库涉及到的类">muduo_http库涉及到的类</h3>

<pre><code class="language-c++">HttpRequest：http请求类封装
HttpResponse：http响应类封装
HttpContext：http协议解析类
HttpServer：http服务器类封装
</code></pre>

<h2 id="40-1-http实现源码">[40-1] http实现源码</h2>

<h3 id="httprequest头文件-包含实现">HttpRequest头文件(包含实现)</h3>

<p>HttpResquest.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_HTTP_HTTPREQUEST_H
#define MUDUO_NET_HTTP_HTTPREQUEST_H
 
#include &lt;muduo/base/copyable.h&gt;
#include &lt;muduo/base/Timestamp.h&gt;
#include &lt;muduo/base/Types.h&gt;
 
#include &lt;map&gt;
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
 
namespace muduo
{
namespace net
{
 
class HttpRequest : public muduo::copyable
{
 public:
  enum Method
  {
    kInvalid, kGet, kPost, kHead, kPut, kDelete
  };
  enum Version
  {
    kUnknown, kHttp10, kHttp11
  };
 
  HttpRequest()
    : method_(kInvalid),
      version_(kUnknown)
  {
  }
 
  void setVersion(Version v)
  {
    version_ = v;
  }
 
  Version getVersion() const
  { return version_; }
 
/*设置请求方法*/
  bool setMethod(const char* start, const char* end)
  {
    assert(method_ == kInvalid);
    string m(start, end);
    if (m == &quot;GET&quot;)
    {
      method_ = kGet;
    }
    else if (m == &quot;POST&quot;)
    {
      method_ = kPost;
    }
    else if (m == &quot;HEAD&quot;)
    {
      method_ = kHead;
    }
    else if (m == &quot;PUT&quot;)
    {
      method_ = kPut;
    }
    else if (m == &quot;DELETE&quot;)
    {
      method_ = kDelete;
    }
    else
    {
      method_ = kInvalid;
    }
    return method_ != kInvalid;
  }
 
/*返回请求方法*/
  Method method() const
  { return method_; }
 
/*请求方法转为字符串*/
  const char* methodString() const
  {
    const char* result = &quot;UNKNOWN&quot;;
    switch(method_)
    {
      case kGet:
        result = &quot;GET&quot;;
        break;
      case kPost:
        result = &quot;POST&quot;;
        break;
      case kHead:
        result = &quot;HEAD&quot;;
        break;
      case kPut:
        result = &quot;PUT&quot;;
        break;
      case kDelete:
        result = &quot;DELETE&quot;;
        break;
      default:
        break;
    }
    return result;
  }
 
/*设置请求路径*/
  void setPath(const char* start, const char* end)
  {
    path_.assign(start, end);
  }
 
/*返回请求路径*/
  const string&amp; path() const
  { return path_; }
 
/*设置接收时间*/
  void setReceiveTime(Timestamp t)
  { receiveTime_ = t; }
 
  Timestamp receiveTime() const
  { return receiveTime_; }
 
/*添加一个头部信息*/
  /*
Accept-Language(start):(colon) zh-CN(end)
 
--&gt;Accept-Language
   zh-CN
*/
  void addHeader(const char* start, const char* colon, const char* end)
  {
    string field(start, colon);     // header域
    ++colon;
    // 去除左空格
    while (colon &lt; end &amp;&amp; isspace(*colon))
    {
      ++colon;
    }
    string value(colon, end);       // header值
    // 去除右空格
    while (!value.empty() &amp;&amp; isspace(value[value.size()-1]))
    {
      value.resize(value.size()-1);
    }
    headers_[field] = value;
  }
 
/*根据头域，获得头域的信息*/
  string getHeader(const string&amp; field) const
  {
    string result;
    std::map&lt;string, string&gt;::const_iterator it = headers_.find(field);
    if (it != headers_.end())
    {
      result = it-&gt;second;
    }
    return result;
  }
 
  const std::map&lt;string, string&gt;&amp; headers() const
  { return headers_; }
 
  void swap(HttpRequest&amp; that)
  {
    /*貌似少了version的交换*/
    std::swap(method_, that.method_);
    path_.swap(that.path_);
    receiveTime_.swap(that.receiveTime_);
    headers_.swap(that.headers_);
  }
 
 private:
  Method method_;       // 请求方法
  Version version_;     // 协议版本1.0/1.1
  string path_;         // 请求路径
  Timestamp receiveTime_;   // 请求时间
  std::map&lt;string, string&gt; headers_;  // header列表
};
 
}
}
 
#endif  // MUDUO_NET_HTTP_HTTPREQUEST_H
</code></pre>

<h3 id="httpresponse头文件">HttpResponse头文件</h3>

<p>HttpResponse.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_HTTP_HTTPRESPONSE_H
#define MUDUO_NET_HTTP_HTTPRESPONSE_H
 
#include &lt;muduo/base/copyable.h&gt;
#include &lt;muduo/base/Types.h&gt;
 
#include &lt;map&gt;
 
namespace muduo
{
namespace net
{
 
class Buffer;
class HttpResponse : public muduo::copyable
{
 public:
  enum HttpStatusCode
  {
    kUnknown,
    k200Ok = 200,       // 成功
    k301MovedPermanently = 301,     // 301重定向，请求的页面永久性移至另一个地址
    k400BadRequest = 400,           // 错误的请求，语法格式有错，服务器无法处理此请求
    k404NotFound = 404,     // 请求的网页不存在
  };
 
  explicit HttpResponse(bool close)
    : statusCode_(kUnknown),
      closeConnection_(close)
  {
  }
 
  void setStatusCode(HttpStatusCode code)
  { statusCode_ = code; }
 
  void setStatusMessage(const string&amp; message)
  { statusMessage_ = message; }
 
  void setCloseConnection(bool on)
  { closeConnection_ = on; }
 
  bool closeConnection() const
  { return closeConnection_; }
 
  // 设置文档媒体类型（MIME）
  void setContentType(const string&amp; contentType)
  { addHeader(&quot;Content-Type&quot;, contentType); }
 
  // FIXME: replace string with StringPiece
  void addHeader(const string&amp; key, const string&amp; value)
  { headers_[key] = value; }
 
  void setBody(const string&amp; body)
  { body_ = body; }
 
  void appendToBuffer(Buffer* output) const;    // 将HttpResponse添加到Buffer
 
 private:
  std::map&lt;string, string&gt; headers_;  // header列表
  HttpStatusCode statusCode_;           // 状态响应码
  // FIXME: add http version
  string statusMessage_;                // 状态响应码对应的文本信息
  bool closeConnection_;                // 是否关闭连接
  string body_;                         // 实体
};
 
}
}
 
#endif  // MUDUO_NET_HTTP_HTTPRESPONSE_H
</code></pre>

<h3 id="httpresponse源文件">HttpResponse源文件</h3>

<p>HttpResponse.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
 
#include &lt;muduo/net/http/HttpResponse.h&gt;
#include &lt;muduo/net/Buffer.h&gt;
 
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
void HttpResponse::appendToBuffer(Buffer* output) const
{
  char buf[32];
  // 添加响应头
  snprintf(buf, sizeof buf, &quot;HTTP/1.1 %d &quot;, statusCode_);
  output-&gt;append(buf);
  output-&gt;append(statusMessage_);
  output-&gt;append(&quot;\r\n&quot;);
 
  if (closeConnection_)
  {
    // 如果是短连接，不需要告诉浏览器Content-Length，浏览器也能正确处理
    // 短链接不会出现粘包问题
    output-&gt;append(&quot;Connection: close\r\n&quot;);
  }
  else
  {
    snprintf(buf, sizeof buf, &quot;Content-Length: %zd\r\n&quot;, body_.size()); // 实体长度
    output-&gt;append(buf);
    output-&gt;append(&quot;Connection: Keep-Alive\r\n&quot;);
  }
 
  // header列表
  for (std::map&lt;string, string&gt;::const_iterator it = headers_.begin();
       it != headers_.end();
       ++it)
  {
    output-&gt;append(it-&gt;first);
    output-&gt;append(&quot;: &quot;);
    output-&gt;append(it-&gt;second);
    output-&gt;append(&quot;\r\n&quot;);
  }
 
  output-&gt;append(&quot;\r\n&quot;);    // header与body之间的空行
  output-&gt;append(body_);
}
</code></pre>

<h3 id="httpcontext文件">HttpContext文件</h3>

<p>HttpContext.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is an internal header file, you should not include this.
 
#ifndef MUDUO_NET_HTTP_HTTPCONTEXT_H
#define MUDUO_NET_HTTP_HTTPCONTEXT_H
 
#include &lt;muduo/base/copyable.h&gt;
 
#include &lt;muduo/net/http/HttpRequest.h&gt;
 
namespace muduo
{
namespace net
{
 
class HttpContext : public muduo::copyable
{
 public:
  enum HttpRequestParseState
  {
    kExpectRequestLine,//正处于请求行的状态
    kExpectHeaders,   //正处于请求头的状态
    kExpectBody,      //正处于请求实体的状态
    kGotAll,          //全部都解析完毕
  };
 
  HttpContext()
    : state_(kExpectRequestLine)
  {
  }
 
  // default copy-ctor, dtor and assignment are fine
 
  bool expectRequestLine() const
  { return state_ == kExpectRequestLine; }
 
  bool expectHeaders() const
  { return state_ == kExpectHeaders; }
 
  bool expectBody() const
  { return state_ == kExpectBody; }
 
  bool gotAll() const
  { return state_ == kGotAll; }
 
  void receiveRequestLine()
  { state_ = kExpectHeaders; }
  /*注意这里没有处理body实体的请求*/
  void receiveHeaders()
  { state_ = kGotAll; }  // FIXME
 
  // 重置HttpContext状态
  void reset()
  {
    state_ = kExpectRequestLine;
    HttpRequest dummy;
    request_.swap(dummy);
  }
 
  const HttpRequest&amp; request() const
  { return request_; }
 
  HttpRequest&amp; request()
  { return request_; }
 
 private:
  HttpRequestParseState state_;     // 请求解析状态
  HttpRequest request_;             // http请求
};
 
}
}
 
#endif  // MUDUO_NET_HTTP_HTTPCONTEXT_H
</code></pre>

<h3 id="httpserver头文件">HttpServer头文件</h3>

<p>HttpServer.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_HTTP_HTTPSERVER_H
#define MUDUO_NET_HTTP_HTTPSERVER_H
 
#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;boost/noncopyable.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class HttpRequest;
class HttpResponse;
 
/// A simple embeddable HTTP server designed for report status of a program.
/// It is not a fully HTTP 1.1 compliant server, but provides minimum features
/// that can communicate with HttpClient and Web browser.
/// It is synchronous, just like Java Servlet.
class HttpServer : boost::noncopyable
{
 public:
  typedef boost::function&lt;void (const HttpRequest&amp;,
                                HttpResponse*)&gt; HttpCallback;
 
  HttpServer(EventLoop* loop,
             const InetAddress&amp; listenAddr,
             const string&amp; name);
 
  ~HttpServer();  // force out-line dtor, for scoped_ptr members.
 
  /// Not thread safe, callback be registered before calling start().
  void setHttpCallback(const HttpCallback&amp; cb)
  {
    httpCallback_ = cb;
  }
 
  /*subIO thread numbers*/
  void setThreadNum(int numThreads)
  {
    server_.setThreadNum(numThreads);
  }
 
  void start();
 
 private:
  void onConnection(const TcpConnectionPtr&amp; conn);
  /*当以http请求到来时
onMessage---&gt;onRequest---&gt;HttpCallback
  */
  void onMessage(const TcpConnectionPtr&amp; conn,
                 Buffer* buf,
                 Timestamp receiveTime);
  void onRequest(const TcpConnectionPtr&amp;, const HttpRequest&amp;);
 
  TcpServer server_;
  HttpCallback httpCallback_;   // 在处理http请求（即调用onRequest）的过程中回调此函数，对请求进行具体的处理
};
 
}
}
 
#endif  // MUDUO_NET_HTTP_HTTPSERVER_H
````

### HttpServer源文件

HttpServer.cc

``` c++

// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
 
#include &lt;muduo/net/http/HttpServer.h&gt;
 
#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/http/HttpContext.h&gt;
#include &lt;muduo/net/http/HttpRequest.h&gt;
#include &lt;muduo/net/http/HttpResponse.h&gt;
 
#include &lt;boost/bind.hpp&gt;
 
using namespace muduo;
using namespace muduo::net;
/*
GET / HTTP/1.1 (请求行)
Accept: image/jpeg, application/x-ms-application, image/gif, application/xaml+xml, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword(请求头)
Accept-Language: zh-CN(请求头)
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; Tablet PC 2.0)(请求头)
Accept-Encoding: gzip, deflate(请求头)
Host: 192.168.159.188:800(请求头)
Connection: Keep-Alive(请求头)
 
*/
namespace muduo
{
namespace net
{
namespace detail
{
 
// FIXME: move to HttpContext class
bool processRequestLine(const char* begin, const char* end, HttpContext* context)
{
  bool succeed = false;
  const char* start = begin;
  const char* space = std::find(start, end, ' ');
  HttpRequest&amp; request = context-&gt;request();
  if (space != end &amp;&amp; request.setMethod(start, space))      // 解析请求方法
  {
    start = space+1;
    space = std::find(start, end, ' ');
    if (space != end)
    {
      request.setPath(start, space);    // 解析PATH
      start = space+1;
      succeed = end-start == 8 &amp;&amp; std::equal(start, end-1, &quot;HTTP/1.&quot;);
      if (succeed)
      {
        if (*(end-1) == '1')
        {
          request.setVersion(HttpRequest::kHttp11);     // HTTP/1.1
        }
        else if (*(end-1) == '0')
        {
          request.setVersion(HttpRequest::kHttp10);     // HTTP/1.0
        }
        else
        {
          succeed = false;
        }
      }
    }
  }
  return succeed;
}
 
// FIXME: move to HttpContext class
// return false if any error
// 开始解析请求
bool parseRequest(Buffer* buf, HttpContext* context, Timestamp receiveTime)
{
  bool ok = true;
  bool hasMore = true;
  while (hasMore)
  {
    if (context-&gt;expectRequestLine())    // 处于解析请求行状态
    {
      const char* crlf = buf-&gt;findCRLF();
      if (crlf)
      {
        ok = processRequestLine(buf-&gt;peek(), crlf, context); // 解析请求行 ，*crlf ='\r'
        if (ok)
        {
          context-&gt;request().setReceiveTime(receiveTime);        // 设置请求时间
          buf-&gt;retrieveUntil(crlf + 2);      // 将请求行从buf中取回，包括\r\n
          context-&gt;receiveRequestLine(); // 将HttpContext状态改为kExpectHeaders
        }
        else
        {
          hasMore = false;
        }
      }
      else
      {
        hasMore = false;
      }
    }
    else if (context-&gt;expectHeaders())       // 解析header
    {
      const char* crlf = buf-&gt;findCRLF();
      if (crlf)
      {
        const char* colon = std::find(buf-&gt;peek(), crlf, ':');       //冒号所在位置
        if (colon != crlf)
        {
          context-&gt;request().addHeader(buf-&gt;peek(), colon, crlf);
        }
        else
        {
          // empty line, end of header
          context-&gt;receiveHeaders();     // HttpContext将状态改为kGotAll
          hasMore = !context-&gt;gotAll();
        }
        buf-&gt;retrieveUntil(crlf + 2);        // 将header从buf中取回，包括\r\n
      }
      else
      {
        hasMore = false;
      }
    }
    else if (context-&gt;expectBody())          // 当前还不支持请求中带body
    {
      // FIXME:
    }
  }
  return ok;
}
 
void defaultHttpCallback(const HttpRequest&amp;, HttpResponse* resp)
{
  resp-&gt;setStatusCode(HttpResponse::k404NotFound);
  resp-&gt;setStatusMessage(&quot;Not Found&quot;);
  resp-&gt;setCloseConnection(true);
}
 
}
}
}
 
HttpServer::HttpServer(EventLoop* loop,
                       const InetAddress&amp; listenAddr,
                       const string&amp; name)
  : server_(loop, listenAddr, name),
    httpCallback_(detail::defaultHttpCallback)
{
  server_.setConnectionCallback(
      boost::bind(&amp;HttpServer::onConnection, this, _1));
  server_.setMessageCallback(
      boost::bind(&amp;HttpServer::onMessage, this, _1, _2, _3));
}
 
HttpServer::~HttpServer()
{
}
 
void HttpServer::start()
{
  LOG_WARN &lt;&lt; &quot;HttpServer[&quot; &lt;&lt; server_.name()
    &lt;&lt; &quot;] starts listenning on &quot; &lt;&lt; server_.hostport();
  server_.start();
}
 
void HttpServer::onConnection(const TcpConnectionPtr&amp; conn)
{
  if (conn-&gt;connected())
  {
    //boost any
    conn-&gt;setContext(HttpContext()); // TcpConnection与一个HttpContext绑定
  }
}
 
void HttpServer::onMessage(const TcpConnectionPtr&amp; conn,
                           Buffer* buf,
                           Timestamp receiveTime)
{
  HttpContext* context = boost::any_cast&lt;HttpContext&gt;(conn-&gt;getMutableContext());
 
  if (!detail::parseRequest(buf, context, receiveTime))
  {
    conn-&gt;send(&quot;HTTP/1.1 400 Bad Request\r\n\r\n&quot;);
    conn-&gt;shutdown();
  }
 
  // 请求消息解析完毕
  if (context-&gt;gotAll())
  {
    onRequest(conn, context-&gt;request());
    context-&gt;reset();        // 本次请求处理完毕，重置HttpContext，适用于长连接
  }
}
 
void HttpServer::onRequest(const TcpConnectionPtr&amp; conn, const HttpRequest&amp; req)
{
  const string&amp; connection = req.getHeader(&quot;Connection&quot;);
  //是否关闭连接
  bool close = connection == &quot;close&quot; ||
    (req.getVersion() == HttpRequest::kHttp10 &amp;&amp; connection != &quot;Keep-Alive&quot;);
  HttpResponse response(close);
  httpCallback_(req, &amp;response);//回调用户函数
  Buffer buf;
  response.appendToBuffer(&amp;buf);
  conn-&gt;send(&amp;buf);
  if (response.closeConnection())
  {
    conn-&gt;shutdown();
  }
}
</code></pre>

<h3 id="测试程序-5">测试程序</h3>

<pre><code class="language-c++">#include &lt;muduo/net/http/HttpServer.h&gt;
#include &lt;muduo/net/http/HttpRequest.h&gt;
#include &lt;muduo/net/http/HttpResponse.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/base/Logging.h&gt;
 
#include &lt;iostream&gt;
#include &lt;map&gt;
 
using namespace muduo;
using namespace muduo::net;
 
extern char favicon[555];
bool benchmark = false;
 
// 实际的请求处理
void onRequest(const HttpRequest&amp; req, HttpResponse* resp)
{
  std::cout &lt;&lt; &quot;Headers &quot; &lt;&lt; req.methodString() &lt;&lt; &quot; &quot; &lt;&lt; req.path() &lt;&lt; std::endl;
  if (!benchmark)
  {
    const std::map&lt;string, string&gt;&amp; headers = req.headers();
    for (std::map&lt;string, string&gt;::const_iterator it = headers.begin();
         it != headers.end();
         ++it)
    {
      std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;
    }
  }
 
  if (req.path() == &quot;/&quot;)
  {
    resp-&gt;setStatusCode(HttpResponse::k200Ok);
    resp-&gt;setStatusMessage(&quot;OK&quot;);
    resp-&gt;setContentType(&quot;text/html&quot;);
    resp-&gt;addHeader(&quot;Server&quot;, &quot;Muduo&quot;);
    string now = Timestamp::now().toFormattedString();
    resp-&gt;setBody(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;This is title&lt;/title&gt;&lt;/head&gt;&quot;
        &quot;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;Now is &quot; + now +
        &quot;&lt;/body&gt;&lt;/html&gt;&quot;);
  }
  else if (req.path() == &quot;/favicon.ico&quot;)
  {
    resp-&gt;setStatusCode(HttpResponse::k200Ok);
    resp-&gt;setStatusMessage(&quot;OK&quot;);
    resp-&gt;setContentType(&quot;image/png&quot;);
    resp-&gt;setBody(string(favicon, sizeof favicon));
  }
  else if (req.path() == &quot;/hello&quot;)
  {
    resp-&gt;setStatusCode(HttpResponse::k200Ok);
    resp-&gt;setStatusMessage(&quot;OK&quot;);
    resp-&gt;setContentType(&quot;text/plain&quot;);
    resp-&gt;addHeader(&quot;Server&quot;, &quot;Muduo&quot;);
    resp-&gt;setBody(&quot;hello, world!\n&quot;);
  }
  else
  {
    resp-&gt;setStatusCode(HttpResponse::k404NotFound);
    resp-&gt;setStatusMessage(&quot;Not Found&quot;);
    resp-&gt;setCloseConnection(true);
  }
}
 
int main(int argc, char* argv[])
{
  int numThreads = 0;
  if (argc &gt; 1)
  {
    benchmark = true;
    Logger::setLogLevel(Logger::WARN);
    numThreads = atoi(argv[1]);
  }
  EventLoop loop;
  HttpServer server(&amp;loop, InetAddress(8000), &quot;dummy&quot;);
  server.setHttpCallback(onRequest);
  server.setThreadNum(numThreads);
  server.start();
  loop.loop();
}
 
// 这是一个图片数据
char favicon[555] = {
  '\x89', 'P', 'N', 'G', '\xD', '\xA', '\x1A', '\xA',
  '\x0', '\x0', '\x0', '\xD', 'I', 'H', 'D', 'R',
  '\x0', '\x0', '\x0', '\x10', '\x0', '\x0', '\x0', '\x10',
  '\x8', '\x6', '\x0', '\x0', '\x0', '\x1F', '\xF3', '\xFF',
  'a', '\x0', '\x0', '\x0', '\x19', 't', 'E', 'X',
  't', 'S', 'o', 'f', 't', 'w', 'a', 'r',
  'e', '\x0', 'A', 'd', 'o', 'b', 'e', '\x20',
  'I', 'm', 'a', 'g', 'e', 'R', 'e', 'a',
  'd', 'y', 'q', '\xC9', 'e', '\x3C', '\x0', '\x0',
  '\x1', '\xCD', 'I', 'D', 'A', 'T', 'x', '\xDA',
  '\x94', '\x93', '9', 'H', '\x3', 'A', '\x14', '\x86',
  '\xFF', '\x5D', 'b', '\xA7', '\x4', 'R', '\xC4', 'm',
  '\x22', '\x1E', '\xA0', 'F', '\x24', '\x8', '\x16', '\x16',
  'v', '\xA', '6', '\xBA', 'J', '\x9A', '\x80', '\x8',
  'A', '\xB4', 'q', '\x85', 'X', '\x89', 'G', '\xB0',
  'I', '\xA9', 'Q', '\x24', '\xCD', '\xA6', '\x8', '\xA4',
  'H', 'c', '\x91', 'B', '\xB', '\xAF', 'V', '\xC1',
  'F', '\xB4', '\x15', '\xCF', '\x22', 'X', '\x98', '\xB',
  'T', 'H', '\x8A', 'd', '\x93', '\x8D', '\xFB', 'F',
  'g', '\xC9', '\x1A', '\x14', '\x7D', '\xF0', 'f', 'v',
  'f', '\xDF', '\x7C', '\xEF', '\xE7', 'g', 'F', '\xA8',
  '\xD5', 'j', 'H', '\x24', '\x12', '\x2A', '\x0', '\x5',
  '\xBF', 'G', '\xD4', '\xEF', '\xF7', '\x2F', '6', '\xEC',
  '\x12', '\x20', '\x1E', '\x8F', '\xD7', '\xAA', '\xD5', '\xEA',
  '\xAF', 'I', '5', 'F', '\xAA', 'T', '\x5F', '\x9F',
  '\x22', 'A', '\x2A', '\x95', '\xA', '\x83', '\xE5', 'r',
  '9', 'd', '\xB3', 'Y', '\x96', '\x99', 'L', '\x6',
  '\xE9', 't', '\x9A', '\x25', '\x85', '\x2C', '\xCB', 'T',
  '\xA7', '\xC4', 'b', '1', '\xB5', '\x5E', '\x0', '\x3',
  'h', '\x9A', '\xC6', '\x16', '\x82', '\x20', 'X', 'R',
  '\x14', 'E', '6', 'S', '\x94', '\xCB', 'e', 'x',
  '\xBD', '\x5E', '\xAA', 'U', 'T', '\x23', 'L', '\xC0',
  '\xE0', '\xE2', '\xC1', '\x8F', '\x0', '\x9E', '\xBC', '\x9',
  'A', '\x7C', '\x3E', '\x1F', '\x83', 'D', '\x22', '\x11',
  '\xD5', 'T', '\x40', '\x3F', '8', '\x80', 'w', '\xE5',
  '3', '\x7', '\xB8', '\x5C', '\x2E', 'H', '\x92', '\x4',
  '\x87', '\xC3', '\x81', '\x40', '\x20', '\x40', 'g', '\x98',
  '\xE9', '6', '\x1A', '\xA6', 'g', '\x15', '\x4', '\xE3',
  '\xD7', '\xC8', '\xBD', '\x15', '\xE1', 'i', '\xB7', 'C',
  '\xAB', '\xEA', 'x', '\x2F', 'j', 'X', '\x92', '\xBB',
  '\x18', '\x20', '\x9F', '\xCF', '3', '\xC3', '\xB8', '\xE9',
  'N', '\xA7', '\xD3', 'l', 'J', '\x0', 'i', '6',
  '\x7C', '\x8E', '\xE1', '\xFE', 'V', '\x84', '\xE7', '\x3C',
  '\x9F', 'r', '\x2B', '\x3A', 'B', '\x7B', '7', 'f',
  'w', '\xAE', '\x8E', '\xE', '\xF3', '\xBD', 'R', '\xA9',
  'd', '\x2', 'B', '\xAF', '\x85', '2', 'f', 'F',
  '\xBA', '\xC', '\xD9', '\x9F', '\x1D', '\x9A', 'l', '\x22',
  '\xE6', '\xC7', '\x3A', '\x2C', '\x80', '\xEF', '\xC1', '\x15',
  '\x90', '\x7', '\x93', '\xA2', '\x28', '\xA0', 'S', 'j',
  '\xB1', '\xB8', '\xDF', '\x29', '5', 'C', '\xE', '\x3F',
  'X', '\xFC', '\x98', '\xDA', 'y', 'j', 'P', '\x40',
  '\x0', '\x87', '\xAE', '\x1B', '\x17', 'B', '\xB4', '\x3A',
  '\x3F', '\xBE', 'y', '\xC7', '\xA', '\x26', '\xB6', '\xEE',
  '\xD9', '\x9A', '\x60', '\x14', '\x93', '\xDB', '\x8F', '\xD',
  '\xA', '\x2E', '\xE9', '\x23', '\x95', '\x29', 'X', '\x0',
  '\x27', '\xEB', 'n', 'V', 'p', '\xBC', '\xD6', '\xCB',
  '\xD6', 'G', '\xAB', '\x3D', 'l', '\x7D', '\xB8', '\xD2',
  '\xDD', '\xA0', '\x60', '\x83', '\xBA', '\xEF', '\x5F', '\xA4',
  '\xEA', '\xCC', '\x2', 'N', '\xAE', '\x5E', 'p', '\x1A',
  '\xEC', '\xB3', '\x40', '9', '\xAC', '\xFE', '\xF2', '\x91',
  '\x89', 'g', '\x91', '\x85', '\x21', '\xA8', '\x87', '\xB7',
  'X', '\x7E', '\x7E', '\x85', '\xBB', '\xCD', 'N', 'N',
  'b', 't', '\x40', '\xFA', '\x93', '\x89', '\xEC', '\x1E',
  '\xEC', '\x86', '\x2', 'H', '\x26', '\x93', '\xD0', 'u',
  '\x1D', '\x7F', '\x9', '2', '\x95', '\xBF', '\x1F', '\xDB',
  '\xD7', 'c', '\x8A', '\x1A', '\xF7', '\x5C', '\xC1', '\xFF',
  '\x22', 'J', '\xC3', '\x87', '\x0', '\x3', '\x0', 'K',
  '\xBB', '\xF8', '\xD6', '\x2A', 'v', '\x98', 'I', '\x0',
  '\x0', '\x0', '\x0', 'I', 'E', 'N', 'D', '\xAE',
  'B', '\x60', '\x82',
};
</code></pre>

<h2 id="41-muduo-inspect库源码分析">[41] muduo_inspect库源码分析</h2>

<ul>
<li>muduo_inspect库通过HTTP方式为服务器提供监控接口</li>
<li>接受了多少个TCP连接</li>
<li>当前有多少个活动连接</li>
<li>一共响应了多少次请求</li>

<li><p>每次请求的平均响应时间多少毫秒</p></li>

<li><p>Inspector     // 包含了一个HttpServer对象</p></li>

<li><p>ProcessInspector // 通过ProcessInfo返回进程信息</p></li>

<li><p>ProcessInfo // 获取进程相关信息</p></li>
</ul>

<h3 id="processinspectort头文件">ProcessInspectort头文件</h3>

<p>ProcessInspector.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is an internal header file, you should not include this.
 
#ifndef MUDUO_NET_INSPECT_PROCESSINSPECTOR_H
#define MUDUO_NET_INSPECT_PROCESSINSPECTOR_H
 
#include &lt;muduo/net/inspect/Inspector.h&gt;
#include &lt;boost/noncopyable.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class ProcessInspector : boost::noncopyable
{
 public:
  void registerCommands(Inspector* ins);    // 注册命令接口
 
 private:
  static string pid(HttpRequest::Method, const Inspector::ArgList&amp;);
  static string procStatus(HttpRequest::Method, const Inspector::ArgList&amp;);
  static string openedFiles(HttpRequest::Method, const Inspector::ArgList&amp;);
  static string threads(HttpRequest::Method, const Inspector::ArgList&amp;);
 
};
 
}
}
 
#endif  // MUDUO_NET_INSPECT_PROCESSINSPECTOR_H
</code></pre>

<h3 id="processinspectort源文件">ProcessInspectort源文件</h3>

<p>ProcessInspector.cc</p>

<pre><code>// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
 
#include &lt;muduo/net/inspect/ProcessInspector.h&gt;
#include &lt;muduo/base/ProcessInfo.h&gt;
#include &lt;stdio.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
/*命令注册*/
void ProcessInspector::registerCommands(Inspector* ins)
{
  /*muduo             :   proc
    command           :   pid
    commandCallback   :   pid
    commnadHelp       :   print id
  */
  ins-&gt;add(&quot;proc&quot;, &quot;pid&quot;, ProcessInspector::pid, &quot;print pid&quot;);
  ins-&gt;add(&quot;proc&quot;, &quot;status&quot;, ProcessInspector::procStatus, &quot;print /proc/self/status&quot;);
  ins-&gt;add(&quot;proc&quot;, &quot;opened_files&quot;, ProcessInspector::openedFiles, &quot;count /proc/self/fd&quot;);
  ins-&gt;add(&quot;proc&quot;, &quot;threads&quot;, ProcessInspector::threads, &quot;list /proc/self/task&quot;);
}
 
string ProcessInspector::pid(HttpRequest::Method, const Inspector::ArgList&amp;)
{
  char buf[32];
  snprintf(buf, sizeof buf, &quot;%d&quot;, ProcessInfo::pid());
  return buf;
}
 
string ProcessInspector::procStatus(HttpRequest::Method, const Inspector::ArgList&amp;)
{
  return ProcessInfo::procStatus();
}
 
string ProcessInspector::openedFiles(HttpRequest::Method, const Inspector::ArgList&amp;)
{
  char buf[32];
  snprintf(buf, sizeof buf, &quot;%d&quot;, ProcessInfo::openedFiles());
  return buf;
}
 
string ProcessInspector::threads(HttpRequest::Method, const Inspector::ArgList&amp;)
{
  std::vector&lt;pid_t&gt; threads = ProcessInfo::threads();
  string result;
  for (size_t i = 0; i &lt; threads.size(); ++i)
  {
    char buf[32];
    snprintf(buf, sizeof buf, &quot;%d\n&quot;, threads[i]);
    result += buf;
  }
  return result;
}
</code></pre>

<h3 id="inspector头文件">Inspector头文件</h3>

<p>Inspector.h</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
// This is a public header file, it must only include public header files.
 
#ifndef MUDUO_NET_INSPECT_INSPECTOR_H
#define MUDUO_NET_INSPECT_INSPECTOR_H
 
#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/net/http/HttpRequest.h&gt;
#include &lt;muduo/net/http/HttpServer.h&gt;
 
#include &lt;map&gt;
#include &lt;boost/function.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
 
namespace muduo
{
namespace net
{
 
class ProcessInspector;
 
// A internal inspector of the running process, usually a singleton.
class Inspector : boost::noncopyable
{
 public:
  typedef std::vector&lt;string&gt; ArgList;
  typedef boost::function&lt;string (HttpRequest::Method, const ArgList&amp; args)&gt; Callback;
  Inspector(EventLoop* loop,
            const InetAddress&amp; httpAddr,
            const string&amp; name);
  ~Inspector();
 
  // 如add(&quot;proc&quot;, &quot;pid&quot;, ProcessInspector::pid, &quot;print pid&quot;);
  // http://192.168.159.188:12345/proc/pid这个http请求就会相应的调用ProcessInspector::pid来处理
  void add(const string&amp; module,
           const string&amp; command,
           const Callback&amp; cb,
           const string&amp; help);
 
 private:
  typedef std::map&lt;string, Callback&gt; CommandList;
  typedef std::map&lt;string, string&gt; HelpList;
 
  void start();
  void onRequest(const HttpRequest&amp; req, HttpResponse* resp);
 
  HttpServer server_;
  boost::scoped_ptr&lt;ProcessInspector&gt; processInspector_;
  MutexLock mutex_;
  std::map&lt;string, CommandList&gt; commands_;
  std::map&lt;string, HelpList&gt; helps_;
  /*
commands_ --- &gt; &lt;muduo commandlist&gt;
helps_    ----&gt; &lt;muduo helplist&gt;
 
commandlist---&gt; &lt;command callback&gt;
HelpList  ----&gt; &lt;command helplist&gt;
 
commands_[][]=xx
helps_[][]=xxx
 
  */
};
 
}
}
 
#endif  // MUDUO_NET_INSPECT_INSPECTOR_H
</code></pre>

<h3 id="inspector源文件">Inspector源文件</h3>

<p>Inspector.cc</p>

<pre><code class="language-c++">// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.
 
// Author: Shuo Chen (chenshuo at chenshuo dot com)
//
 
#include &lt;muduo/net/inspect/Inspector.h&gt;
 
#include &lt;muduo/base/Thread.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/http/HttpRequest.h&gt;
#include &lt;muduo/net/http/HttpResponse.h&gt;
#include &lt;muduo/net/inspect/ProcessInspector.h&gt;
 
//#include &lt;iostream&gt;
//#include &lt;iterator&gt;
//#include &lt;sstream&gt;
#include &lt;boost/bind.hpp&gt;
#include &lt;boost/algorithm/string/classification.hpp&gt;
#include &lt;boost/algorithm/string/split.hpp&gt;
 
using namespace muduo;
using namespace muduo::net;
 
namespace
{
Inspector* g_globalInspector = 0;
 
// Looks buggy
std::vector&lt;string&gt; split(const string&amp; str)
{
  std::vector&lt;string&gt; result;
  size_t start = 0;
  size_t pos = str.find('/');
  while (pos != string::npos)
  {
    if (pos &gt; start)
    {
      result.push_back(str.substr(start, pos-start));
    }
    start = pos+1;
    pos = str.find('/', start);
  }
 
  if (start &lt; str.length())      // 说明最后一个字符不是'/'
  {
    result.push_back(str.substr(start));
  }
 
  return result;
}
 
}
 
Inspector::Inspector(EventLoop* loop,
                     const InetAddress&amp; httpAddr,
                     const string&amp; name)
    : server_(loop, httpAddr, &quot;Inspector:&quot;+name),
      processInspector_(new ProcessInspector)
{
  //断言在主线程当中
  assert(CurrentThread::isMainThread());
  assert(g_globalInspector == 0);
  g_globalInspector = this;
  /*设置请求的回调函数，这里的请求是完成了协议的解析之后*/
  server_.setHttpCallback(boost::bind(&amp;Inspector::onRequest, this, _1, _2));
  /*注册命令*/
  processInspector_-&gt;registerCommands(this);
  // 这样子做法是为了防止竞态问题
  // 如果直接调用start，（当前线程不是loop所属的IO线程，是主线程）那么有可能，当前构造函数还没返回，
  // HttpServer所在的IO线程可能已经收到了http客户端的请求了（因为这时候HttpServer已启动），那么就会回调
  // Inspector::onRequest，而这时候构造函数还没返回，也就是说对象还没完全构造好。那么就会出现问题了
  loop-&gt;runAfter(0, boost::bind(&amp;Inspector::start, this)); // little race condition
}
 
Inspector::~Inspector()
{
  assert(CurrentThread::isMainThread());
  g_globalInspector = NULL;
}
 
void Inspector::add(const string&amp; module,
                    const string&amp; command,
                    const Callback&amp; cb,
                    const string&amp; help)
{
  /*这里要不要加锁？？
因为在构造函数时 程序是注册完 processInspector_-&gt;registerCommands(this); 才执行
loop-&gt;runAfter(0, boost::bind(&amp;Inspector::start, this)); // little race condition。
 
如果程序进行扩充时，就要了。
class TcpInspector : boost::noncopyable
{
 public:
  void registerCommands(Inspector* ins);  // 注册命令接口
 
 private:
  static string pid(HttpRequest::Method, const Inspector::ArgList&amp;);
  static string procStatus(HttpRequest::Method, const Inspector::ArgList&amp;);
  static string openedFiles(HttpRequest::Method, const Inspector::ArgList&amp;);
  static string threads(HttpRequest::Method, const Inspector::ArgList&amp;);
 
};
 
MyInspector ：public ProcessInspector
{
   TcpInspector
} ;
那么
MyInspector{
 
  HttpServer server_;
  boost::scoped_ptr&lt;ProcessInspector&gt; processInspector;
  boost::scoped_ptr&lt;ProcessInspector&gt; TcpInspector;
  MutexLock mutex_;
  std::map&lt;string, CommandList&gt; commands_;
  std::map&lt;string, HelpList&gt; helps_;
}
那么MyInspector 在初始化时，会初始化ProcessInspector 和TcpInspector，
如果ProcessInspector初始化完毕后，启动了OnreRequest(),而TcpInspector还没注册完，
也就是说TcpInspector还在add（）函数中，那么不加锁的话，就会出现问题了。
  */
  MutexLockGuard lock(mutex_);
  commands_[module][command] = cb;
  helps_[module][command] = help;
}
 
void Inspector::start()
{
  server_.start();
}
 
void Inspector::onRequest(const HttpRequest&amp; req, HttpResponse* resp)
{
  if (req.path() == &quot;/&quot;)
  {
    string result;
    MutexLockGuard lock(mutex_);
    // 遍历helps
    for (std::map&lt;string, HelpList&gt;::const_iterator helpListI = helps_.begin();
         helpListI != helps_.end();
         ++helpListI)
    {
      const HelpList&amp; list = helpListI-&gt;second;
      for (HelpList::const_iterator it = list.begin();
           it != list.end();
           ++it)
      {
        result += &quot;/&quot;;
        result += helpListI-&gt;first;      // module
        result += &quot;/&quot;;
        result += it-&gt;first;         // command
        result += &quot;\t&quot;;
        result += it-&gt;second;            // help
        result += &quot;\n&quot;;
      }
    }
    resp-&gt;setStatusCode(HttpResponse::k200Ok);
    resp-&gt;setStatusMessage(&quot;OK&quot;);
    resp-&gt;setContentType(&quot;text/plain&quot;);
    resp-&gt;setBody(result);
  }
  else
  {
    // 以&quot;/&quot;进行分割，将得到的字符串保存在result中
    std::vector&lt;string&gt; result = split(req.path());
    // boost::split(result, req.path(), boost::is_any_of(&quot;/&quot;));
    //std::copy(result.begin(), result.end(), std::ostream_iterator&lt;string&gt;(std::cout, &quot;, &quot;));
    //std::cout &lt;&lt; &quot;\n&quot;;
    bool ok = false;
    if (result.size() == 0)
    {
      // 这种情况是错误的，因此ok仍为false
    }
    else if (result.size() == 1)
    {
      // 只有module，没有command也是错的，因此ok仍为false
      string module = result[0];
    }
    else
    {
      string module = result[0];
      // 查找module所对应的命令列表
      std::map&lt;string, CommandList&gt;::const_iterator commListI = commands_.find(module);
      if (commListI != commands_.end())
      {
        string command = result[1];
        const CommandList&amp; commList = commListI-&gt;second;
        // 查找command对应的命令
        CommandList::const_iterator it = commList.find(command);
        if (it != commList.end())
        {
          ArgList args(result.begin()+2, result.end());     // 传递给回调函数的参数表
          if (it-&gt;second)
          {
            resp-&gt;setStatusCode(HttpResponse::k200Ok);
            resp-&gt;setStatusMessage(&quot;OK&quot;);
            resp-&gt;setContentType(&quot;text/plain&quot;);
            const Callback&amp; cb = it-&gt;second;
            resp-&gt;setBody(cb(req.method(), args));       // 调用cb将返回的字符串传给setBody
            ok = true;
          }
        }
      }
 
    }
 
    if (!ok)
    {
      resp-&gt;setStatusCode(HttpResponse::k404NotFound);
      resp-&gt;setStatusMessage(&quot;Not Found&quot;);
    }
    //resp-&gt;setCloseConnection(true);
  }
}
</code></pre>

<p>测试程序</p>

<pre><code class="language-c++">#include &lt;muduo/net/inspect/Inspector.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/EventLoopThread.h&gt;
 
using namespace muduo;
using namespace muduo::net;
 
int main()
{
  EventLoop loop;
  EventLoopThread t;    // 监控线程 ，这里“线程该没有真正创建，t.startLoop（）函数才是真正创建”
  /*Inspector 的loop 和main thread 的loop是不一样的，也就是说，现在已经有两个loop了*/
  Inspector ins(t.startLoop(), InetAddress(12345), &quot;test&quot;);
  loop.loop();
}
</code></pre>

<p>在浏览器中输入127.0.0.1:12345/proc/status</p>

<pre><code class="language-c++">Name:   inspector_test
State:  S (sleeping)
Tgid:   2030
Pid:    2030
PPid:   1907
TracerPid:  0
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
FDSize: 256
Groups: 4 20 24 46 116 118 124 1000
VmPeak:    12348 kB
VmSize:    12348 kB
VmLck:         0 kB
VmHWM:      1580 kB
VmRSS:      1580 kB
VmData:     8408 kB
VmStk:       136 kB
VmExe:       860 kB
VmLib:      2868 kB
VmPTE:        32 kB
VmSwap:        0 kB
Threads:    2
SigQ:   0/9772
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000001000
SigCgt: 0000000180000000
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: ffffffffffffffff
Cpus_allowed:   3
Cpus_allowed_list:  0-1
Mems_allowed:   1
Mems_allowed_list:  0
voluntary_ctxt_switches:    22
nonvoluntary_ctxt_switches: 14
</code></pre>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Rg </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://laohanlinux.github.io/2015/07/01/muduo-net-library-chapter-3/>https://laohanlinux.github.io/2015/07/01/muduo-net-library-chapter-3/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://laohanlinux.github.io/tags/muduo/">
                    #muduo</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://laohanlinux.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://laohanlinux.github.io/2015/07/01/muduo-net-library-chapter-2/" class="prev" rel="prev" title="muduo net library chapter 2"><i class="iconfont icon-left"></i>&nbsp;muduo net library chapter 2</a>
         
        
        <a href="https://laohanlinux.github.io/2016/03/13/udon-riak-core/" class="next" rel="next" title="udon_riak_core">udon_riak_core&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
        
<div id="gitalk-container" style="border:0" ></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css/" style="border:0" >
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js/" style="border:0" ></script>
<script>
    const gitalk = new Gitalk({
        clientID: '88e50f263d090b13460f',
    clientSecret: 'f1007eb6cff0af3b461be3a4b73d808ab7058a21',
    repo: 'blog',
    owner: 'laohanlinux',
    admin: ['laohanlinux'],
    id: location.pathname, 
    distractionFreeMode: false 
    })

gitalk.render('gitalk-container')
</script>


    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2014 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://laohanlinux.github.io">Rg</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
